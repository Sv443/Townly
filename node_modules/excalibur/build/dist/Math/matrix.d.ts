import { Vector } from './vector';
export declare enum MatrixLocations {
    X = 12,
    Y = 13
}
/**
 * Excalibur Matrix helper for 4x4 matrices
 *
 * Useful for webgl 4x4 matrices
 */
export declare class Matrix {
    /**
     *  4x4 matrix in column major order
     *
     * |         |         |          |          |
     * | ------- | ------- | -------- |          |
     * | data[0] | data[4] | data[8]  | data[12] |
     * | data[1] | data[5] | data[9]  | data[13] |
     * | data[2] | data[6] | data[10] | data[14] |
     * | data[3] | data[7] | data[11] | data[15] |
     *
     */
    data: Float32Array;
    /**
     * Creates an orthographic (flat non-perspective) projection
     * https://en.wikipedia.org/wiki/Orthographic_projection
     * @param left
     * @param right
     * @param bottom
     * @param top
     * @param near
     * @param far
     */
    static ortho(left: number, right: number, bottom: number, top: number, near: number, far: number): Matrix;
    /**
     * Creates a new Matrix with the same data as the current 4x4
     */
    clone(): Matrix;
    /**
     * Creates a new identity matrix (a matrix that when applied does nothing)
     */
    static identity(): Matrix;
    /**
     * Creates a brand new translation matrix at the specified 3d point
     * @param x
     * @param y
     */
    static translation(x: number, y: number): Matrix;
    /**
     * Creates a brand new scaling matrix with the specified scaling factor
     * @param sx
     * @param sy
     */
    static scale(sx: number, sy: number): Matrix;
    /**
     * Creates a brand new rotation matrix with the specified angle
     * @param angleRadians
     */
    static rotation(angleRadians: number): Matrix;
    /**
     * Multiplies the current matrix by a vector and returns the resulting vector
     * @param other
     */
    multv(other: [number, number]): [number, number];
    multv(other: Vector): Vector;
    /**
     * Multiplies the current matrix by another and returns the resulting matrix
     * @param other
     */
    multm(other: Matrix): Matrix;
    /**
     * Applies translation to the current matrix mutating it
     * @param x
     * @param y
     */
    translate(x: number, y: number): this;
    setPosition(x: number, y: number): void;
    getPosition(): Vector;
    /**
     * Applies rotation to the current matrix mutating it
     * @param angle in Radians
     */
    rotate(angle: number): this;
    /**
     * Applies scaling to the current matrix mutating it
     * @param x
     * @param y
     */
    scale(x: number, y: number): this;
    setRotation(angle: number): void;
    getRotation(): number;
    getScaleX(): number;
    getScaleY(): number;
    /**
     * Get the scale of the matrix
     */
    getScale(): Vector;
    private _scaleSignX;
    setScaleX(val: number): void;
    private _scaleSignY;
    setScaleY(val: number): void;
    setScale(scale: Vector): void;
    /**
     * Determinant of the upper left 2x2 matrix
     */
    getBasisDeterminant(): number;
    getAffineInverse(): Matrix;
    isIdentity(): boolean;
    toString(): string;
}
