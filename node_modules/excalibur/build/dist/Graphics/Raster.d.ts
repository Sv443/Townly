import { Graphic, GraphicOptions } from './Graphic';
import { ExcaliburGraphicsContext } from './Context/ExcaliburGraphicsContext';
import { Color } from '../Color';
import { BoundingBox } from '../Collision/BoundingBox';
export interface RasterOptions {
    smoothing?: boolean;
    color?: Color;
    strokeColor?: Color;
    lineWidth?: number;
    lineDash?: number[];
    padding?: number;
}
/**
 * A Raster is a Graphic that needs to be first painted to a HTMLCanvasElement before it can be drawn to the
 * [[ExcaliburGraphicsContext]]. This is useful for generating custom images using the 2D canvas api.
 *
 * Implementors must implemenet the [[Raster.execute]] method to rasterize their drawing.
 */
export declare abstract class Raster extends Graphic {
    _bitmap: HTMLCanvasElement;
    protected _ctx: CanvasRenderingContext2D;
    private _dirty;
    constructor(options?: GraphicOptions & RasterOptions);
    cloneRasterOptions(): RasterOptions;
    /**
     * Gets whether the graphic is dirty, this means there are changes that haven't been re-rasterized
     */
    get dirty(): boolean;
    /**
     * Flags the graphic as dirty, meaning it must be re-rasterized before draw.
     * This should be called any time the graphics state changes such that it affects the outputed drawing
     */
    flagDirty(): void;
    private _originalWidth;
    /**
     * Gets or sets the current width of the Raster graphic. Setting the width will cause the raster
     * to be flagged dirty causing a re-raster on the next draw.
     *
     * Any `padding`s set will be factored into the width
     */
    get width(): number;
    set width(value: number);
    private _originalHeight;
    /**
     * Gets or sets the current height of the Raster graphic. Setting the height will cause the raster
     * to be flagged dirty causing a re-raster on the next draw.
     *
     * Any `padding` set will be factored into the height
     */
    get height(): number;
    set height(value: number);
    private _getTotalWidth;
    private _getTotalHeight;
    /**
     * Returns the local bounds of the Raster including the padding
     */
    get localBounds(): BoundingBox;
    private _smoothing;
    /**
     * Gets or sets the smoothing (anti-aliasing of the graphic). Setting the height will cause the raster
     * to be flagged dirty causing a re-raster on the next draw.
     */
    get smoothing(): boolean;
    set smoothing(value: boolean);
    private _color;
    /**
     * Gets or sets the fillStyle of the Raster graphic. Setting the fillStyle will cause the raster to be
     * flagged dirty causing a re-raster on the next draw.
     */
    get color(): Color;
    set color(value: Color);
    private _strokeColor;
    /**
     * Gets or sets the strokeStyle of the Raster graphic. Setting the strokeStyle will cause the raster to be
     * flagged dirty causing a re-raster on the next draw.
     */
    get strokeColor(): Color;
    set strokeColor(value: Color);
    private _lineWidth;
    /**
     * Gets or sets the line width of the Raster graphic. Setting the lineWidth will cause the raster to be
     * flagged dirty causing a re-raster on the next draw.
     */
    get lineWidth(): number;
    set lineWidth(value: number);
    private _lineDash;
    get lineDash(): number[];
    set lineDash(value: number[]);
    private _padding;
    get padding(): number;
    set padding(value: number);
    /**
     * Rasterize the graphic to a bitmap making it usuable as in excalibur. Rasterize is called automatically if
     * the graphic is [[Raster.dirty]] on the next [[Graphic.draw]] call
     */
    rasterize(): void;
    protected _applyRasterProperites(ctx: CanvasRenderingContext2D): void;
    protected _drawImage(ex: ExcaliburGraphicsContext, x: number, y: number): void;
    /**
     * Executes drawing implemenation of the graphic, this is where the specific drawing code for the graphic
     * should be implemented. Once `rasterize()` the graphic can be drawn to the [[ExcaliburGraphicsContext]] via `draw(...)`
     * @param ctx Canvas to draw the graphic to
     */
    abstract execute(ctx: CanvasRenderingContext2D): void;
}
