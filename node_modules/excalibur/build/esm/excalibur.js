/*!
 * excalibur - 0.25.1 - 2021-11-5
 * https://github.com/excaliburjs/Excalibur
 * Copyright (c) 2021 Excalibur.js <https://github.com/excaliburjs/Excalibur/graphs/contributors>
 * Licensed BSD-2-Clause
 * @preserve
 */
/******/ var __webpack_modules__ = ({

/***/ 4662:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(3430);
var entryUnbind = __webpack_require__(8791);

module.exports = entryUnbind('Array', 'sort');


/***/ }),

/***/ 8343:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(4769);
var path = __webpack_require__(9276);

module.exports = path.Object.keys;


/***/ }),

/***/ 7111:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(6733);
var tryToString = __webpack_require__(9821);

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ 1176:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(5052);

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw TypeError(String(argument) + ' is not an object');
};


/***/ }),

/***/ 9540:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIndexedObject = __webpack_require__(905);
var toLength = __webpack_require__(4237);
var toAbsoluteIndex = __webpack_require__(3231);

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ 6038:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var fails = __webpack_require__(4229);

module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing
    method.call(null, argument || function () { throw 1; }, 1);
  });
};


/***/ }),

/***/ 3867:
/***/ ((module) => {

// TODO: use something more complex like timsort?
var floor = Math.floor;

var mergeSort = function (array, comparefn) {
  var length = array.length;
  var middle = floor(length / 2);
  return length < 8 ? insertionSort(array, comparefn) : merge(
    mergeSort(array.slice(0, middle), comparefn),
    mergeSort(array.slice(middle), comparefn),
    comparefn
  );
};

var insertionSort = function (array, comparefn) {
  var length = array.length;
  var i = 1;
  var element, j;

  while (i < length) {
    j = i;
    element = array[i];
    while (j && comparefn(array[j - 1], element) > 0) {
      array[j] = array[--j];
    }
    if (j !== i++) array[j] = element;
  } return array;
};

var merge = function (left, right, comparefn) {
  var llength = left.length;
  var rlength = right.length;
  var lindex = 0;
  var rindex = 0;
  var result = [];

  while (lindex < llength || rindex < rlength) {
    if (lindex < llength && rindex < rlength) {
      result.push(comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]);
    } else {
      result.push(lindex < llength ? left[lindex++] : right[rindex++]);
    }
  } return result;
};

module.exports = mergeSort;


/***/ }),

/***/ 7079:
/***/ ((module) => {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ 1589:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var TO_STRING_TAG_SUPPORT = __webpack_require__(1601);
var isCallable = __webpack_require__(6733);
var classofRaw = __webpack_require__(7079);
var wellKnownSymbol = __webpack_require__(95);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ 7081:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var has = __webpack_require__(816);
var ownKeys = __webpack_require__(4826);
var getOwnPropertyDescriptorModule = __webpack_require__(7933);
var definePropertyModule = __webpack_require__(1787);

module.exports = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};


/***/ }),

/***/ 5762:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(7400);
var definePropertyModule = __webpack_require__(1787);
var createPropertyDescriptor = __webpack_require__(5358);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ 5358:
/***/ ((module) => {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ 7400:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(4229);

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ 2635:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9859);
var isObject = __webpack_require__(5052);

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ 2671:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var userAgent = __webpack_require__(598);

var firefox = userAgent.match(/firefox\/(\d+)/i);

module.exports = !!firefox && +firefox[1];


/***/ }),

/***/ 8506:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var UA = __webpack_require__(598);

module.exports = /MSIE|Trident/.test(UA);


/***/ }),

/***/ 598:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(1333);

module.exports = getBuiltIn('navigator', 'userAgent') || '';


/***/ }),

/***/ 6358:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9859);
var userAgent = __webpack_require__(598);

var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  version = match[0] < 4 ? 1 : match[0] + match[1];
} else if (userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = match[1];
  }
}

module.exports = version && +version;


/***/ }),

/***/ 9811:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var userAgent = __webpack_require__(598);

var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);

module.exports = !!webkit && +webkit[1];


/***/ }),

/***/ 8791:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9859);
var bind = __webpack_require__(7636);

var call = Function.call;

module.exports = function (CONSTRUCTOR, METHOD, length) {
  return bind(call, global[CONSTRUCTOR].prototype[METHOD], length);
};


/***/ }),

/***/ 3837:
/***/ ((module) => {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ 3103:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9859);
var getOwnPropertyDescriptor = __webpack_require__(7933).f;
var createNonEnumerableProperty = __webpack_require__(5762);
var redefine = __webpack_require__(7487);
var setGlobal = __webpack_require__(2079);
var copyConstructorProperties = __webpack_require__(7081);
var isForced = __webpack_require__(6541);

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
  options.name        - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ 4229:
/***/ ((module) => {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ 7636:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var aCallable = __webpack_require__(7111);

// optional / simple context binding
module.exports = function (fn, that, length) {
  aCallable(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 0: return function () {
      return fn.call(that);
    };
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ 1805:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(7400);
var has = __webpack_require__(816);

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = has(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ 1333:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9859);
var isCallable = __webpack_require__(6733);

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
};


/***/ }),

/***/ 5300:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var aCallable = __webpack_require__(7111);

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return func == null ? undefined : aCallable(func);
};


/***/ }),

/***/ 9859:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ 816:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toObject = __webpack_require__(2991);

var hasOwnProperty = {}.hasOwnProperty;

module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty.call(toObject(it), key);
};


/***/ }),

/***/ 5977:
/***/ ((module) => {

module.exports = {};


/***/ }),

/***/ 4394:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(7400);
var fails = __webpack_require__(4229);
var createElement = __webpack_require__(2635);

// Thank's IE8 for his funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- requied for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ 9337:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(4229);
var classof = __webpack_require__(7079);

var split = ''.split;

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;


/***/ }),

/***/ 8511:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(6733);
var store = __webpack_require__(5353);

var functionToString = Function.toString;

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString.call(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ 6407:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_WEAK_MAP = __webpack_require__(8694);
var global = __webpack_require__(9859);
var isObject = __webpack_require__(5052);
var createNonEnumerableProperty = __webpack_require__(5762);
var objectHas = __webpack_require__(816);
var shared = __webpack_require__(5353);
var sharedKey = __webpack_require__(4399);
var hiddenKeys = __webpack_require__(5977);

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  var wmget = store.get;
  var wmhas = store.has;
  var wmset = store.set;
  set = function (it, metadata) {
    if (wmhas.call(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    wmset.call(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget.call(store, it) || {};
  };
  has = function (it) {
    return wmhas.call(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (objectHas(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return objectHas(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return objectHas(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ 6733:
/***/ ((module) => {

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
module.exports = function (argument) {
  return typeof argument === 'function';
};


/***/ }),

/***/ 6541:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(4229);
var isCallable = __webpack_require__(6733);

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ 5052:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(6733);

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ 4231:
/***/ ((module) => {

module.exports = false;


/***/ }),

/***/ 9395:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(6733);
var getBuiltIn = __webpack_require__(1333);
var USE_SYMBOL_AS_UID = __webpack_require__(6969);

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && Object(it) instanceof $Symbol;
};


/***/ }),

/***/ 3839:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(6358);
var fails = __webpack_require__(4229);

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol();
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ 8694:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9859);
var isCallable = __webpack_require__(6733);
var inspectSource = __webpack_require__(8511);

var WeakMap = global.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(inspectSource(WeakMap));


/***/ }),

/***/ 1787:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(7400);
var IE8_DOM_DEFINE = __webpack_require__(4394);
var anObject = __webpack_require__(1176);
var toPropertyKey = __webpack_require__(9310);

// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ 7933:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(7400);
var propertyIsEnumerableModule = __webpack_require__(9195);
var createPropertyDescriptor = __webpack_require__(5358);
var toIndexedObject = __webpack_require__(905);
var toPropertyKey = __webpack_require__(9310);
var has = __webpack_require__(816);
var IE8_DOM_DEFINE = __webpack_require__(4394);

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};


/***/ }),

/***/ 8151:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var internalObjectKeys = __webpack_require__(140);
var enumBugKeys = __webpack_require__(3837);

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ 894:
/***/ ((__unused_webpack_module, exports) => {

// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ 140:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var has = __webpack_require__(816);
var toIndexedObject = __webpack_require__(905);
var indexOf = __webpack_require__(9540).indexOf;
var hiddenKeys = __webpack_require__(5977);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~indexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ 5632:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var internalObjectKeys = __webpack_require__(140);
var enumBugKeys = __webpack_require__(3837);

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ 9195:
/***/ ((__unused_webpack_module, exports) => {


var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ 2914:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(6733);
var isObject = __webpack_require__(5052);

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = fn.call(input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = fn.call(input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ 4826:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(1333);
var getOwnPropertyNamesModule = __webpack_require__(8151);
var getOwnPropertySymbolsModule = __webpack_require__(894);
var anObject = __webpack_require__(1176);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ 9276:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9859);

module.exports = global;


/***/ }),

/***/ 7487:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9859);
var isCallable = __webpack_require__(6733);
var has = __webpack_require__(816);
var createNonEnumerableProperty = __webpack_require__(5762);
var setGlobal = __webpack_require__(2079);
var inspectSource = __webpack_require__(8511);
var InternalStateModule = __webpack_require__(6407);
var CONFIGURABLE_FUNCTION_NAME = __webpack_require__(1805).CONFIGURABLE;

var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(String).split('String');

(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  var name = options && options.name !== undefined ? options.name : key;
  var state;
  if (isCallable(value)) {
    if (String(name).slice(0, 7) === 'Symbol(') {
      name = '[' + String(name).replace(/^Symbol\(([^)]*)\)/, '$1') + ']';
    }
    if (!has(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
      createNonEnumerableProperty(value, 'name', name);
    }
    state = enforceInternalState(value);
    if (!state.source) {
      state.source = TEMPLATE.join(typeof name == 'string' ? name : '');
    }
  }
  if (O === global) {
    if (simple) O[key] = value;
    else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;
  else createNonEnumerableProperty(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
});


/***/ }),

/***/ 8885:
/***/ ((module) => {

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ 2079:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9859);

module.exports = function (key, value) {
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty(global, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ 4399:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var shared = __webpack_require__(3036);
var uid = __webpack_require__(1441);

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ 5353:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9859);
var setGlobal = __webpack_require__(2079);

var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});

module.exports = store;


/***/ }),

/***/ 3036:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var IS_PURE = __webpack_require__(4231);
var store = __webpack_require__(5353);

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.18.1',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: 'Â© 2021 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ 3231:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toInteger = __webpack_require__(6051);

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ 905:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(9337);
var requireObjectCoercible = __webpack_require__(8885);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ 6051:
/***/ ((module) => {

var ceil = Math.ceil;
var floor = Math.floor;

// `ToInteger` abstract operation
// https://tc39.es/ecma262/#sec-tointeger
module.exports = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};


/***/ }),

/***/ 4237:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toInteger = __webpack_require__(6051);

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ 2991:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var requireObjectCoercible = __webpack_require__(8885);

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ 2066:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(5052);
var isSymbol = __webpack_require__(9395);
var getMethod = __webpack_require__(5300);
var ordinaryToPrimitive = __webpack_require__(2914);
var wellKnownSymbol = __webpack_require__(95);

var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = exoticToPrim.call(input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ 9310:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toPrimitive = __webpack_require__(2066);
var isSymbol = __webpack_require__(9395);

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : String(key);
};


/***/ }),

/***/ 1601:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(95);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ 3326:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classof = __webpack_require__(1589);

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
  return String(argument);
};


/***/ }),

/***/ 9821:
/***/ ((module) => {

module.exports = function (argument) {
  try {
    return String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ 1441:
/***/ ((module) => {

var id = 0;
var postfix = Math.random();

module.exports = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};


/***/ }),

/***/ 6969:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(3839);

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ 95:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(9859);
var shared = __webpack_require__(3036);
var has = __webpack_require__(816);
var uid = __webpack_require__(1441);
var NATIVE_SYMBOL = __webpack_require__(3839);
var USE_SYMBOL_AS_UID = __webpack_require__(6969);

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!has(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
    if (NATIVE_SYMBOL && has(Symbol, name)) {
      WellKnownSymbolsStore[name] = Symbol[name];
    } else {
      WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
    }
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ 3430:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(3103);
var aCallable = __webpack_require__(7111);
var toObject = __webpack_require__(2991);
var toLength = __webpack_require__(4237);
var toString = __webpack_require__(3326);
var fails = __webpack_require__(4229);
var internalSort = __webpack_require__(3867);
var arrayMethodIsStrict = __webpack_require__(6038);
var FF = __webpack_require__(2671);
var IE_OR_EDGE = __webpack_require__(8506);
var V8 = __webpack_require__(6358);
var WEBKIT = __webpack_require__(9811);

var test = [];
var nativeSort = test.sort;

// IE8-
var FAILS_ON_UNDEFINED = fails(function () {
  test.sort(undefined);
});
// V8 bug
var FAILS_ON_NULL = fails(function () {
  test.sort(null);
});
// Old WebKit
var STRICT_METHOD = arrayMethodIsStrict('sort');

var STABLE_SORT = !fails(function () {
  // feature detection can be too slow, so check engines versions
  if (V8) return V8 < 70;
  if (FF && FF > 3) return;
  if (IE_OR_EDGE) return true;
  if (WEBKIT) return WEBKIT < 603;

  var result = '';
  var code, chr, value, index;

  // generate an array with more 512 elements (Chakra and old V8 fails only in this case)
  for (code = 65; code < 76; code++) {
    chr = String.fromCharCode(code);

    switch (code) {
      case 66: case 69: case 70: case 72: value = 3; break;
      case 68: case 71: value = 4; break;
      default: value = 2;
    }

    for (index = 0; index < 47; index++) {
      test.push({ k: chr + index, v: value });
    }
  }

  test.sort(function (a, b) { return b.v - a.v; });

  for (index = 0; index < test.length; index++) {
    chr = test[index].k.charAt(0);
    if (result.charAt(result.length - 1) !== chr) result += chr;
  }

  return result !== 'DGBEFHACIJK';
});

var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;

var getSortCompare = function (comparefn) {
  return function (x, y) {
    if (y === undefined) return -1;
    if (x === undefined) return 1;
    if (comparefn !== undefined) return +comparefn(x, y) || 0;
    return toString(x) > toString(y) ? 1 : -1;
  };
};

// `Array.prototype.sort` method
// https://tc39.es/ecma262/#sec-array.prototype.sort
$({ target: 'Array', proto: true, forced: FORCED }, {
  sort: function sort(comparefn) {
    if (comparefn !== undefined) aCallable(comparefn);

    var array = toObject(this);

    if (STABLE_SORT) return comparefn === undefined ? nativeSort.call(array) : nativeSort.call(array, comparefn);

    var items = [];
    var arrayLength = toLength(array.length);
    var itemsLength, index;

    for (index = 0; index < arrayLength; index++) {
      if (index in array) items.push(array[index]);
    }

    items = internalSort(items, getSortCompare(comparefn));
    itemsLength = items.length;
    index = 0;

    while (index < itemsLength) array[index] = items[index++];
    while (index < arrayLength) delete array[index++];

    return array;
  }
});


/***/ }),

/***/ 4769:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(3103);
var toObject = __webpack_require__(2991);
var nativeKeys = __webpack_require__(5632);
var fails = __webpack_require__(4229);

var FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  keys: function keys(it) {
    return nativeKeys(toObject(it));
  }
});


/***/ }),

/***/ 1388:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(272);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2609);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/* Buttons styles start */\r\n\r\nbutton#excalibur-play {\r\n  display: inline-block;\r\n  position: relative;\r\n  z-index: 999;\r\n  border-radius: 6px;\r\n  border: none;\r\n  /*border: 3px solid;\r\n    border-color: white;\r\n    box-shadow: 0 0 10px #ccc;*/\r\n  padding: 1rem 1.5rem 1rem 4rem;\r\n  margin: 0;\r\n  text-decoration: none;\r\n  background: #00b233;\r\n  color: #ffffff;\r\n  font-family: sans-serif;\r\n  font-size: 2rem;\r\n  white-space: nowrap;\r\n  line-height: 1;\r\n  cursor: pointer;\r\n  text-align: center;\r\n  transition: background 250ms ease-in-out, transform 150ms ease;\r\n  -webkit-appearance: none;\r\n  -moz-appearance: none;\r\n\r\n  -webkit-animation: excalibur-button-fadein 200ms; /* Safari, Chrome and Opera > 12.1 */\r\n  -moz-animation: excalibur-button-fadein 200ms; /* Firefox < 16 */\r\n  -ms-animation: excalibur-button-fadein 200ms; /* Internet Explorer */\r\n  -o-animation: excalibur-button-fadein 200ms; /* Opera < 12.1 */\r\n  animation: excalibur-button-fadein 200ms;\r\n}\r\n\r\n/*\r\nbutton#excalibur-play {\r\n  display: none;\r\n}*/\r\n\r\nbutton#excalibur-play:after {\r\n  position: absolute;\r\n  content: '';\r\n  border: 8px solid;\r\n  border-color: transparent transparent transparent white;\r\n  left: 35px;\r\n  top: 24px;\r\n  width: 0;\r\n  height: 0;\r\n}\r\n\r\nbutton#excalibur-play:before {\r\n  position: absolute;\r\n  content: '';\r\n  border: 3px solid;\r\n  left: 19px;\r\n  top: 14px;\r\n  border-radius: 20px;\r\n  width: 30px;\r\n  height: 30px;\r\n}\r\n\r\nbutton#excalibur-play:hover,\r\nbutton#excalibur-play:focus {\r\n  background: #00982c;\r\n}\r\n\r\nbutton#excalibur-play:focus {\r\n  outline: 1px solid #fff;\r\n  outline-offset: -4px;\r\n}\r\n\r\nbutton#excalibur-play:active {\r\n  transform: scale(0.99);\r\n}\r\n\r\n@keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Firefox < 16 */\r\n@-moz-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Safari, Chrome and Opera > 12.1 */\r\n@-webkit-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Internet Explorer */\r\n@-ms-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Opera < 12.1 */\r\n@-o-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n", "",{"version":3,"sources":["webpack://./Loader.css"],"names":[],"mappings":"AAAA,yBAAyB;;AAEzB;EACE,qBAAqB;EACrB,kBAAkB;EAClB,YAAY;EACZ,kBAAkB;EAClB,YAAY;EACZ;;+BAE6B;EAC7B,8BAA8B;EAC9B,SAAS;EACT,qBAAqB;EACrB,mBAAmB;EACnB,cAAc;EACd,uBAAuB;EACvB,eAAe;EACf,mBAAmB;EACnB,cAAc;EACd,eAAe;EACf,kBAAkB;EAClB,8DAA8D;EAC9D,wBAAwB;EACxB,qBAAqB;;EAErB,gDAAgD,EAAE,oCAAoC;EACtF,6CAA6C,EAAE,iBAAiB;EAChE,4CAA4C,EAAE,sBAAsB;EACpE,2CAA2C,EAAE,iBAAiB;EAC9D,wCAAwC;AAC1C;;AAEA;;;EAGE;;AAEF;EACE,kBAAkB;EAClB,WAAW;EACX,iBAAiB;EACjB,uDAAuD;EACvD,UAAU;EACV,SAAS;EACT,QAAQ;EACR,SAAS;AACX;;AAEA;EACE,kBAAkB;EAClB,WAAW;EACX,iBAAiB;EACjB,UAAU;EACV,SAAS;EACT,mBAAmB;EACnB,WAAW;EACX,YAAY;AACd;;AAEA;;EAEE,mBAAmB;AACrB;;AAEA;EACE,uBAAuB;EACvB,oBAAoB;AACtB;;AAEA;EACE,sBAAsB;AACxB;;AAEA;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,iBAAiB;AACjB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,oCAAoC;AACpC;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,sBAAsB;AACtB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,iBAAiB;AACjB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF","sourcesContent":["/* Buttons styles start */\r\n\r\nbutton#excalibur-play {\r\n  display: inline-block;\r\n  position: relative;\r\n  z-index: 999;\r\n  border-radius: 6px;\r\n  border: none;\r\n  /*border: 3px solid;\r\n    border-color: white;\r\n    box-shadow: 0 0 10px #ccc;*/\r\n  padding: 1rem 1.5rem 1rem 4rem;\r\n  margin: 0;\r\n  text-decoration: none;\r\n  background: #00b233;\r\n  color: #ffffff;\r\n  font-family: sans-serif;\r\n  font-size: 2rem;\r\n  white-space: nowrap;\r\n  line-height: 1;\r\n  cursor: pointer;\r\n  text-align: center;\r\n  transition: background 250ms ease-in-out, transform 150ms ease;\r\n  -webkit-appearance: none;\r\n  -moz-appearance: none;\r\n\r\n  -webkit-animation: excalibur-button-fadein 200ms; /* Safari, Chrome and Opera > 12.1 */\r\n  -moz-animation: excalibur-button-fadein 200ms; /* Firefox < 16 */\r\n  -ms-animation: excalibur-button-fadein 200ms; /* Internet Explorer */\r\n  -o-animation: excalibur-button-fadein 200ms; /* Opera < 12.1 */\r\n  animation: excalibur-button-fadein 200ms;\r\n}\r\n\r\n/*\r\nbutton#excalibur-play {\r\n  display: none;\r\n}*/\r\n\r\nbutton#excalibur-play:after {\r\n  position: absolute;\r\n  content: '';\r\n  border: 8px solid;\r\n  border-color: transparent transparent transparent white;\r\n  left: 35px;\r\n  top: 24px;\r\n  width: 0;\r\n  height: 0;\r\n}\r\n\r\nbutton#excalibur-play:before {\r\n  position: absolute;\r\n  content: '';\r\n  border: 3px solid;\r\n  left: 19px;\r\n  top: 14px;\r\n  border-radius: 20px;\r\n  width: 30px;\r\n  height: 30px;\r\n}\r\n\r\nbutton#excalibur-play:hover,\r\nbutton#excalibur-play:focus {\r\n  background: #00982c;\r\n}\r\n\r\nbutton#excalibur-play:focus {\r\n  outline: 1px solid #fff;\r\n  outline-offset: -4px;\r\n}\r\n\r\nbutton#excalibur-play:active {\r\n  transform: scale(0.99);\r\n}\r\n\r\n@keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Firefox < 16 */\r\n@-moz-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Safari, Chrome and Opera > 12.1 */\r\n@-webkit-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Internet Explorer */\r\n@-ms-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Opera < 12.1 */\r\n@-o-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 2609:
/***/ ((module) => {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";

      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }

      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }

      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }

      content += cssWithMappingToString(item);

      if (needLayer) {
        content += "}";
      }

      if (item[2]) {
        content += "}";
      }

      if (item[4]) {
        content += "}";
      }

      return content;
    }).join("");
  }; // import a list of modules into the list


  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var _i = 0; _i < this.length; _i++) {
        var id = this[_i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i2 = 0; _i2 < modules.length; _i2++) {
      var item = [].concat(modules[_i2]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }

      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }

      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }

      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ 272:
/***/ ((module) => {



module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		id: moduleId,
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/compat get default export */
/******/ (() => {
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = (module) => {
/******/ 		var getter = module && module.__esModule ?
/******/ 			() => (module['default']) :
/******/ 			() => (module);
/******/ 		__webpack_require__.d(getter, { a: getter });
/******/ 		return getter;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/global */
/******/ (() => {
/******/ 	__webpack_require__.g = (function() {
/******/ 		if (typeof globalThis === 'object') return globalThis;
/******/ 		try {
/******/ 			return this || new Function('return this')();
/******/ 		} catch (e) {
/******/ 			if (typeof window === 'object') return window;
/******/ 		}
/******/ 	})();
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "fWn": () => (/* reexport */ ActionContext),
  "Ia8": () => (/* reexport */ ActionQueue),
  "hLI": () => (/* reexport */ ActionsComponent),
  "yyv": () => (/* reexport */ ActionsSystem),
  "tX5": () => (/* reexport */ ActivateEvent),
  "vtX": () => (/* reexport */ Actor),
  "r7K": () => (/* reexport */ AddedComponent),
  "lCh": () => (/* reexport */ AddedEntity),
  "fwF": () => (/* reexport */ Animation),
  "sce": () => (/* reexport */ AnimationDirection),
  "_c7": () => (/* reexport */ AnimationStrategy),
  "KUs": () => (/* reexport */ ArcadeSolver),
  "Ajp": () => (/* reexport */ AudioContextFactory),
  "RDh": () => (/* reexport */ Axis),
  "_H9": () => (/* reexport */ BaseAlign),
  "Ulf": () => (/* reexport */ BinaryTreeNode),
  "mxs": () => (/* reexport */ Blink),
  "OmD": () => (/* reexport */ BodyComponent),
  "kBf": () => (/* reexport */ BoundingBox),
  "C4F": () => (/* reexport */ BroadphaseStrategy),
  "NQt": () => (/* reexport */ BrowserComponent),
  "JjN": () => (/* reexport */ BrowserEvents),
  "V1s": () => (/* reexport */ Camera),
  "Xz7": () => (/* reexport */ Canvas),
  "bLd": () => (/* reexport */ Cell),
  "Cdc": () => (/* reexport */ Circle),
  "FKn": () => (/* reexport */ CircleCollider),
  "wTW": () => (/* reexport */ Class),
  "ab2": () => (/* reexport */ ClosestLine),
  "GfZ": () => (/* reexport */ ClosestLineJumpTable),
  "YMS": () => (/* reexport */ Collider),
  "oyv": () => (/* reexport */ ColliderComponent),
  "aUb": () => (/* reexport */ CollisionContact),
  "SdD": () => (/* reexport */ CollisionEndEvent),
  "JUv": () => (/* reexport */ CollisionGroup),
  "jEj": () => (/* reexport */ CollisionGroupManager),
  "TFq": () => (/* reexport */ CollisionJumpTable),
  "HDU": () => (/* reexport */ CollisionPostSolveEvent),
  "R_y": () => (/* reexport */ CollisionPreSolveEvent),
  "ydN": () => (/* reexport */ CollisionResolutionStrategy),
  "_N2": () => (/* reexport */ CollisionSolver),
  "t50": () => (/* reexport */ CollisionStartEvent),
  "s$$": () => (/* reexport */ CollisionSystem),
  "v2G": () => (/* reexport */ CollisionType),
  "Ilk": () => (/* reexport */ Color),
  "H_9": () => (/* reexport */ ColorBlindCorrector),
  "s9i": () => (/* reexport */ ColorBlindFlags),
  "ksl": () => (/* reexport */ ColorBlindness),
  "wA2": () => (/* reexport */ Component),
  "R_p": () => (/* reexport */ CompositeCollider),
  "IQ$": () => (/* reexport */ Configurable),
  "I5F": () => (/* reexport */ ConsoleAppender),
  "X8$": () => (/* reexport */ ContactConstraintPoint),
  "FR6": () => (/* reexport */ ContactEndEvent),
  "U8o": () => (/* reexport */ ContactStartEvent),
  "kbG": () => (/* reexport */ CoordPlane),
  "oeJ": () => (/* reexport */ CullingBox),
  "iS_": () => (/* reexport */ DeactivateEvent),
  "cGG": () => (/* reexport */ Debug),
  "skb": () => (/* reexport */ DebugSystem),
  "SLU": () => (/* reexport */ DebugText),
  "RdJ": () => (/* reexport */ DegreeOfFreedom),
  "gU7": () => (/* reexport */ Detector),
  "LSk": () => (/* reexport */ Die),
  "Nmp": () => (/* reexport */ Direction),
  "d1Y": () => (/* reexport */ DisplayMode),
  "xrL": () => (/* reexport */ DynamicTree),
  "sRW": () => (/* reexport */ DynamicTreeCollisionProcessor),
  "cmV": () => (/* binding */ EX_VERSION),
  "N0Q": () => (/* reexport */ EaseTo),
  "q8b": () => (/* reexport */ EasingFunctions),
  "ynB": () => (/* reexport */ EdgeCollider),
  "jT9": () => (/* reexport */ ElasticToActorStrategy),
  "wAz": () => (/* reexport */ EmitterType),
  "D4V": () => (/* reexport */ Engine),
  "N6H": () => (/* reexport */ EnterTriggerEvent),
  "W1A": () => (/* reexport */ EnterViewPortEvent),
  "JHW": () => (/* reexport */ Entity),
  "v2K": () => (/* reexport */ EntityManager),
  "pBf": () => (/* reexport */ EventDispatcher),
  "GMl": () => (/* reexport */ EventTypes),
  "zW2": () => (/* reexport */ Events_namespaceObject),
  "B0K": () => (/* reexport */ ExResponse),
  "Nv7": () => (/* reexport */ ExcaliburGraphicsContext2DCanvas),
  "C_p": () => (/* reexport */ ExcaliburGraphicsContextWebGL),
  "MUA": () => (/* reexport */ ExitTriggerEvent),
  "xqU": () => (/* reexport */ ExitViewPortEvent),
  "peG": () => (/* reexport */ Experiments),
  "pTp": () => (/* reexport */ Fade),
  "vUK": () => (/* reexport */ Flags),
  "j9l": () => (/* reexport */ Follow),
  "Zxw": () => (/* reexport */ Font),
  "Hdx": () => (/* reexport */ FontStyle),
  "Z$d": () => (/* reexport */ FontUnit),
  "o$7": () => (/* reexport */ FrameStats),
  "Zm$": () => (/* reexport */ GameEvent),
  "$QH": () => (/* reexport */ GameStartEvent),
  "i78": () => (/* reexport */ GameStopEvent),
  "h6u": () => (/* reexport */ GamepadAxisEvent),
  "hts": () => (/* reexport */ GamepadButtonEvent),
  "j88": () => (/* reexport */ GamepadConnectEvent),
  "VME": () => (/* reexport */ GamepadDisconnectEvent),
  "nt": () => (/* reexport */ Gif),
  "Ukr": () => (/* reexport */ GlobalCoordinates),
  "zsu": () => (/* reexport */ Graphic),
  "oA6": () => (/* reexport */ GraphicsComponent),
  "TVh": () => (/* reexport */ GraphicsGroup),
  "TwZ": () => (/* reexport */ GraphicsLayer),
  "GTT": () => (/* reexport */ GraphicsLayers),
  "xxj": () => (/* reexport */ GraphicsSystem),
  "XdK": () => (/* reexport */ HiddenEvent),
  "cXo": () => (/* reexport */ ImageSource),
  "Dm5": () => (/* reexport */ InitializeEvent),
  "IIB": () => (/* reexport */ Input_Index_namespaceObject),
  "zI0": () => (/* reexport */ Integrator),
  "SKZ": () => (/* reexport */ KillEvent),
  "__J": () => (/* reexport */ Label_Label),
  "Dvr": () => (/* reexport */ Legacy),
  "Tf9": () => (/* reexport */ Drawing_Index_namespaceObject),
  "RI$": () => (/* reexport */ LimitCameraBoundsStrategy),
  "x12": () => (/* reexport */ Line),
  "aNw": () => (/* reexport */ Loader),
  "xwn": () => (/* reexport */ LockCameraToActorAxisStrategy),
  "dNK": () => (/* reexport */ LockCameraToActorStrategy),
  "ini": () => (/* reexport */ LogLevel),
  "YdH": () => (/* reexport */ Logger),
  "y3G": () => (/* reexport */ Matrix),
  "l57": () => (/* reexport */ MatrixLocations),
  "xn0": () => (/* reexport */ MediaEvent),
  "t2V": () => (/* reexport */ Meet),
  "ZyS": () => (/* reexport */ MockedElement),
  "uxB": () => (/* reexport */ MotionComponent),
  "cpd": () => (/* reexport */ MotionSystem),
  "fiy": () => (/* reexport */ MoveBy),
  "$XZ": () => (/* reexport */ MoveTo),
  "uqK": () => (/* reexport */ NativeSoundEvent),
  "STE": () => (/* reexport */ NativeSoundProcessedEvent),
  "y$z": () => (/* reexport */ Observable),
  "sOq": () => (/* reexport */ Pair),
  "Sqs": () => (/* reexport */ ParseGif),
  "hpZ": () => (/* reexport */ Particle),
  "Vol": () => (/* reexport */ ParticleEmitter),
  "wIZ": () => (/* reexport */ Physics),
  "cBi": () => (/* reexport */ PhysicsStats),
  "mgq": () => (/* reexport */ Polygon_Polygon),
  "YVA": () => (/* reexport */ PolygonCollider),
  "Kgp": () => (/* reexport */ Pool),
  "HH$": () => (/* reexport */ PostCollisionEvent),
  "M_d": () => (/* reexport */ PostDebugDrawEvent),
  "rgh": () => (/* reexport */ PostDrawEvent),
  "Ra6": () => (/* reexport */ PostFrameEvent),
  "KhR": () => (/* reexport */ PostKillEvent),
  "BS5": () => (/* reexport */ PostUpdateEvent),
  "xhz": () => (/* reexport */ PreCollisionEvent),
  "xOq": () => (/* reexport */ PreDebugDrawEvent),
  "a9j": () => (/* reexport */ PreDrawEvent),
  "bHk": () => (/* reexport */ PreFrameEvent),
  "CgK": () => (/* reexport */ PreKillEvent),
  "cuY": () => (/* reexport */ PreUpdateEvent),
  "kvE": () => (/* reexport */ Projection),
  "JDb": () => (/* reexport */ Promises_Promise),
  "Cbi": () => (/* reexport */ PromiseState),
  "AE_": () => (/* reexport */ Query),
  "ctO": () => (/* reexport */ QueryManager),
  "OLH": () => (/* reexport */ RadiusAroundActorStrategy),
  "kky": () => (/* reexport */ Random),
  "nSF": () => (/* reexport */ Raster),
  "zHn": () => (/* reexport */ Ray),
  "zwx": () => (/* reexport */ RealisticSolver),
  "AeJ": () => (/* reexport */ Rectangle),
  "hLz": () => (/* reexport */ RemovedComponent),
  "D9g": () => (/* reexport */ RemovedEntity),
  "wA": () => (/* reexport */ Repeat),
  "jhr": () => (/* reexport */ RepeatForever),
  "GVs": () => (/* reexport */ Resolution),
  "_zO": () => (/* reexport */ Resource),
  "w6$": () => (/* reexport */ RotateBy),
  "mhV": () => (/* reexport */ RotateTo),
  "MOD": () => (/* reexport */ RotationType),
  "kwd": () => (/* reexport */ ScaleBy),
  "Lmr": () => (/* reexport */ ScaleTo),
  "xsS": () => (/* reexport */ Scene),
  "lLr": () => (/* reexport */ Screen),
  "Z$r": () => (/* reexport */ ScreenAppender),
  "IXb": () => (/* reexport */ ScreenElement_ScreenElement),
  "SMj": () => (/* reexport */ ScrollPreventionMode),
  "bnF": () => (/* reexport */ Shape),
  "MFA": () => (/* reexport */ Side),
  "$XC": () => (/* reexport */ SortedList),
  "$uU": () => (/* reexport */ Sound),
  "jyi": () => (/* reexport */ Sprite),
  "E03": () => (/* reexport */ SpriteFont_SpriteFont),
  "V6q": () => (/* reexport */ SpriteSheet),
  "nVo": () => (/* reexport */ StrategyContainer),
  "F6N": () => (/* reexport */ Stream),
  "ad3": () => (/* reexport */ SubscribeEvent),
  "xP7": () => (/* reexport */ System),
  "Odq": () => (/* reexport */ SystemManager),
  "Zif": () => (/* reexport */ SystemType),
  "ZGJ": () => (/* reexport */ TagComponent),
  "xvT": () => (/* reexport */ Text),
  "PHM": () => (/* reexport */ TextAlign),
  "KwO": () => (/* reexport */ TileMap),
  "B7y": () => (/* reexport */ Timer),
  "SFp": () => (/* reexport */ Traits_Index_namespaceObject),
  "Uvn": () => (/* reexport */ TransformComponent),
  "OFT": () => (/* reexport */ TreeNode),
  "xzN": () => (/* reexport */ Trigger_Trigger),
  "H6j": () => (/* reexport */ UnsubscribeEvent),
  "ZrN": () => (/* reexport */ Util_Index_namespaceObject),
  "OWs": () => (/* reexport */ Vector),
  "dF9": () => (/* reexport */ VectorView),
  "VHo": () => (/* reexport */ VisibleEvent),
  "R$E": () => (/* reexport */ WebAudioInstance),
  "q3I": () => (/* reexport */ World),
  "Pab": () => (/* reexport */ canonicalizeAngle),
  "uZ5": () => (/* reexport */ clamp),
  "McK": () => (/* reexport */ createId),
  "k0b": () => (/* reexport */ hasGraphicsTick),
  "hnT": () => (/* reexport */ hasOnInitialize),
  "RSJ": () => (/* reexport */ hasOnPostUpdate),
  "Mku": () => (/* reexport */ hasOnPreUpdate),
  "h90": () => (/* reexport */ hasPostDraw),
  "rms": () => (/* reexport */ hasPreDraw),
  "ErP": () => (/* reexport */ has_initialize),
  "aVg": () => (/* reexport */ has_postupdate),
  "lPc": () => (/* reexport */ has_preupdate),
  "Z8E": () => (/* reexport */ isAddedComponent),
  "NNA": () => (/* reexport */ isAddedSystemEntity),
  "yFn": () => (/* reexport */ isRemoveSystemEntity),
  "lNv": () => (/* reexport */ isRemovedComponent),
  "MZQ": () => (/* reexport */ maxMessages),
  "FUM": () => (/* reexport */ obsolete),
  "vdf": () => (/* reexport */ randomInRange),
  "iaL": () => (/* reexport */ randomIntInRange),
  "w6H": () => (/* reexport */ range),
  "Q4c": () => (/* reexport */ resetObsoleteCounter),
  "Uxb": () => (/* reexport */ toDegrees),
  "Yr5": () => (/* reexport */ toRadians),
  "Bhw": () => (/* reexport */ vec)
});

// NAMESPACE OBJECT: ./Events.ts
var Events_namespaceObject = {};
__webpack_require__.r(Events_namespaceObject);
__webpack_require__.d(Events_namespaceObject, {
  "ActivateEvent": () => (ActivateEvent),
  "CollisionEndEvent": () => (CollisionEndEvent),
  "CollisionPostSolveEvent": () => (CollisionPostSolveEvent),
  "CollisionPreSolveEvent": () => (CollisionPreSolveEvent),
  "CollisionStartEvent": () => (CollisionStartEvent),
  "ContactEndEvent": () => (ContactEndEvent),
  "ContactStartEvent": () => (ContactStartEvent),
  "DeactivateEvent": () => (DeactivateEvent),
  "EnterTriggerEvent": () => (EnterTriggerEvent),
  "EnterViewPortEvent": () => (EnterViewPortEvent),
  "EventTypes": () => (EventTypes),
  "ExitTriggerEvent": () => (ExitTriggerEvent),
  "ExitViewPortEvent": () => (ExitViewPortEvent),
  "GameEvent": () => (GameEvent),
  "GameStartEvent": () => (GameStartEvent),
  "GameStopEvent": () => (GameStopEvent),
  "GamepadAxisEvent": () => (GamepadAxisEvent),
  "GamepadButtonEvent": () => (GamepadButtonEvent),
  "GamepadConnectEvent": () => (GamepadConnectEvent),
  "GamepadDisconnectEvent": () => (GamepadDisconnectEvent),
  "HiddenEvent": () => (HiddenEvent),
  "InitializeEvent": () => (InitializeEvent),
  "KillEvent": () => (KillEvent),
  "PostCollisionEvent": () => (PostCollisionEvent),
  "PostDebugDrawEvent": () => (PostDebugDrawEvent),
  "PostDrawEvent": () => (PostDrawEvent),
  "PostFrameEvent": () => (PostFrameEvent),
  "PostKillEvent": () => (PostKillEvent),
  "PostUpdateEvent": () => (PostUpdateEvent),
  "PreCollisionEvent": () => (PreCollisionEvent),
  "PreDebugDrawEvent": () => (PreDebugDrawEvent),
  "PreDrawEvent": () => (PreDrawEvent),
  "PreFrameEvent": () => (PreFrameEvent),
  "PreKillEvent": () => (PreKillEvent),
  "PreUpdateEvent": () => (PreUpdateEvent),
  "SubscribeEvent": () => (SubscribeEvent),
  "UnsubscribeEvent": () => (UnsubscribeEvent),
  "VisibleEvent": () => (VisibleEvent)
});

// NAMESPACE OBJECT: ./Drawing/SpriteEffects.ts
var SpriteEffects_namespaceObject = {};
__webpack_require__.r(SpriteEffects_namespaceObject);
__webpack_require__.d(SpriteEffects_namespaceObject, {
  "Colorize": () => (Colorize),
  "Darken": () => (Darken),
  "Desaturate": () => (Desaturate),
  "Fill": () => (Fill),
  "Grayscale": () => (Grayscale),
  "Invert": () => (Invert),
  "Lighten": () => (Lighten),
  "Opacity": () => (Opacity),
  "Saturate": () => (Saturate)
});

// NAMESPACE OBJECT: ./Util/DrawUtil.ts
var DrawUtil_namespaceObject = {};
__webpack_require__.r(DrawUtil_namespaceObject);
__webpack_require__.d(DrawUtil_namespaceObject, {
  "circle": () => (circle),
  "line": () => (line),
  "point": () => (point),
  "roundRect": () => (roundRect),
  "vector": () => (vector)
});

// NAMESPACE OBJECT: ./Drawing/Index.ts
var Drawing_Index_namespaceObject = {};
__webpack_require__.r(Drawing_Index_namespaceObject);
__webpack_require__.d(Drawing_Index_namespaceObject, {
  "Animation": () => (Animation_Animation),
  "CanvasDrawComponent": () => (CanvasDrawComponent),
  "CanvasDrawingSystem": () => (CanvasDrawingSystem),
  "Effects": () => (SpriteEffects_namespaceObject),
  "Polygon": () => (Polygon),
  "Sprite": () => (Sprite_Sprite),
  "SpriteFont": () => (SpriteFont),
  "SpriteSheet": () => (SpriteSheet_SpriteSheet),
  "Texture": () => (Texture)
});

// NAMESPACE OBJECT: ./Input/Index.ts
var Input_Index_namespaceObject = {};
__webpack_require__.r(Input_Index_namespaceObject);
__webpack_require__.d(Input_Index_namespaceObject, {
  "Axes": () => (Axes),
  "Buttons": () => (Buttons),
  "Gamepad": () => (Gamepad),
  "Gamepads": () => (Gamepads),
  "KeyEvent": () => (KeyEvent),
  "Keyboard": () => (Keyboard),
  "Keys": () => (Keys),
  "NativePointerButton": () => (NativePointerButton),
  "Pointer": () => (Pointer),
  "PointerButton": () => (PointerButton),
  "PointerCancelEvent": () => (PointerCancelEvent),
  "PointerDownEvent": () => (PointerDownEvent),
  "PointerDragEvent": () => (PointerDragEvent),
  "PointerEnterEvent": () => (PointerEnterEvent),
  "PointerEvent": () => (PointerEvent),
  "PointerEventFactory": () => (PointerEventFactory),
  "PointerLeaveEvent": () => (PointerLeaveEvent),
  "PointerMoveEvent": () => (PointerMoveEvent),
  "PointerScope": () => (PointerScope),
  "PointerType": () => (PointerType),
  "PointerUpEvent": () => (PointerUpEvent),
  "Pointers": () => (Pointers),
  "WheelDeltaMode": () => (WheelDeltaMode),
  "WheelEvent": () => (WheelEvent),
  "createPointerEventByName": () => (createPointerEventByName)
});

// NAMESPACE OBJECT: ./Traits/Index.ts
var Traits_Index_namespaceObject = {};
__webpack_require__.r(Traits_Index_namespaceObject);
__webpack_require__.d(Traits_Index_namespaceObject, {
  "CapturePointer": () => (CapturePointer),
  "OffscreenCulling": () => (OffscreenCulling)
});

// NAMESPACE OBJECT: ./Util/Index.ts
var Util_Index_namespaceObject = {};
__webpack_require__.r(Util_Index_namespaceObject);
__webpack_require__.d(Util_Index_namespaceObject, {
  "Collection": () => (Collection),
  "ConsoleAppender": () => (ConsoleAppender),
  "DrawUtil": () => (DrawUtil_namespaceObject),
  "EasingFunctions": () => (EasingFunctions),
  "LogLevel": () => (LogLevel),
  "Logger": () => (Logger),
  "Observable": () => (Observable),
  "ScreenAppender": () => (ScreenAppender),
  "TwoPI": () => (TwoPI),
  "addItemToArray": () => (addItemToArray),
  "base64Encode": () => (base64Encode),
  "canonicalizeAngle": () => (canonicalizeAngle),
  "clamp": () => (clamp),
  "contains": () => (contains),
  "delay": () => (delay),
  "extend": () => (extend),
  "fail": () => (fail),
  "getOppositeSide": () => (getOppositeSide),
  "getPosition": () => (getPosition),
  "getSideFromDirection": () => (getSideFromDirection),
  "nullish": () => (nullish),
  "randomInRange": () => (randomInRange),
  "randomIntInRange": () => (randomIntInRange),
  "range": () => (range),
  "removeItemFromArray": () => (removeItemFromArray),
  "toDegrees": () => (toDegrees),
  "toRadians": () => (toRadians)
});

// EXTERNAL MODULE: ../../node_modules/core-js/es/array/sort.js
var sort = __webpack_require__(4662);
// EXTERNAL MODULE: ../../node_modules/core-js/es/object/keys.js
var keys = __webpack_require__(8343);
;// CONCATENATED MODULE: ./Polyfill.ts


/**
 * Polyfill adding function
 */
function polyfill() {
    /* istanbul ignore next */
    if (typeof window === 'undefined') {
        window = {
            audioContext: function () {
                return;
            }
        };
    }
    /* istanbul ignore next */
    if (typeof window !== 'undefined' && !window.requestAnimationFrame) {
        window.requestAnimationFrame =
            window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                function (callback) {
                    window.setInterval(callback, 1000 / 60);
                };
    }
    /* istanbul ignore next */
    if (typeof window !== 'undefined' && !window.cancelAnimationFrame) {
        window.cancelAnimationFrame =
            window.webkitCancelAnimationFrame ||
                window.mozCancelAnimationFrame ||
                function () {
                    return;
                };
    }
    /* istanbul ignore next */
    if (typeof window !== 'undefined' && !window.AudioContext) {
        if (window.webkitAudioContext) {
            const ctx = window.webkitAudioContext;
            const replaceMe = ctx.prototype.decodeAudioData;
            window.webkitAudioContext.prototype.decodeAudioData = function (arrayBuffer) {
                return new Promise((resolve, reject) => {
                    replaceMe.call(this, arrayBuffer, resolve, reject);
                });
            };
        }
        window.AudioContext =
            window.AudioContext ||
                window.webkitAudioContext ||
                window.mozAudioContext ||
                window.msAudioContext ||
                window.oAudioContext;
    }
    /* istanbul ignore next */
    if (typeof window !== 'undefined' && !window.devicePixelRatio) {
        window.devicePixelRatio = window.devicePixelRatio || 1;
    }
}

;// CONCATENATED MODULE: ./Flags.ts
/**
 * Features in preview
 */
var Experiments;
(function (Experiments) {
    Experiments["WebGL"] = "use-webgl";
})(Experiments || (Experiments = {}));
/**
 * Legacy features that will go away
 */
var Legacy;
(function (Legacy) {
    Legacy["Canvas"] = "use-canvas-context";
    Legacy["LegacyDrawing"] = "use-legacy-drawing";
})(Legacy || (Legacy = {}));
/**
 * Flags is a feature flag implementation for Excalibur. They can only be operated **before [[Engine]] construction**
 * after which they are frozen and are read-only.
 *
 * Flags are used to enable experimental or preview features in Excalibur.
 */
class Flags {
    /**
     * Freeze all flag modifications making them readonly
     */
    static freeze() {
        Flags._FROZEN = true;
    }
    /**
     * Resets internal flag state, not meant to be called by users. Only used for testing.
     *
     * Calling this in your game is UNSUPPORTED
     * @internal
     */
    static _reset() {
        Flags._FROZEN = false;
        Flags._FLAGS = {};
    }
    /**
     * Turn on webgl support
     */
    static useWebGL() {
        Flags.enable(Experiments.WebGL);
    }
    static useCanvasGraphicsContext() {
        Flags.enable(Legacy.Canvas);
    }
    /**
     * @deprecated Recommended not to use legacy drawing, going away in v0.26.0
     */
    static useLegacyDrawing() {
        Flags.enable(Legacy.LegacyDrawing);
    }
    /**
     * Enable a specific feature flag by name. **Note: can only be set before [[Engine]] constructor time**
     * @param flagName
     */
    static enable(flagName) {
        if (this._FROZEN) {
            throw Error('Feature flags can only be enabled before Engine constructor time');
        }
        Flags._FLAGS[flagName] = true;
    }
    /**
     * Disable a specific feature flag by name. **Note: can only be set before [[Engine]] constructor time**
     * @param flagName
     */
    static disable(flagName) {
        if (this._FROZEN) {
            throw Error('Feature flags can only be disabled before Engine constructor time');
        }
        Flags._FLAGS[flagName] = false;
    }
    /**
     * Check if a flag is enabled. If the flag is disabled or does not exist `false` is returned
     * @param flagName
     */
    static isEnabled(flagName) {
        return !!Flags._FLAGS[flagName];
    }
    /**
     * Show a list of currently known flags
     */
    static show() {
        return Object.keys(Flags._FLAGS);
    }
}
Flags._FROZEN = false;
Flags._FLAGS = {};

;// CONCATENATED MODULE: ./Id.ts
/**
 *
 */
function createId(type, value) {
    return { type, value };
}
;

;// CONCATENATED MODULE: ./Util/Log.ts
/* eslint-disable no-console */
/**
 * Logging level that Excalibur will tag
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Debug"] = 0] = "Debug";
    LogLevel[LogLevel["Info"] = 1] = "Info";
    LogLevel[LogLevel["Warn"] = 2] = "Warn";
    LogLevel[LogLevel["Error"] = 3] = "Error";
    LogLevel[LogLevel["Fatal"] = 4] = "Fatal";
})(LogLevel || (LogLevel = {}));
/**
 * Static singleton that represents the logging facility for Excalibur.
 * Excalibur comes built-in with a [[ConsoleAppender]] and [[ScreenAppender]].
 * Derive from [[Appender]] to create your own logging appenders.
 */
class Logger {
    constructor() {
        this._appenders = [];
        /**
         * Gets or sets the default logging level. Excalibur will only log
         * messages if equal to or above this level. Default: [[LogLevel.Info]]
         */
        this.defaultLevel = LogLevel.Info;
        if (Logger._INSTANCE) {
            throw new Error('Logger is a singleton');
        }
        Logger._INSTANCE = this;
        // Default console appender
        Logger._INSTANCE.addAppender(new ConsoleAppender());
        return Logger._INSTANCE;
    }
    /**
     * Gets the current static instance of Logger
     */
    static getInstance() {
        if (Logger._INSTANCE == null) {
            Logger._INSTANCE = new Logger();
        }
        return Logger._INSTANCE;
    }
    /**
     * Adds a new [[Appender]] to the list of appenders to write to
     */
    addAppender(appender) {
        this._appenders.push(appender);
    }
    /**
     * Clears all appenders from the logger
     */
    clearAppenders() {
        this._appenders.length = 0;
    }
    /**
     * Logs a message at a given LogLevel
     * @param level  The LogLevel`to log the message at
     * @param args   An array of arguments to write to an appender
     */
    _log(level, args) {
        if (level == null) {
            level = this.defaultLevel;
        }
        const len = this._appenders.length;
        for (let i = 0; i < len; i++) {
            if (level >= this.defaultLevel) {
                this._appenders[i].log(level, args);
            }
        }
    }
    /**
     * Writes a log message at the [[LogLevel.Debug]] level
     * @param args  Accepts any number of arguments
     */
    debug(...args) {
        this._log(LogLevel.Debug, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Info]] level
     * @param args  Accepts any number of arguments
     */
    info(...args) {
        this._log(LogLevel.Info, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Warn]] level
     * @param args  Accepts any number of arguments
     */
    warn(...args) {
        this._log(LogLevel.Warn, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Error]] level
     * @param args  Accepts any number of arguments
     */
    error(...args) {
        this._log(LogLevel.Error, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Fatal]] level
     * @param args  Accepts any number of arguments
     */
    fatal(...args) {
        this._log(LogLevel.Fatal, args);
    }
}
Logger._INSTANCE = null;
/**
 * Console appender for browsers (i.e. `console.log`)
 */
class ConsoleAppender {
    /**
     * Logs a message at the given [[LogLevel]]
     * @param level  Level to log at
     * @param args   Arguments to log
     */
    log(level, args) {
        // Check for console support
        if (!console && !console.log && console.warn && console.error) {
            // todo maybe do something better than nothing
            return;
        }
        // Create a new console args array
        const consoleArgs = [];
        consoleArgs.unshift.apply(consoleArgs, args);
        consoleArgs.unshift('[' + LogLevel[level] + '] : ');
        if (level < LogLevel.Warn) {
            // Call .log for Debug/Info
            if (console.log.apply) {
                // this is required on some older browsers that don't support apply on console.log :(
                console.log.apply(console, consoleArgs);
            }
            else {
                console.log(consoleArgs.join(' '));
            }
        }
        else if (level < LogLevel.Error) {
            // Call .warn for Warn
            if (console.warn.apply) {
                console.warn.apply(console, consoleArgs);
            }
            else {
                console.warn(consoleArgs.join(' '));
            }
        }
        else {
            // Call .error for Error/Fatal
            if (console.error.apply) {
                console.error.apply(console, consoleArgs);
            }
            else {
                console.error(consoleArgs.join(' '));
            }
        }
    }
}
/**
 * On-screen (canvas) appender
 */
class ScreenAppender {
    /**
     * @param width   Width of the screen appender in pixels
     * @param height  Height of the screen appender in pixels
     */
    constructor(width, height) {
        // @todo Clean this up
        this._messages = [];
        this._canvas = document.createElement('canvas');
        this._canvas.width = width || window.innerWidth;
        this._canvas.height = height || window.innerHeight;
        this._canvas.style.position = 'absolute';
        // eslint-disable-next-line
        this._ctx = this._canvas.getContext('2d'); // eslint-disable-line
        document.body.appendChild(this._canvas);
    }
    /**
     * Logs a message at the given [[LogLevel]]
     * @param level  Level to log at
     * @param args   Arguments to log
     */
    log(level, args) {
        const message = args.join(',');
        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
        this._messages.unshift('[' + LogLevel[level] + '] : ' + message);
        let pos = 10;
        let opacity = 1.0;
        for (let i = 0; i < this._messages.length; i++) {
            this._ctx.fillStyle = 'rgba(255,255,255,' + opacity.toFixed(2) + ')';
            this._ctx.fillText(this._messages[i], 200, pos);
            pos += 10;
            opacity = opacity > 0 ? opacity - 0.05 : 0;
        }
    }
}

;// CONCATENATED MODULE: ./Math/Random.ts
/**
 * @module
 * Pseudo-Random Utility
 *
 * A pseudo-random utility to add seeded random support for help in
 * generating things like terrain or reproducible randomness. Uses the
 * [Mersenne Twister](https://en.wikipedia.org/wiki/Mersenne_Twister) algorithm.
 */
/**
 * 32-bit mask
 */
const BITMASK32 = 0xffffffff;
/**
 * Pseudo-random number generator following the Mersenne_Twister algorithm. Given a seed this generator will produce the same sequence
 * of numbers each time it is called.
 * See https://en.wikipedia.org/wiki/Mersenne_Twister for more details.
 * Uses the MT19937-32 (2002) implementation documented here http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html
 *
 * Api inspired by http://chancejs.com/# https://github.com/chancejs/chancejs
 */
class Random {
    /**
     * If no seed is specified, the Date.now() is used
     */
    constructor(seed) {
        this.seed = seed;
        // Separation point of one one word, the number of bits in the lower bitmask 0 <= r <= w-1
        this._lowerMask = 0x7fffffff; // 31 bits same as _r
        this._upperMask = 0x80000000; // 34 high bits
        // Word size, 64 bits
        this._w = 32;
        // Degree of recurrence
        this._n = 624;
        // Middle word, an offset used in the recurrence defining the series x, 1<=m<n
        this._m = 397;
        // coefficients of teh rational normal form twist matrix
        this._a = 0x9908b0df;
        // tempering bit shifts and masks
        this._u = 11;
        this._s = 7;
        this._b = 0x9d2c5680;
        this._t = 15;
        this._c = 0xefc60000;
        this._l = 18;
        this._f = 1812433253;
        this._mt = new Array(this._n);
        // need to mask to support higher bit machines
        this._mt[0] = (seed || Date.now()) >>> 0;
        for (let i = 1; i < this._n; i++) {
            const s = this._mt[i - 1] ^ (this._mt[i - 1] >>> (this._w - 2));
            // numbers are bigger than the JS max safe int, add in 16-bit chunks to prevent IEEE rounding errors on high bits
            this._mt[i] = (((this._f * ((s & 0xffff0000) >>> 16)) << 16) + this._f * (s & 0xffff) + i) >>> 0;
        }
        this._index = this._n;
    }
    /**
     * Apply the twist
     */
    _twist() {
        const mag01 = [0x0, this._a];
        let y = 0, i = 0;
        for (; i < this._n - this._m; i++) {
            y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);
            this._mt[i] = this._mt[i + this._m] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);
        }
        for (; i < this._n - 1; i++) {
            y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);
            this._mt[i] = this._mt[i + (this._m - this._n)] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);
        }
        y = (this._mt[this._n - 1] & this._upperMask) | (this._mt[0] & this._lowerMask);
        this._mt[this._n - 1] = this._mt[this._m - 1] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);
        this._index = 0;
    }
    /**
     * Return next 32 bit integer number in sequence
     */
    nextInt() {
        if (this._index >= this._n) {
            this._twist();
        }
        let y = this._mt[this._index++];
        y ^= y >>> this._u;
        y ^= (y << this._s) & this._b;
        y ^= (y << this._t) & this._c;
        y ^= y >>> this._l;
        return y >>> 0;
    }
    /**
     * Return a random floating point number between [0, 1)
     */
    next() {
        return this.nextInt() * (1.0 / 4294967296.0); // divided by 2^32
    }
    /**
     * Return a random floating point in range [min, max) min is included, max is not included
     */
    floating(min, max) {
        return (max - min) * this.next() + min;
    }
    /**
     * Return a random integer in range [min, max] min is included, max is included.
     * Implemented with rejection sampling, see https://medium.com/@betable/tifu-by-using-math-random-f1c308c4fd9d#.i13tdiu5a
     */
    integer(min, max) {
        return Math.floor((max - min + 1) * this.next() + min);
    }
    /**
     * Returns true or false randomly with 50/50 odds by default.
     * By default the likelihood of returning a true is .5 (50%).
     * @param likelihood takes values between [0, 1]
     */
    bool(likelihood = 0.5) {
        return this.next() <= likelihood;
    }
    /**
     * Returns one element from an array at random
     */
    pickOne(array) {
        return array[this.integer(0, array.length - 1)];
    }
    /**
     * Returns a new array random picking elements from the original
     * @param array Original array to pick from
     * @param numPicks can be any positive number
     * @param allowDuplicates indicates whether the returned set is allowed duplicates (it does not mean there will always be duplicates
     * just that it is possible)
     */
    pickSet(array, numPicks, allowDuplicates = false) {
        if (allowDuplicates) {
            return this._pickSetWithDuplicates(array, numPicks);
        }
        else {
            return this._pickSetWithoutDuplicates(array, numPicks);
        }
    }
    /**
     * Returns a new array randomly picking elements in the original (not reused)
     * @param array Array to pick elements out of
     * @param numPicks must be less than or equal to the number of elements in the array.
     */
    _pickSetWithoutDuplicates(array, numPicks) {
        if (numPicks > array.length || numPicks < 0) {
            throw new Error('Invalid number of elements to pick, must pick a value 0 < n <= length');
        }
        if (numPicks === array.length) {
            return array;
        }
        const result = new Array(numPicks);
        let currentPick = 0;
        const tempArray = array.slice(0);
        while (currentPick < numPicks) {
            const index = this.integer(0, tempArray.length - 1);
            result[currentPick++] = tempArray[index];
            tempArray.splice(index, 1);
        }
        return result;
    }
    /**
     * Returns a new array random picking elements from the original allowing duplicates
     * @param array Array to pick elements out of
     * @param numPicks can be any positive number
     */
    _pickSetWithDuplicates(array, numPicks) {
        // Typescript numbers are all floating point, so do we add check for int? (or floor the input?)
        if (numPicks < 0) {
            throw new Error('Invalid number of elements to pick, must pick a value 0 <= n < MAX_INT');
        }
        const result = new Array(numPicks);
        for (let i = 0; i < numPicks; i++) {
            result[i] = this.pickOne(array);
        }
        return result;
    }
    /**
     * Returns a new array that has its elements shuffled. Using the Fisher/Yates method
     * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
     */
    shuffle(array) {
        const tempArray = array.slice(0);
        let swap = null;
        for (let i = 0; i < tempArray.length - 2; i++) {
            const randomIndex = this.integer(i, tempArray.length - 1);
            swap = tempArray[i];
            tempArray[i] = tempArray[randomIndex];
            tempArray[randomIndex] = swap;
        }
        return tempArray;
    }
    /**
     * Generate a list of random integer numbers
     * @param length the length of the final array
     * @param min the minimum integer number to generate inclusive
     * @param max the maximum integer number to generate inclusive
     */
    range(length, min, max) {
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
            result[i] = this.integer(min, max);
        }
        return result;
    }
    /**
     * Returns the result of a d4 dice roll
     */
    d4() {
        return this.integer(1, 4);
    }
    /**
     * Returns the result of a d6 dice roll
     */
    d6() {
        return this.integer(1, 6);
    }
    /**
     * Returns the result of a d8 dice roll
     */
    d8() {
        return this.integer(1, 8);
    }
    /**
     * Returns the result of a d10 dice roll
     */
    d10() {
        return this.integer(1, 10);
    }
    /**
     * Returns the result of a d12 dice roll
     */
    d12() {
        return this.integer(1, 12);
    }
    /**
     * Returns the result of a d20 dice roll
     */
    d20() {
        return this.integer(1, 20);
    }
}

;// CONCATENATED MODULE: ./Collision/Side.ts

/**
 * An enum that describes the sides of an axis aligned box for collision
 */
var Side;
(function (Side) {
    Side["None"] = "None";
    Side["Top"] = "Top";
    Side["Bottom"] = "Bottom";
    Side["Left"] = "Left";
    Side["Right"] = "Right";
})(Side || (Side = {}));
(function (Side) {
    /**
     * Returns the opposite side from the current
     */
    function getOpposite(side) {
        if (side === Side.Top) {
            return Side.Bottom;
        }
        if (side === Side.Bottom) {
            return Side.Top;
        }
        if (side === Side.Left) {
            return Side.Right;
        }
        if (side === Side.Right) {
            return Side.Left;
        }
        return Side.None;
    }
    Side.getOpposite = getOpposite;
    /**
     * Given a vector, return the Side most in that direction (via dot product)
     */
    function fromDirection(direction) {
        const directions = [Vector.Left, Vector.Right, Vector.Up, Vector.Down];
        const directionEnum = [Side.Left, Side.Right, Side.Top, Side.Bottom];
        let max = -Number.MAX_VALUE;
        let maxIndex = -1;
        for (let i = 0; i < directions.length; i++) {
            if (directions[i].dot(direction) > max) {
                max = directions[i].dot(direction);
                maxIndex = i;
            }
        }
        return directionEnum[maxIndex];
    }
    Side.fromDirection = fromDirection;
})(Side || (Side = {}));

;// CONCATENATED MODULE: ./Util/Util.ts



/**
 * Two PI constant
 */
const TwoPI = Math.PI * 2;
/**
 * Merges one or more objects into a single target object
 *
 * @returns Merged object with properties from other objects
 * @credit https://gomakethings.com/vanilla-javascript-version-of-jquery-extend/
 */
function extend() {
    const extended = {};
    let deep = false;
    let i = 0;
    const length = arguments.length;
    // Check if a deep merge
    if (Object.prototype.toString.call(arguments[0]) === '[object Boolean]') {
        deep = arguments[0];
        i++;
    }
    // Merge the object into the extended object
    const assignExists = typeof Object.assign === 'function';
    let merge = null;
    if (!assignExists) {
        merge = function (obj) {
            for (const prop in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, prop)) {
                    // If deep merge and property is an object, merge properties
                    if (deep && Object.prototype.toString.call(obj[prop]) === '[object Object]') {
                        extended[prop] = extend(true, extended[prop], obj[prop]);
                    }
                    else {
                        extended[prop] = obj[prop];
                    }
                }
            }
        };
    }
    else {
        merge = Object.assign;
    }
    // Loop through each object and conduct a merge
    for (; i < length; i++) {
        const obj = arguments[i];
        if (!assignExists) {
            merge(obj);
        }
        else {
            merge(extended, obj);
        }
    }
    return extended;
}
/**
 * Encode a string in base64
 * @deprecated This will be removed in v0.26.0
 */
function base64Encode(inputStr) {
    const b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    let outputStr = '';
    let i = 0;
    while (i < inputStr.length) {
        //all three "& 0xff" added below are there to fix a known bug
        //with bytes returned by xhr.responseText
        const byte1 = inputStr.charCodeAt(i++) & 0xff;
        const byte2 = inputStr.charCodeAt(i++) & 0xff;
        const byte3 = inputStr.charCodeAt(i++) & 0xff;
        const enc1 = byte1 >> 2;
        const enc2 = ((byte1 & 3) << 4) | (byte2 >> 4);
        let enc3, enc4;
        if (isNaN(byte2)) {
            enc3 = enc4 = 64;
        }
        else {
            enc3 = ((byte2 & 15) << 2) | (byte3 >> 6);
            if (isNaN(byte3)) {
                enc4 = 64;
            }
            else {
                enc4 = byte3 & 63;
            }
        }
        outputStr += b64.charAt(enc1) + b64.charAt(enc2) + b64.charAt(enc3) + b64.charAt(enc4);
    }
    return outputStr;
}
/**
 * Sugar that will use `nullishVal` if it's not null or undefined. Simulates the `??` operator
 * @param nullishVal
 * @param defaultVal
 */
function nullish(nullishVal, defaultVal) {
    return nullishVal !== null && nullishVal !== undefined ? nullishVal : defaultVal;
}
/**
 * Clamps a value between a min and max inclusive
 */
function clamp(val, min, max) {
    return Math.min(Math.max(min, val), max);
}
/**
 * Find a random floating point number in range
 */
function randomInRange(min, max, random = new Random()) {
    return random ? random.floating(min, max) : min + Math.random() * (max - min);
}
/**
 * Find a random integer in a range
 */
function randomIntInRange(min, max, random = new Random()) {
    return random ? random.integer(min, max) : Math.round(randomInRange(min, max));
}
/**
 * Convert an angle to be the equivalent in the range [0, 2PI]
 */
function canonicalizeAngle(angle) {
    let tmpAngle = angle;
    if (angle > TwoPI) {
        while (tmpAngle > TwoPI) {
            tmpAngle -= TwoPI;
        }
    }
    if (angle < 0) {
        while (tmpAngle < 0) {
            tmpAngle += TwoPI;
        }
    }
    return tmpAngle;
}
/**
 * Convert radians to degrees
 */
function toDegrees(radians) {
    return (180 / Math.PI) * radians;
}
/**
 * Convert degrees to radians
 */
function toRadians(degrees) {
    return (degrees / 180) * Math.PI;
}
/**
 * Find the screen position of an HTML element
 */
function getPosition(el) {
    let oLeft = 0, oTop = 0;
    const calcOffsetLeft = (parent) => {
        oLeft += parent.offsetLeft;
        if (parent.offsetParent) {
            calcOffsetLeft(parent.offsetParent);
        }
    };
    const calcOffsetTop = (parent) => {
        oTop += parent.offsetTop;
        if (parent.offsetParent) {
            calcOffsetTop(parent.offsetParent);
        }
    };
    calcOffsetLeft(el);
    calcOffsetTop(el);
    return new Vector(oLeft, oTop);
}
/**
 * Add an item to an array list if it doesn't already exist. Returns true if added, false if not and already exists in the array.
 * @deprecated Will be removed in v0.26.0
 */
function addItemToArray(item, array) {
    if (array.indexOf(item) === -1) {
        array.push(item);
        return true;
    }
    return false;
}
/**
 * Remove an item from an list
 * @deprecated Will be removed in v0.26.0
 */
function removeItemFromArray(item, array) {
    let index = -1;
    if ((index = array.indexOf(item)) > -1) {
        array.splice(index, 1);
        return true;
    }
    return false;
}
/**
 * See if an array contains something
 */
function contains(array, obj) {
    for (let i = 0; i < array.length; i++) {
        if (array[i] === obj) {
            return true;
        }
    }
    return false;
}
/**
 * Get the opposit side
 * TODO: Move to Side type
 * @deprecated Will be removed in v0.26.0
 */
function getOppositeSide(side) {
    if (side === Side.Top) {
        return Side.Bottom;
    }
    if (side === Side.Bottom) {
        return Side.Top;
    }
    if (side === Side.Left) {
        return Side.Right;
    }
    if (side === Side.Right) {
        return Side.Left;
    }
    return Side.None;
}
/**
 * Returns the side in the direction of the vector supplied
 * @param direction Vector to check
 * @deprecated
 * TODO: Move to Side type
 */
function getSideFromDirection(direction) {
    const directions = [Vector.Left, Vector.Right, Vector.Up, Vector.Down];
    const directionEnum = [Side.Left, Side.Right, Side.Top, Side.Bottom];
    let max = -Number.MAX_VALUE;
    let maxIndex = -1;
    for (let i = 0; i < directions.length; i++) {
        if (directions[i].dot(direction) > max) {
            max = directions[i].dot(direction);
            maxIndex = i;
        }
    }
    return directionEnum[maxIndex];
}
/**
 * Excalibur's dynamically resizing collection
 * @deprecated Will be removed v0.26.0
 */
class Collection {
    /**
     * @param initialSize  Initial size of the internal backing array
     */
    constructor(initialSize = Collection.DefaultSize) {
        this._internalArray = null;
        this._endPointer = 0;
        this._internalArray = new Array(initialSize);
    }
    _resize() {
        const newSize = this._internalArray.length * 2;
        const newArray = new Array(newSize);
        const count = this.count();
        for (let i = 0; i < count; i++) {
            newArray[i] = this._internalArray[i];
        }
        delete this._internalArray;
        this._internalArray = newArray;
    }
    /**
     * Push elements to the end of the collection
     */
    push(element) {
        if (this._endPointer === this._internalArray.length) {
            this._resize();
        }
        return (this._internalArray[this._endPointer++] = element);
    }
    /**
     * Removes elements from the end of the collection
     */
    pop() {
        this._endPointer = this._endPointer - 1 < 0 ? 0 : this._endPointer - 1;
        return this._internalArray[this._endPointer];
    }
    /**
     * Returns the count of the collection
     */
    count() {
        return this._endPointer;
    }
    /**
     * Empties the collection
     */
    clear() {
        this._endPointer = 0;
    }
    /**
     * Returns the size of the internal backing array
     */
    internalSize() {
        return this._internalArray.length;
    }
    /**
     * Returns an element at a specific index
     * @param index  Index of element to retrieve
     */
    elementAt(index) {
        if (index >= this.count()) {
            //Logger.getInstance().error('Invalid parameter: ' + index);
            throw new Error('Invalid index ' + index);
        }
        return this._internalArray[index];
    }
    /**
     * Inserts an element at a specific index
     * @param index  Index to insert the element
     * @param value  Element to insert
     */
    insert(index, value) {
        if (index >= this.count()) {
            this._resize();
        }
        return (this._internalArray[index] = value);
    }
    /**
     * Removes an element at a specific index
     * @param index  Index of element to remove
     */
    remove(index) {
        const count = this.count();
        if (count === 0) {
            //Logger.getInstance().error('Invalid parameter: ' + index);
            throw new Error('Invalid parameter ' + index);
        }
        // O(n) Shift
        const removed = this._internalArray[index];
        for (let i = index; i < count; i++) {
            this._internalArray[i] = this._internalArray[i + 1];
        }
        this._endPointer--;
        return removed;
    }
    /**
     * Removes an element by reference
     * @param element  Element to retrieve
     */
    removeElement(element) {
        const index = this._internalArray.indexOf(element);
        this.remove(index);
    }
    /**
     * Returns a array representing the collection
     */
    toArray() {
        return this._internalArray.slice(0, this._endPointer);
    }
    /**
     * Iterate over every element in the collection
     * @param func  Callback to call for each element passing a reference to the element and its index, returned values are ignored
     */
    forEach(func) {
        let i = 0;
        const count = this.count();
        for (i; i < count; i++) {
            func.call(this, this._internalArray[i], i);
        }
    }
    /**
     * Mutate every element in the collection
     * @param func  Callback to call for each element passing a reference to the element and its index, any values returned mutate
     * the collection
     */
    map(func) {
        const count = this.count();
        for (let i = 0; i < count; i++) {
            this._internalArray[i] = func.call(this, this._internalArray[i], i);
        }
    }
}
/**
 * Default collection size
 */
Collection.DefaultSize = 200;
/**
 * Used for exhaustive checks at compile time
 */
function fail(message) {
    throw new Error(message);
}
/**
 * Generate a range of numbers
 * For example: range(0, 5) -> [0, 1, 2, 3, 4, 5]
 * @param from inclusive
 * @param to inclusive
 */
const range = (from, to) => Array.from(new Array(to - from + 1), (_x, i) => i + from);
/**
 * Create a promise that resolves after a certain number of milliseconds
 * @param milliseconds
 */
function delay(milliseconds) {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve();
        }, milliseconds);
    });
}

;// CONCATENATED MODULE: ./Util/Decorators.ts



const maxMessages = 5;
const obsoleteMessage = {};
const resetObsoleteCounter = () => {
    for (const message in obsoleteMessage) {
        obsoleteMessage[message] = 0;
    }
};
const logMessage = (message, options) => {
    const suppressObsoleteMessages = Flags.isEnabled('suppress-obsolete-message');
    if (obsoleteMessage[message] < maxMessages && !suppressObsoleteMessages) {
        Logger.getInstance().warn(message);
        // tslint:disable-next-line: no-console
        if (console.trace && options.showStackTrace) {
            // tslint:disable-next-line: no-console
            console.trace();
        }
    }
    obsoleteMessage[message]++;
};
/**
 * Obsolete decorator for marking Excalibur methods obsolete, you can optionally specify a custom message and/or alternate replacement
 * method do the deprecated one. Inspired by https://github.com/jayphelps/core-decorators.js
 */
function obsolete(options) {
    options = extend({}, {
        message: 'This feature will be removed in future versions of Excalibur.',
        alternateMethod: null,
        showStackTrack: false
    }, options);
    return function (target, property, descriptor) {
        if (descriptor &&
            !(typeof descriptor.value === 'function' || typeof descriptor.get === 'function' || typeof descriptor.set === 'function')) {
            throw new SyntaxError('Only classes/functions/getters/setters can be marked as obsolete');
        }
        const methodSignature = `${target.name || ''}${target.name && property ? '.' : ''}${property ? property : ''}`;
        const message = `${methodSignature} is marked obsolete: ${options.message}` +
            (options.alternateMethod ? ` Use ${options.alternateMethod} instead` : '');
        if (!obsoleteMessage[message]) {
            obsoleteMessage[message] = 0;
        }
        // If descriptor is null it is a class
        const method = descriptor ? Object.assign({}, descriptor) : target;
        if (!descriptor) {
            // with es2015 classes we need to change our decoration tactic
            class DecoratedClass extends method {
                constructor(...args) {
                    logMessage(message, options);
                    super(...args);
                }
            }
            return DecoratedClass;
        }
        if (descriptor && descriptor.value) {
            method.value = function () {
                logMessage(message, options);
                return descriptor.value.apply(this, arguments);
            };
            return method;
        }
        if (descriptor && descriptor.get) {
            method.get = function () {
                logMessage(message, options);
                return descriptor.get.apply(this, arguments);
            };
        }
        if (descriptor && descriptor.set) {
            method.set = function () {
                logMessage(message, options);
                return descriptor.set.apply(this, arguments);
            };
        }
        return method;
    };
}

;// CONCATENATED MODULE: ./Math/vector.ts
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/**
 * A 2D vector on a plane.
 */
class Vector {
    /**
     * @param x  X component of the Vector
     * @param y  Y component of the Vector
     */
    constructor(x, y) {
        this._x = 0;
        this._y = 0;
        this._x = x;
        this._y = y;
    }
    /**
     * A (0, 0) vector
     */
    static get Zero() {
        return new Vector(0, 0);
    }
    /**
     * A (1, 1) vector
     */
    static get One() {
        return new Vector(1, 1);
    }
    /**
     * A (0.5, 0.5) vector
     */
    static get Half() {
        return new Vector(0.5, 0.5);
    }
    /**
     * A unit vector pointing up (0, -1)
     */
    static get Up() {
        return new Vector(0, -1);
    }
    /**
     * A unit vector pointing down (0, 1)
     */
    static get Down() {
        return new Vector(0, 1);
    }
    /**
     * A unit vector pointing left (-1, 0)
     */
    static get Left() {
        return new Vector(-1, 0);
    }
    /**
     * A unit vector pointing right (1, 0)
     */
    static get Right() {
        return new Vector(1, 0);
    }
    /**
     * Returns a vector of unit length in the direction of the specified angle in Radians.
     * @param angle The angle to generate the vector
     */
    static fromAngle(angle) {
        return new Vector(Math.cos(angle), Math.sin(angle));
    }
    /**
     * Checks if vector is not null, undefined, or if any of its components are NaN or Infinity.
     */
    static isValid(vec) {
        if (vec === null || vec === undefined) {
            return false;
        }
        if (isNaN(vec.x) || isNaN(vec.y)) {
            return false;
        }
        if (vec.x === Infinity || vec.y === Infinity || vec.x === -Infinity || vec.y === -Infinity) {
            return false;
        }
        return true;
    }
    /**
     * Calculates distance between two Vectors
     * @param vec1
     * @param vec2
     */
    static distance(vec1, vec2) {
        return Math.sqrt(Math.pow(vec1.x - vec2.x, 2) + Math.pow(vec1.y - vec2.y, 2));
    }
    /**
     * Get the x component of the vector
     */
    get x() {
        return this._x;
    }
    /**
     * Set the x component, THIS MUTATES the current vector. It is usually better to create a new vector.
     * @warning **Be very careful setting components on shared vectors, mutating shared vectors can cause hard to find bugs**
     */
    set x(val) {
        this._x = val;
    }
    /**
     * Get the y component of the vector
     */
    get y() {
        return this._y;
    }
    /**
     * Set the y component, THIS MUTATES the current vector. It is usually better to create a new vector.
     * @warning **Be very careful setting components on shared vectors, mutating shared vectors can cause hard to find bugs**
     */
    set y(val) {
        this._y = val;
    }
    /**
     * Sets the x and y components at once, THIS MUTATES the current vector. It is usually better to create a new vector.
     *
     * @warning **Be very careful using this, mutating vectors can cause hard to find bugs**
     */
    setTo(x, y) {
        this.x = x;
        this.y = y;
    }
    /**
     * Compares this point against another and tests for equality
     * @param vector The other point to compare to
     * @param tolerance Amount of euclidean distance off we are willing to tolerate
     */
    equals(vector, tolerance = 0.001) {
        return Math.abs(this.x - vector.x) <= tolerance && Math.abs(this.y - vector.y) <= tolerance;
    }
    /**
     * The distance to another vector. If no other Vector is specified, this will return the [[magnitude]].
     * @param v  The other vector. Leave blank to use origin vector.
     */
    distance(v) {
        if (!v) {
            v = Vector.Zero;
        }
        return Math.sqrt(Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2));
    }
    squareDistance(v) {
        if (!v) {
            v = Vector.Zero;
        }
        return Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2);
    }
    /**
     * The magnitude (size) of the Vector
     * @deprecated magnitude will be removed in favour of '.size' in version 0.25.0
     */
    magnitude() {
        return this.distance();
    }
    /**
     * The size (magnitude) of the Vector
     */
    get size() {
        return this.distance();
    }
    /**
     * Setting the size mutates the current vector
     *
     * @warning Can be used to set the size of the vector, **be very careful using this, mutating vectors can cause hard to find bugs**
     */
    set size(newLength) {
        const v = this.normalize().scale(newLength);
        this.setTo(v.x, v.y);
    }
    /**
     * Normalizes a vector to have a magnitude of 1.
     */
    normalize() {
        const d = this.distance();
        if (d > 0) {
            return new Vector(this.x / d, this.y / d);
        }
        else {
            return new Vector(0, 1);
        }
    }
    /**
     * Returns the average (midpoint) between the current point and the specified
     */
    average(vec) {
        return this.add(vec).scale(0.5);
    }
    scale(sizeOrScale) {
        if (sizeOrScale instanceof Vector) {
            return new Vector(this.x * sizeOrScale.x, this.y * sizeOrScale.y);
        }
        else {
            return new Vector(this.x * sizeOrScale, this.y * sizeOrScale);
        }
    }
    /**
     * Adds one vector to another
     * @param v The vector to add
     */
    add(v) {
        return new Vector(this.x + v.x, this.y + v.y);
    }
    /**
     * Subtracts a vector from another, if you subtract vector `B.sub(A)` the resulting vector points from A -> B
     * @param v The vector to subtract
     */
    sub(v) {
        return new Vector(this.x - v.x, this.y - v.y);
    }
    /**
     * Adds one vector to this one modifying the original
     * @param v The vector to add
     * @warning Be very careful using this, mutating vectors can cause hard to find bugs
     */
    addEqual(v) {
        this.setTo(this.x + v.x, this.y + v.y);
        return this;
    }
    /**
     * Subtracts a vector from this one modifying the original
     * @param v The vector to subtract
     * @warning Be very careful using this, mutating vectors can cause hard to find bugs
     */
    subEqual(v) {
        this.setTo(this.x - v.x, this.y - v.y);
        return this;
    }
    /**
     * Scales this vector by a factor of size and modifies the original
     * @warning Be very careful using this, mutating vectors can cause hard to find bugs
     */
    scaleEqual(size) {
        this.setTo(this.x * size, this.y * size);
        return this;
    }
    /**
     * Performs a dot product with another vector
     * @param v  The vector to dot
     */
    dot(v) {
        return this.x * v.x + this.y * v.y;
    }
    cross(v) {
        if (v instanceof Vector) {
            return this.x * v.y - this.y * v.x;
        }
        else if (typeof v === 'number') {
            return new Vector(v * this.y, -v * this.x);
        }
    }
    static cross(num, vec) {
        return new Vector(-num * vec.y, num * vec.x);
    }
    /**
     * Returns the perpendicular vector to this one
     */
    perpendicular() {
        return new Vector(this.y, -this.x);
    }
    /**
     * Returns the normal vector to this one, same as the perpendicular of length 1
     */
    normal() {
        return this.perpendicular().normalize();
    }
    /**
     * Negate the current vector
     */
    negate() {
        return this.scale(-1);
    }
    /**
     * Returns the angle of this vector.
     */
    toAngle() {
        return Math.atan2(this.y, this.x);
    }
    /**
     * Rotates the current vector around a point by a certain number of
     * degrees in radians
     */
    rotate(angle, anchor) {
        if (!anchor) {
            anchor = new Vector(0, 0);
        }
        const sinAngle = Math.sin(angle);
        const cosAngle = Math.cos(angle);
        const x = cosAngle * (this.x - anchor.x) - sinAngle * (this.y - anchor.y) + anchor.x;
        const y = sinAngle * (this.x - anchor.x) + cosAngle * (this.y - anchor.y) + anchor.y;
        return new Vector(x, y);
    }
    /**
     * Creates new vector that has the same values as the previous.
     */
    clone() {
        return new Vector(this.x, this.y);
    }
    /**
     * Returns a string representation of the vector.
     */
    toString(fixed) {
        if (fixed) {
            return `(${this.x.toFixed(fixed)}, ${this.y.toFixed(fixed)})`;
        }
        return `(${this.x}, ${this.y})`;
    }
}
__decorate([
    obsolete({ message: 'will be removed in favour of `.size` in version 0.25.0' })
], Vector.prototype, "magnitude", null);
/**
 * Shorthand for creating new Vectors - returns a new Vector instance with the
 * provided X and Y components.
 *
 * @param x  X component of the Vector
 * @param y  Y component of the Vector
 */
function vec(x, y) {
    return new Vector(x, y);
}

;// CONCATENATED MODULE: ./Color.ts
var Color_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/**
 * Provides standard colors (e.g. [[Color.Black]])
 * but you can also create custom colors using RGB, HSL, or Hex. Also provides
 * useful color operations like [[Color.lighten]], [[Color.darken]], and more.
 */
class Color {
    /**
     * Creates a new instance of Color from an r, g, b, a
     *
     * @param r  The red component of color (0-255)
     * @param g  The green component of color (0-255)
     * @param b  The blue component of color (0-255)
     * @param a  The alpha component of color (0-1.0)
     */
    constructor(r, g, b, a) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a != null ? a : 1;
    }
    /**
     * Creates a new instance of Color from an r, g, b, a
     *
     * @param r  The red component of color (0-255)
     * @param g  The green component of color (0-255)
     * @param b  The blue component of color (0-255)
     * @param a  The alpha component of color (0-1.0)
     */
    static fromRGB(r, g, b, a) {
        return new Color(r, g, b, a);
    }
    /**
     * Creates a new instance of Color from a rgb string
     *
     * @param string  CSS color string of the form rgba(255, 255, 255, 1) or rgb(255, 255, 255)
     */
    static fromRGBString(string) {
        const rgbaRegEx = /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)/i;
        let match = null;
        if ((match = string.match(rgbaRegEx))) {
            const r = parseInt(match[1], 10);
            const g = parseInt(match[2], 10);
            const b = parseInt(match[3], 10);
            let a = 1;
            if (match[4]) {
                a = parseFloat(match[4]);
            }
            return new Color(r, g, b, a);
        }
        else {
            throw new Error('Invalid rgb/a string: ' + string);
        }
    }
    /**
     * Creates a new instance of Color from a hex string
     *
     * @param hex  CSS color string of the form #ffffff, the alpha component is optional
     */
    static fromHex(hex) {
        const hexRegEx = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;
        let match = null;
        if ((match = hex.match(hexRegEx))) {
            const r = parseInt(match[1], 16);
            const g = parseInt(match[2], 16);
            const b = parseInt(match[3], 16);
            let a = 1;
            if (match[4]) {
                a = parseInt(match[4], 16) / 255;
            }
            return new Color(r, g, b, a);
        }
        else {
            throw new Error('Invalid hex string: ' + hex);
        }
    }
    /**
     * Creates a new instance of Color from hsla values
     *
     * @param h  Hue is represented [0-1]
     * @param s  Saturation is represented [0-1]
     * @param l  Luminance is represented [0-1]
     * @param a  Alpha is represented [0-1]
     */
    static fromHSL(h, s, l, a = 1.0) {
        const temp = new HSLColor(h, s, l, a);
        return temp.toRGBA();
    }
    /**
     * Lightens the current color by a specified amount
     *
     * @param factor  The amount to lighten by [0-1]
     */
    lighten(factor = 0.1) {
        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
        temp.l += (1 - temp.l) * factor;
        return temp.toRGBA();
    }
    /**
     * Darkens the current color by a specified amount
     *
     * @param factor  The amount to darken by [0-1]
     */
    darken(factor = 0.1) {
        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
        temp.l -= temp.l * factor;
        return temp.toRGBA();
    }
    /**
     * Saturates the current color by a specified amount
     *
     * @param factor  The amount to saturate by [0-1]
     */
    saturate(factor = 0.1) {
        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
        temp.s += temp.s * factor;
        return temp.toRGBA();
    }
    /**
     * Desaturates the current color by a specified amount
     *
     * @param factor  The amount to desaturate by [0-1]
     */
    desaturate(factor = 0.1) {
        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
        temp.s -= temp.s * factor;
        return temp.toRGBA();
    }
    /**
     * Multiplies a color by another, results in a darker color
     *
     * @param color  The other color
     */
    multiply(color) {
        const newR = (((color.r / 255) * this.r) / 255) * 255;
        const newG = (((color.g / 255) * this.g) / 255) * 255;
        const newB = (((color.b / 255) * this.b) / 255) * 255;
        const newA = color.a * this.a;
        return new Color(newR, newG, newB, newA);
    }
    /**
     * Multiplies a color by another, results in a darker color
     * @param color
     * @deprecated Alias for incorrect spelling used in older versions, use multiply instead, will be removed in v0.25.0
     */
    mulitiply(color) {
        return this.multiply(color);
    }
    /**
     * Screens a color by another, results in a lighter color
     *
     * @param color  The other color
     */
    screen(color) {
        const color1 = color.invert();
        const color2 = color.invert();
        return color1.multiply(color2).invert();
    }
    /**
     * Inverts the current color
     */
    invert() {
        return new Color(255 - this.r, 255 - this.g, 255 - this.b, 1.0 - this.a);
    }
    /**
     * Averages the current color with another
     *
     * @param color  The other color
     */
    average(color) {
        const newR = (color.r + this.r) / 2;
        const newG = (color.g + this.g) / 2;
        const newB = (color.b + this.b) / 2;
        const newA = (color.a + this.a) / 2;
        return new Color(newR, newG, newB, newA);
    }
    equal(color) {
        return this.toString() === color.toString();
    }
    /**
     * Returns a CSS string representation of a color.
     *
     * @param format Color representation, accepts: rgb, hsl, or hex
     */
    toString(format = 'rgb') {
        switch (format) {
            case 'rgb':
                return this.toRGBA();
            case 'hsl':
                return this.toHSLA();
            case 'hex':
                return this.toHex();
            default:
                throw new Error('Invalid Color format');
        }
    }
    /**
     * Returns Hex Value of a color component
     * @param c color component
     * @see https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
     */
    _componentToHex(c) {
        const hex = c.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
    }
    /**
     * Return Hex representation of a color.
     */
    toHex() {
        return '#' + this._componentToHex(this.r) + this._componentToHex(this.g) + this._componentToHex(this.b);
    }
    /**
     * Return RGBA representation of a color.
     */
    toRGBA() {
        const result = String(this.r.toFixed(0)) + ', ' + String(this.g.toFixed(0)) + ', ' + String(this.b.toFixed(0));
        if (this.a !== undefined || this.a !== null) {
            return 'rgba(' + result + ', ' + String(this.a) + ')';
        }
        return 'rgb(' + result + ')';
    }
    /**
     * Return HSLA representation of a color.
     */
    toHSLA() {
        return HSLColor.fromRGBA(this.r, this.g, this.b, this.a).toString();
    }
    /**
     * Returns a CSS string representation of a color.
     */
    fillStyle() {
        return this.toString();
    }
    /**
     * Returns a clone of the current color.
     */
    clone() {
        return new Color(this.r, this.g, this.b, this.a);
    }
    /**
     * Black (#000000)
     */
    static get Black() {
        return Color.fromHex('#000000');
    }
    /**
     * White (#FFFFFF)
     */
    static get White() {
        return Color.fromHex('#FFFFFF');
    }
    /**
     * Gray (#808080)
     */
    static get Gray() {
        return Color.fromHex('#808080');
    }
    /**
     * Light gray (#D3D3D3)
     */
    static get LightGray() {
        return Color.fromHex('#D3D3D3');
    }
    /**
     * Dark gray (#A9A9A9)
     */
    static get DarkGray() {
        return Color.fromHex('#A9A9A9');
    }
    /**
     * Yellow (#FFFF00)
     */
    static get Yellow() {
        return Color.fromHex('#FFFF00');
    }
    /**
     * Orange (#FFA500)
     */
    static get Orange() {
        return Color.fromHex('#FFA500');
    }
    /**
     * Red (#FF0000)
     */
    static get Red() {
        return Color.fromHex('#FF0000');
    }
    /**
     * Vermilion (#FF5B31)
     */
    static get Vermilion() {
        return Color.fromHex('#FF5B31');
    }
    /**
     * Vermilion (#FF5B31)
     * @deprecated Alias for incorrect spelling used in older versions, use multiply instead, will be removed in v0.25.0
     */
    static get Vermillion() {
        return Color.Vermilion;
    }
    /**
     * Rose (#FF007F)
     */
    static get Rose() {
        return Color.fromHex('#FF007F');
    }
    /**
     * Magenta (#FF00FF)
     */
    static get Magenta() {
        return Color.fromHex('#FF00FF');
    }
    /**
     * Violet (#7F00FF)
     */
    static get Violet() {
        return Color.fromHex('#7F00FF');
    }
    /**
     * Blue (#0000FF)
     */
    static get Blue() {
        return Color.fromHex('#0000FF');
    }
    /**
     * Azure (#007FFF)
     */
    static get Azure() {
        return Color.fromHex('#007FFF');
    }
    /**
     * Cyan (#00FFFF)
     */
    static get Cyan() {
        return Color.fromHex('#00FFFF');
    }
    /**
     * Viridian (#59978F)
     */
    static get Viridian() {
        return Color.fromHex('#59978F');
    }
    /**
     * Green (#00FF00)
     */
    static get Green() {
        return Color.fromHex('#00FF00');
    }
    /**
     * Chartreuse (#7FFF00)
     */
    static get Chartreuse() {
        return Color.fromHex('#7FFF00');
    }
    /**
     * Transparent (#FFFFFF00)
     */
    static get Transparent() {
        return Color.fromHex('#FFFFFF00');
    }
    /**
     * ExcaliburBlue (#176BAA)
     */
    static get ExcaliburBlue() {
        return Color.fromHex('#176BAA');
    }
}
Color_decorate([
    obsolete({ message: 'Alias for incorrect spelling used in older versions, use multiply instead, will be removed in v0.25.0' })
], Color.prototype, "mulitiply", null);
Color_decorate([
    obsolete({
        message: 'Alias for incorrect spelling used in older versions',
        alternateMethod: 'Vermilion'
    })
], Color, "Vermillion", null);
/**
 * Internal HSL Color representation
 *
 * http://en.wikipedia.org/wiki/HSL_and_HSV
 * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
 */
class HSLColor {
    constructor(h, s, l, a) {
        this.h = h;
        this.s = s;
        this.l = l;
        this.a = a;
    }
    static hue2rgb(p, q, t) {
        if (t < 0) {
            t += 1;
        }
        if (t > 1) {
            t -= 1;
        }
        if (t < 1 / 6) {
            return p + (q - p) * 6 * t;
        }
        if (t < 1 / 2) {
            return q;
        }
        if (t < 2 / 3) {
            return p + (q - p) * (2 / 3 - t) * 6;
        }
        return p;
    }
    static fromRGBA(r, g, b, a) {
        r /= 255;
        g /= 255;
        b /= 255;
        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s;
        const l = (max + min) / 2;
        if (max === min) {
            h = s = 0; // achromatic
        }
        else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
            }
            h /= 6;
        }
        return new HSLColor(h, s, l, a);
    }
    toRGBA() {
        let r, g, b;
        if (this.s === 0) {
            r = g = b = this.l; // achromatic
        }
        else {
            const q = this.l < 0.5 ? this.l * (1 + this.s) : this.l + this.s - this.l * this.s;
            const p = 2 * this.l - q;
            r = HSLColor.hue2rgb(p, q, this.h + 1 / 3);
            g = HSLColor.hue2rgb(p, q, this.h);
            b = HSLColor.hue2rgb(p, q, this.h - 1 / 3);
        }
        return new Color(r * 255, g * 255, b * 255, this.a);
    }
    toString() {
        const h = this.h.toFixed(0), s = this.s.toFixed(0), l = this.l.toFixed(0), a = this.a.toFixed(0);
        return `hsla(${h}, ${s}, ${l}, ${a})`;
    }
}

;// CONCATENATED MODULE: ./Collision/BoundingBox.ts



/**
 * Axis Aligned collision primitive for Excalibur.
 */
class BoundingBox {
    /**
     * Constructor allows passing of either an object with all coordinate components,
     * or the coordinate components passed separately.
     * @param leftOrOptions    Either x coordinate of the left edge or an options object
     * containing the four coordinate components.
     * @param top     y coordinate of the top edge
     * @param right   x coordinate of the right edge
     * @param bottom  y coordinate of the bottom edge
     */
    constructor(leftOrOptions = 0, top = 0, right = 0, bottom = 0) {
        if (typeof leftOrOptions === 'object') {
            this.left = leftOrOptions.left;
            this.top = leftOrOptions.top;
            this.right = leftOrOptions.right;
            this.bottom = leftOrOptions.bottom;
        }
        else if (typeof leftOrOptions === 'number') {
            this.left = leftOrOptions;
            this.top = top;
            this.right = right;
            this.bottom = bottom;
        }
    }
    /**
     * Given bounding box A & B, returns the side relative to A when intersection is performed.
     * @param intersection Intersection vector between 2 bounding boxes
     */
    static getSideFromIntersection(intersection) {
        if (!intersection) {
            return Side.None;
        }
        if (intersection) {
            if (Math.abs(intersection.x) > Math.abs(intersection.y)) {
                if (intersection.x < 0) {
                    return Side.Right;
                }
                return Side.Left;
            }
            else {
                if (intersection.y < 0) {
                    return Side.Bottom;
                }
                return Side.Top;
            }
        }
        return Side.None;
    }
    static fromPoints(points) {
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        for (let i = 0; i < points.length; i++) {
            if (points[i].x < minX) {
                minX = points[i].x;
            }
            if (points[i].x > maxX) {
                maxX = points[i].x;
            }
            if (points[i].y < minY) {
                minY = points[i].y;
            }
            if (points[i].y > maxY) {
                maxY = points[i].y;
            }
        }
        return new BoundingBox(minX, minY, maxX, maxY);
    }
    static fromDimension(width, height, anchor = Vector.Half, pos = Vector.Zero) {
        return new BoundingBox(-width * anchor.x + pos.x, -height * anchor.y + pos.y, width - width * anchor.x + pos.x, height - height * anchor.y + pos.y);
    }
    /**
     * Returns the calculated width of the bounding box
     */
    get width() {
        return this.right - this.left;
    }
    /**
     * Returns the calculated height of the bounding box
     */
    get height() {
        return this.bottom - this.top;
    }
    /**
     * Return whether the bounding box has zero dimensions in height,width or both
     */
    hasZeroDimensions() {
        return this.width === 0 || this.height === 0;
    }
    /**
     * Returns the center of the bounding box
     */
    get center() {
        return new Vector((this.left + this.right) / 2, (this.top + this.bottom) / 2);
    }
    translate(pos) {
        return new BoundingBox(this.left + pos.x, this.top + pos.y, this.right + pos.x, this.bottom + pos.y);
    }
    /**
     * Rotates a bounding box by and angle and around a point, if no point is specified (0, 0) is used by default. The resulting bounding
     * box is also axis-align. This is useful when a new axis-aligned bounding box is needed for rotated geometry.
     */
    rotate(angle, point = Vector.Zero) {
        const points = this.getPoints().map((p) => p.rotate(angle, point));
        return BoundingBox.fromPoints(points);
    }
    scale(scale, point = Vector.Zero) {
        const shifted = this.translate(point);
        return new BoundingBox(shifted.left * scale.x, shifted.top * scale.y, shifted.right * scale.x, shifted.bottom * scale.y);
    }
    transform(matrix) {
        const points = this.getPoints().map((p) => matrix.multv(p));
        return BoundingBox.fromPoints(points);
    }
    /**
     * Returns the perimeter of the bounding box
     */
    getPerimeter() {
        const wx = this.width;
        const wy = this.height;
        return 2 * (wx + wy);
    }
    getPoints() {
        const results = [];
        results.push(new Vector(this.left, this.top));
        results.push(new Vector(this.right, this.top));
        results.push(new Vector(this.right, this.bottom));
        results.push(new Vector(this.left, this.bottom));
        return results;
    }
    /**
     * Determines whether a ray intersects with a bounding box
     */
    rayCast(ray, farClipDistance = Infinity) {
        // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/
        let tmin = -Infinity;
        let tmax = +Infinity;
        const xinv = ray.dir.x === 0 ? Number.MAX_VALUE : 1 / ray.dir.x;
        const yinv = ray.dir.y === 0 ? Number.MAX_VALUE : 1 / ray.dir.y;
        const tx1 = (this.left - ray.pos.x) * xinv;
        const tx2 = (this.right - ray.pos.x) * xinv;
        tmin = Math.min(tx1, tx2);
        tmax = Math.max(tx1, tx2);
        const ty1 = (this.top - ray.pos.y) * yinv;
        const ty2 = (this.bottom - ray.pos.y) * yinv;
        tmin = Math.max(tmin, Math.min(ty1, ty2));
        tmax = Math.min(tmax, Math.max(ty1, ty2));
        return tmax >= Math.max(0, tmin) && tmin < farClipDistance;
    }
    rayCastTime(ray, farClipDistance = Infinity) {
        // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/
        let tmin = -Infinity;
        let tmax = +Infinity;
        const xinv = ray.dir.x === 0 ? Number.MAX_VALUE : 1 / ray.dir.x;
        const yinv = ray.dir.y === 0 ? Number.MAX_VALUE : 1 / ray.dir.y;
        const tx1 = (this.left - ray.pos.x) * xinv;
        const tx2 = (this.right - ray.pos.x) * xinv;
        tmin = Math.min(tx1, tx2);
        tmax = Math.max(tx1, tx2);
        const ty1 = (this.top - ray.pos.y) * yinv;
        const ty2 = (this.bottom - ray.pos.y) * yinv;
        tmin = Math.max(tmin, Math.min(ty1, ty2));
        tmax = Math.min(tmax, Math.max(ty1, ty2));
        if (tmax >= Math.max(0, tmin) && tmin < farClipDistance) {
            return tmin;
        }
        return -1;
    }
    contains(val) {
        if (val instanceof Vector) {
            return this.left <= val.x && this.top <= val.y && this.bottom >= val.y && this.right >= val.x;
        }
        else if (val instanceof BoundingBox) {
            if (this.left < val.left && this.top < val.top && val.bottom < this.bottom && val.right < this.right) {
                return true;
            }
            return false;
        }
        return false;
    }
    /**
     * Combines this bounding box and another together returning a new bounding box
     * @param other  The bounding box to combine
     */
    combine(other) {
        const compositeBB = new BoundingBox(Math.min(this.left, other.left), Math.min(this.top, other.top), Math.max(this.right, other.right), Math.max(this.bottom, other.bottom));
        return compositeBB;
    }
    get dimensions() {
        return new Vector(this.width, this.height);
    }
    /**
     * Test wether this bounding box intersects with another returning
     * the intersection vector that can be used to resolve the collision. If there
     * is no intersection null is returned.
     *
     * @param other  Other [[BoundingBox]] to test intersection with
     * @returns A Vector in the direction of the current BoundingBox, this <- other
     */
    intersect(other) {
        const totalBoundingBox = this.combine(other);
        // If the total bounding box is less than or equal the sum of the 2 bounds then there is collision
        if (totalBoundingBox.width < other.width + this.width &&
            totalBoundingBox.height < other.height + this.height &&
            !totalBoundingBox.dimensions.equals(other.dimensions) &&
            !totalBoundingBox.dimensions.equals(this.dimensions)) {
            // collision
            let overlapX = 0;
            // right edge is between the other's left and right edge
            /**
             *     +-this-+
             *     |      |
             *     |    +-other-+
             *     +----|-+     |
             *          |       |
             *          +-------+
             *         <---
             *          ^ overlap
             */
            if (this.right >= other.left && this.right <= other.right) {
                overlapX = other.left - this.right;
                // right edge is past the other's right edge
                /**
                 *     +-other-+
                 *     |       |
                 *     |    +-this-+
                 *     +----|--+   |
                 *          |      |
                 *          +------+
                 *          --->
                 *          ^ overlap
                 */
            }
            else {
                overlapX = other.right - this.left;
            }
            let overlapY = 0;
            // top edge is between the other's top and bottom edge
            /**
             *     +-other-+
             *     |       |
             *     |    +-this-+   | <- overlap
             *     +----|--+   |   |
             *          |      |  \ /
             *          +------+   '
             */
            if (this.top <= other.bottom && this.top >= other.top) {
                overlapY = other.bottom - this.top;
                // top edge is above the other top edge
                /**
                 *     +-this-+         .
                 *     |      |        / \
                 *     |    +-other-+   | <- overlap
                 *     +----|-+     |   |
                 *          |       |
                 *          +-------+
                 */
            }
            else {
                overlapY = other.top - this.bottom;
            }
            if (Math.abs(overlapX) < Math.abs(overlapY)) {
                return new Vector(overlapX, 0);
            }
            else {
                return new Vector(0, overlapY);
            }
            // Case of total containment of one bounding box by another
        }
        else if (totalBoundingBox.dimensions.equals(other.dimensions) || totalBoundingBox.dimensions.equals(this.dimensions)) {
            let overlapX = 0;
            // this is wider than the other
            if (this.width - other.width >= 0) {
                // This right edge is closest to the others right edge
                if (this.right - other.right <= other.left - this.left) {
                    overlapX = other.left - this.right;
                    // This left edge is closest to the others left edge
                }
                else {
                    overlapX = other.right - this.left;
                }
                // other is wider than this
            }
            else {
                // This right edge is closest to the others right edge
                if (other.right - this.right <= this.left - other.left) {
                    overlapX = this.left - other.right;
                    // This left edge is closest to the others left edge
                }
                else {
                    overlapX = this.right - other.left;
                }
            }
            let overlapY = 0;
            // this is taller than other
            if (this.height - other.height >= 0) {
                // The bottom edge is closest to the others bottom edge
                if (this.bottom - other.bottom <= other.top - this.top) {
                    overlapY = other.top - this.bottom;
                }
                else {
                    overlapY = other.bottom - this.top;
                }
                // other is taller than this
            }
            else {
                // The bottom edge is closest to the others bottom edge
                if (other.bottom - this.bottom <= this.top - other.top) {
                    overlapY = this.top - other.bottom;
                }
                else {
                    overlapY = this.bottom - other.top;
                }
            }
            if (Math.abs(overlapX) < Math.abs(overlapY)) {
                return new Vector(overlapX, 0);
            }
            else {
                return new Vector(0, overlapY);
            }
        }
        else {
            return null;
        }
    }
    /**
     * Test whether the bounding box has intersected with another bounding box, returns the side of the current bb that intersected.
     * @param bb The other actor to test
     */
    intersectWithSide(bb) {
        const intersect = this.intersect(bb);
        return BoundingBox.getSideFromIntersection(intersect);
    }
    /* istanbul ignore next */
    debugDraw(ctx, color = Color.Yellow) {
        ctx.strokeStyle = color.toString();
        ctx.strokeRect(this.left, this.top, this.width, this.height);
    }
    /**
     * Draw a debug bounding box
     * @param ex
     * @param color
     */
    draw(ex, color = Color.Yellow) {
        ex.debug.drawRect(this.left, this.top, this.width, this.height, { color });
    }
}

;// CONCATENATED MODULE: ./Math/matrix.ts



var MatrixLocations;
(function (MatrixLocations) {
    MatrixLocations[MatrixLocations["X"] = 12] = "X";
    MatrixLocations[MatrixLocations["Y"] = 13] = "Y";
})(MatrixLocations || (MatrixLocations = {}));
const sign = (val) => {
    if (val === 0) {
        return 0;
    }
    return val < 0 ? -1 : 1;
};
// const multMatch = (a: number, b: number) => {
//   if (sign(a) < 0 && sign(b) < 0) {
//     return -Math.abs(a * b);
//   }
//   return a * b;
// }
// const epsilon = (val: number) => {
//   if (val * val < .0001) {
//     return 0;
//   }
//   return val;
// }
/**
 * Excalibur Matrix helper for 4x4 matrices
 *
 * Useful for webgl 4x4 matrices
 */
class Matrix {
    constructor() {
        /**
         *  4x4 matrix in column major order
         *
         * |         |         |          |          |
         * | ------- | ------- | -------- |          |
         * | data[0] | data[4] | data[8]  | data[12] |
         * | data[1] | data[5] | data[9]  | data[13] |
         * | data[2] | data[6] | data[10] | data[14] |
         * | data[3] | data[7] | data[11] | data[15] |
         *
         */
        this.data = new Float32Array(16);
        this._scaleSignX = 1;
        this._scaleSignY = 1;
    }
    /**
     * Creates an orthographic (flat non-perspective) projection
     * https://en.wikipedia.org/wiki/Orthographic_projection
     * @param left
     * @param right
     * @param bottom
     * @param top
     * @param near
     * @param far
     */
    static ortho(left, right, bottom, top, near, far) {
        const mat = new Matrix();
        mat.data[0] = 2 / (right - left);
        mat.data[1] = 0;
        mat.data[2] = 0;
        mat.data[3] = 0;
        mat.data[4] = 0;
        mat.data[5] = 2 / (top - bottom);
        mat.data[6] = 0;
        mat.data[7] = 0;
        mat.data[8] = 0;
        mat.data[9] = 0;
        mat.data[10] = -2 / (far - near);
        mat.data[11] = 0;
        mat.data[12] = -(right + left) / (right - left);
        mat.data[13] = -(top + bottom) / (top - bottom);
        mat.data[14] = -(far + near) / (far - near);
        mat.data[15] = 1;
        return mat;
    }
    /**
     * Creates a new Matrix with the same data as the current 4x4
     */
    clone() {
        const mat = new Matrix();
        mat.data[0] = this.data[0];
        mat.data[1] = this.data[1];
        mat.data[2] = this.data[2];
        mat.data[3] = this.data[3];
        mat.data[4] = this.data[4];
        mat.data[5] = this.data[5];
        mat.data[6] = this.data[6];
        mat.data[7] = this.data[7];
        mat.data[8] = this.data[8];
        mat.data[9] = this.data[9];
        mat.data[10] = this.data[10];
        mat.data[11] = this.data[11];
        mat.data[12] = this.data[12];
        mat.data[13] = this.data[13];
        mat.data[14] = this.data[14];
        mat.data[15] = this.data[15];
        return mat;
    }
    /**
     * Creates a new identity matrix (a matrix that when applied does nothing)
     */
    static identity() {
        const mat = new Matrix();
        mat.data[0] = 1;
        mat.data[1] = 0;
        mat.data[2] = 0;
        mat.data[3] = 0;
        mat.data[4] = 0;
        mat.data[5] = 1;
        mat.data[6] = 0;
        mat.data[7] = 0;
        mat.data[8] = 0;
        mat.data[9] = 0;
        mat.data[10] = 1;
        mat.data[11] = 0;
        mat.data[12] = 0;
        mat.data[13] = 0;
        mat.data[14] = 0;
        mat.data[15] = 1;
        return mat;
    }
    /**
     * Creates a brand new translation matrix at the specified 3d point
     * @param x
     * @param y
     */
    static translation(x, y) {
        const mat = Matrix.identity();
        mat.data[12] = x;
        mat.data[13] = y;
        return mat;
    }
    /**
     * Creates a brand new scaling matrix with the specified scaling factor
     * @param sx
     * @param sy
     */
    static scale(sx, sy) {
        const mat = Matrix.identity();
        mat.data[0] = sx;
        mat.data[5] = sy;
        mat.data[10] = 1;
        mat.data[15] = 1;
        return mat;
    }
    /**
     * Creates a brand new rotation matrix with the specified angle
     * @param angleRadians
     */
    static rotation(angleRadians) {
        const mat = Matrix.identity();
        mat.data[0] = Math.cos(angleRadians);
        mat.data[4] = -Math.sin(angleRadians);
        mat.data[1] = Math.sin(angleRadians);
        mat.data[5] = Math.cos(angleRadians);
        return mat;
    }
    multv(other) {
        const z = 0;
        if (other instanceof Vector) {
            return new Vector(other.x * this.data[0] + other.y * this.data[4] + z * this.data[6] + 1 * this.data[12], other.x * this.data[1] + other.y * this.data[5] + z * this.data[9] + 1 * this.data[13]);
        }
        else {
            const dest = [
                other[0] * this.data[0] + other[1] * this.data[4] + z * this.data[6] + 1 * this.data[12],
                other[0] * this.data[1] + other[1] * this.data[5] + z * this.data[9] + 1 * this.data[13]
            ];
            return dest;
        }
    }
    /**
     * Multiplies the current matrix by another and returns the resulting matrix
     * @param other
     */
    multm(other) {
        const dest = new Matrix();
        const a11 = this.data[0];
        const a21 = this.data[1];
        const a31 = this.data[2];
        const a41 = this.data[3];
        const a12 = this.data[4];
        const a22 = this.data[5];
        const a32 = this.data[6];
        const a42 = this.data[7];
        const a13 = this.data[8];
        const a23 = this.data[9];
        const a33 = this.data[10];
        const a43 = this.data[11];
        const a14 = this.data[12];
        const a24 = this.data[13];
        const a34 = this.data[14];
        const a44 = this.data[15];
        const b11 = other.data[0];
        const b21 = other.data[1];
        const b31 = other.data[2];
        const b41 = other.data[3];
        const b12 = other.data[4];
        const b22 = other.data[5];
        const b32 = other.data[6];
        const b42 = other.data[7];
        const b13 = other.data[8];
        const b23 = other.data[9];
        const b33 = other.data[10];
        const b43 = other.data[11];
        const b14 = other.data[12];
        const b24 = other.data[13];
        const b34 = other.data[14];
        const b44 = other.data[15];
        dest.data[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        dest.data[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        dest.data[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        dest.data[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        dest.data[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        dest.data[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        dest.data[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        dest.data[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        dest.data[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        dest.data[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        dest.data[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        dest.data[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        dest.data[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        dest.data[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        dest.data[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        dest.data[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        const s = this.getScale();
        dest._scaleSignX = sign(s.x) * sign(dest._scaleSignX);
        dest._scaleSignY = sign(s.y) * sign(dest._scaleSignY);
        return dest;
    }
    /**
     * Applies translation to the current matrix mutating it
     * @param x
     * @param y
     */
    translate(x, y) {
        const a11 = this.data[0];
        const a21 = this.data[1];
        const a31 = this.data[2];
        const a41 = this.data[3];
        const a12 = this.data[4];
        const a22 = this.data[5];
        const a32 = this.data[6];
        const a42 = this.data[7];
        const a13 = this.data[8];
        const a23 = this.data[9];
        const a33 = this.data[10];
        const a43 = this.data[11];
        const a14 = this.data[12];
        const a24 = this.data[13];
        const a34 = this.data[14];
        const a44 = this.data[15];
        // Doesn't change z
        const z = 0;
        const w = 1;
        this.data[12] = a11 * x + a12 * y + a13 * z + a14 * w;
        this.data[13] = a21 * x + a22 * y + a23 * z + a24 * w;
        this.data[14] = a31 * x + a32 * y + a33 * z + a34 * w;
        this.data[15] = a41 * x + a42 * y + a43 * z + a44 * w;
        return this;
    }
    setPosition(x, y) {
        this.data[12] = x;
        this.data[13] = y;
    }
    getPosition() {
        return vec(this.data[12], this.data[13]);
    }
    /**
     * Applies rotation to the current matrix mutating it
     * @param angle in Radians
     */
    rotate(angle) {
        const a11 = this.data[0];
        const a21 = this.data[1];
        const a31 = this.data[2];
        const a41 = this.data[3];
        const a12 = this.data[4];
        const a22 = this.data[5];
        const a32 = this.data[6];
        const a42 = this.data[7];
        const sine = Math.sin(angle);
        const cosine = Math.cos(angle);
        this.data[0] = cosine * a11 + sine * a12;
        this.data[1] = cosine * a21 + sine * a22;
        this.data[2] = cosine * a31 + sine * a32;
        this.data[3] = cosine * a41 + sine * a42;
        this.data[4] = cosine * a12 - sine * a11;
        this.data[5] = cosine * a22 - sine * a21;
        this.data[6] = cosine * a32 - sine * a31;
        this.data[7] = cosine * a42 - sine * a41;
        return this;
    }
    /**
     * Applies scaling to the current matrix mutating it
     * @param x
     * @param y
     */
    scale(x, y) {
        const a11 = this.data[0];
        const a21 = this.data[1];
        const a31 = this.data[2];
        const a41 = this.data[3];
        const a12 = this.data[4];
        const a22 = this.data[5];
        const a32 = this.data[6];
        const a42 = this.data[7];
        this.data[0] = a11 * x;
        this.data[1] = a21 * x;
        this.data[2] = a31 * x;
        this.data[3] = a41 * x;
        this.data[4] = a12 * y;
        this.data[5] = a22 * y;
        this.data[6] = a32 * y;
        this.data[7] = a42 * y;
        return this;
    }
    setRotation(angle) {
        const currentScale = this.getScale();
        const sine = Math.sin(angle);
        const cosine = Math.cos(angle);
        this.data[0] = cosine * currentScale.x;
        this.data[1] = sine * currentScale.y;
        this.data[4] = -sine * currentScale.x;
        this.data[5] = cosine * currentScale.y;
    }
    getRotation() {
        const angle = Math.atan2(this.data[1] / this.getScaleY(), this.data[0] / this.getScaleX());
        return canonicalizeAngle(angle);
    }
    getScaleX() {
        // absolute scale of the matrix (we lose sign so need to add it back)
        const xscale = vec(this.data[0], this.data[4]).size;
        return this._scaleSignX * xscale;
    }
    getScaleY() {
        // absolute scale of the matrix (we lose sign so need to add it back)
        const yscale = vec(this.data[1], this.data[5]).size;
        return this._scaleSignY * yscale;
    }
    /**
     * Get the scale of the matrix
     */
    getScale() {
        return vec(this.getScaleX(), this.getScaleY());
    }
    setScaleX(val) {
        this._scaleSignX = sign(val);
        // negative scale acts like a 180 rotation, so flip
        const xscale = vec(this.data[0] * this._scaleSignX, this.data[4] * this._scaleSignX).normalize();
        this.data[0] = xscale.x * val;
        this.data[4] = xscale.y * val;
    }
    setScaleY(val) {
        this._scaleSignY = sign(val);
        // negative scale acts like a 180 rotation, so flip
        const yscale = vec(this.data[1] * this._scaleSignY, this.data[5] * this._scaleSignY).normalize();
        this.data[1] = yscale.x * val;
        this.data[5] = yscale.y * val;
    }
    setScale(scale) {
        this.setScaleX(scale.x);
        this.setScaleY(scale.y);
    }
    /**
     * Determinant of the upper left 2x2 matrix
     */
    getBasisDeterminant() {
        return this.data[0] * this.data[5] - this.data[1] * this.data[4];
    }
    getAffineInverse() {
        // See http://negativeprobability.blogspot.com/2011/11/affine-transformations-and-their.html
        // See https://www.mathsisfun.com/algebra/matrix-inverse.html
        // Since we are actually only doing 2D transformations we can use this hack
        // We don't actually use the 3rd or 4th dimension
        const det = this.getBasisDeterminant();
        const inverseDet = 1 / det; // todo zero check
        const a = this.data[0];
        const b = this.data[4];
        const c = this.data[1];
        const d = this.data[5];
        const m = Matrix.identity();
        // inverts rotation and scale
        m.data[0] = d * inverseDet;
        m.data[1] = -c * inverseDet;
        m.data[4] = -b * inverseDet;
        m.data[5] = a * inverseDet;
        const tx = this.data[12];
        const ty = this.data[13];
        // invert translation
        // transform translation into the matrix basis created by rot/scale
        m.data[12] = -(tx * m.data[0] + ty * m.data[4]);
        m.data[13] = -(tx * m.data[1] + ty * m.data[5]);
        return m;
    }
    isIdentity() {
        return (this.data[0] === 1 &&
            this.data[1] === 0 &&
            this.data[2] === 0 &&
            this.data[3] === 0 &&
            this.data[4] === 0 &&
            this.data[5] === 1 &&
            this.data[6] === 0 &&
            this.data[7] === 0 &&
            this.data[8] === 0 &&
            this.data[9] === 0 &&
            this.data[10] === 1 &&
            this.data[11] === 0 &&
            this.data[12] === 0 &&
            this.data[13] === 0 &&
            this.data[14] === 0 &&
            this.data[15] === 1);
    }
    toString() {
        return `
[${this.data[0]} ${this.data[4]} ${this.data[8]} ${this.data[12]}]
[${this.data[1]} ${this.data[5]} ${this.data[9]} ${this.data[13]}]
[${this.data[2]} ${this.data[6]} ${this.data[10]} ${this.data[14]}]
[${this.data[3]} ${this.data[7]} ${this.data[11]} ${this.data[15]}]
`;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/transform-stack.ts

class TransformStack {
    constructor() {
        this._transforms = [];
        this._currentTransform = Matrix.identity();
    }
    save() {
        this._transforms.push(this._currentTransform);
        this._currentTransform = this._currentTransform.clone();
    }
    restore() {
        this._currentTransform = this._transforms.pop();
    }
    translate(x, y) {
        return this._currentTransform.translate(x, y);
    }
    rotate(angle) {
        return this._currentTransform.rotate(angle);
    }
    scale(x, y) {
        return this._currentTransform.scale(x, y);
    }
    set current(matrix) {
        this._currentTransform = matrix;
    }
    get current() {
        return this._currentTransform;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/state-stack.ts
class StateStack {
    constructor() {
        this._states = [];
        this._currentState = this._getDefaultState();
    }
    _getDefaultState() {
        return {
            opacity: 1
        };
    }
    _cloneState() {
        return {
            opacity: this._currentState.opacity
        };
    }
    save() {
        this._states.push(this._currentState);
        this._currentState = this._cloneState();
    }
    restore() {
        this._currentState = this._states.pop();
    }
    get current() {
        return this._currentState;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/shader.ts
/**
 * Create a shader program for the Excalibur WebGL Graphics Context
 */
class Shader {
    /**
     * Create a shader program in excalibur
     * @param _gl WebGL graphics context
     * @param _vertexSource Vertex shader source as a string
     * @param _fragmentSource Fragment shader source as a string
     */
    constructor(_gl, _vertexSource, _fragmentSource) {
        this._gl = _gl;
        this._vertexSource = _vertexSource;
        this._fragmentSource = _fragmentSource;
        this.program = null;
        this.uniforms = {};
        this.attributes = {};
        this.layout = [];
        this.compile(_gl);
    }
    _createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram();
        if (program === null) {
            throw Error('Could not create graphics shader program');
        }
        // attach the shaders.
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        // link the program.
        gl.linkProgram(program);
        const success = gl.getProgramParameter(program, gl.LINK_STATUS);
        if (!success) {
            throw Error(`Could not link the program: [${gl.getProgramInfoLog(program)}]`);
        }
        return program;
    }
    _compileShader(gl, source, type) {
        const shader = gl.createShader(type);
        if (shader === null) {
            throw Error(`Could not build shader: [${source}]`);
        }
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        if (!success) {
            throw Error(`Could not compile shader [${gl.getShaderInfoLog(shader)}]`);
        }
        return shader;
    }
    /**
     * Compile the current shader against a webgl context
     * @param gl WebGL context
     */
    compile(gl) {
        const vertexShader = this._compileShader(gl, this._vertexSource, gl.VERTEX_SHADER);
        const fragmentShader = this._compileShader(gl, this._fragmentSource, gl.FRAGMENT_SHADER);
        const program = this._createProgram(gl, vertexShader, fragmentShader);
        return (this.program = program);
    }
    /**
     * Add a uniform [[Matrix]] to the shader
     * @param name Name of the uniform in the shader source
     * @param data (4x4) matrix in column major order
     */
    addUniformMatrix(name, data) {
        if (!data) {
            throw Error(`Shader Uniform Matrix '${name}' was set to null or undefined`);
        }
        const gl = this._gl;
        this.uniforms[name] = {
            name,
            type: 'matrix',
            location: gl.getUniformLocation(this.program, name),
            data: data
        };
    }
    /**
     * Add a uniform array of numbers to the shader
     * @param name Name of the uniform in the shader source
     * @param data List of numbers
     */
    addUniformIntegerArray(name, data) {
        if (!data) {
            throw Error(`Shader Uniform Integery Array '${name}' was set to null or undefined`);
        }
        const gl = this._gl;
        this.uniforms[name] = {
            name,
            type: 'numbers',
            location: gl.getUniformLocation(this.program, name),
            data: data
        };
    }
    /**
     * Add attributes in the order they appear in the VBO
     * @param name Name of the attribute in the shader source
     * @param size The size of the attribute in gl.Type units, for example `vec2 a_pos` would be 2 gl.FLOAT
     * @param glType The gl.Type of the attribute
     */
    addAttribute(name, size, glType, normalized = false) {
        const gl = this._gl;
        // TODO needs to be compiled first
        const location = gl.getAttribLocation(this.program, name);
        this.attributes[name] = {
            name,
            size,
            glType,
            normalized,
            location
        };
        this.layout.push(this.attributes[name]);
    }
    /**
     * Number of javascript floats a vertex will take up
     */
    get vertexAttributeSize() {
        let vertexSize = 0;
        for (const vert of this.layout) {
            vertexSize += vert.size;
        }
        return vertexSize;
    }
    /**
     * Total number of bytes that the vertex will take up
     */
    get totalVertexSizeBytes() {
        let vertexSize = 0;
        for (const vert of this.layout) {
            let typeSize = 1;
            switch (vert.glType) {
                case this._gl.FLOAT: {
                    typeSize = 4;
                    break;
                }
                default: {
                    typeSize = 1;
                }
            }
            vertexSize += typeSize * vert.size;
        }
        return vertexSize;
    }
    /**
     * Get a previously defined attribute size in bytes
     * @param name
     */
    getAttributeSize(name) {
        let typeSize = 1;
        switch (this.attributes[name].glType) {
            case this._gl.FLOAT: {
                typeSize = 4;
                break;
            }
            default: {
                typeSize = 1;
            }
        }
        return typeSize * this.attributes[name].size;
    }
    /**
     * Sets this shader program as the current in the underlying webgl context
     *
     * **Must** specify all attributes and uniforms before calling this
     */
    use() {
        const gl = this._gl;
        gl.useProgram(this.program);
        let offset = 0;
        for (const vert of this.layout) {
            gl.vertexAttribPointer(vert.location, vert.size, vert.glType, vert.normalized, this.totalVertexSizeBytes, offset);
            gl.enableVertexAttribArray(vert.location);
            offset += this.getAttributeSize(vert.name);
        }
        for (const key in this.uniforms) {
            const uniform = this.uniforms[key];
            switch (uniform.type) {
                case 'matrix': {
                    gl.uniformMatrix4fv(uniform.location, false, uniform.data);
                    break;
                }
                case 'numbers': {
                    gl.uniform1iv(uniform.location, uniform.data);
                    break;
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/shaders/line-vertex.glsl
/* harmony default export */ const line_vertex = ("attribute vec4 a_position;\r\nattribute vec4 a_color;\r\n\r\nvarying lowp vec4 v_color;\r\n\r\nuniform mat4 u_matrix;\r\n\r\n\r\nvoid main() {\r\n   // Set the vertex position using the ortho transform matrix\r\n   gl_Position = u_matrix * a_position;\r\n\r\n   // Passthrough the color\r\n   v_color = a_color;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/shaders/line-fragment.glsl
/* harmony default export */ const line_fragment = ("precision mediump float;\r\n\r\n// Color\r\nvarying lowp vec4 v_color;\r\n\r\n\r\nvoid main() {\r\n  gl_FragColor = v_color;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/batch.ts
class BatchCommand {
    constructor(max) {
        this.max = max;
        this._pool = undefined;
        this.commands = [];
    }
    isFull() {
        if (this.commands.length >= this.max) {
            return true;
        }
        return false;
    }
    canAdd() {
        return !this.isFull();
    }
    add(cmd) {
        this.commands.push(cmd);
    }
    dispose() {
        this.commands.length = 0;
        return this;
    }
}

;// CONCATENATED MODULE: ./Graphics/GraphicsDiagnostics.ts
class GraphicsDiagnostics {
    static clear() {
        GraphicsDiagnostics.DrawCallCount = 0;
        GraphicsDiagnostics.DrawnImagesCount = 0;
    }
}
GraphicsDiagnostics.DrawCallCount = 0;
GraphicsDiagnostics.DrawnImagesCount = 0;

;// CONCATENATED MODULE: ./Util/Pool.ts

class Pool {
    constructor(builder, recycler, maxObjects = 100) {
        this.builder = builder;
        this.recycler = recycler;
        this.maxObjects = maxObjects;
        this.totalAllocations = 0;
        this.index = 0;
        this.objects = [];
        this._logger = Logger.getInstance();
    }
    /**
     * Use many instances out of the in the context and return all to the pool.
     *
     * By returning values out of the contex they will be un-hooked from the pool and are free to be passed to consumers
     * @param context
     */
    using(context) {
        const result = context(this);
        if (result) {
            return this.done(...result);
        }
        return this.done();
    }
    /**
     * Use a single instance out of th pool and immediately return it to the pool
     * @param context
     */
    borrow(context) {
        const object = this.get();
        context(object);
        this.index--;
    }
    /**
     * Retrieve a value from the pool, will allocate a new instance if necessary or recycle from the pool
     * @param args
     */
    get(...args) {
        if (this.index === this.maxObjects) {
            // TODO implement hard or soft cap
            this._logger.warn('Max pooled objects reached, possible memory leak? Doubling');
            this.maxObjects = this.maxObjects * 2;
            // throw new Error('Max pooled objects reached, possible memory leak?');
        }
        if (this.objects[this.index]) {
            // Pool has an available object already constructed
            return this.recycler(this.objects[this.index++], ...args);
        }
        else {
            // New allocation
            this.totalAllocations++;
            const object = (this.objects[this.index++] = this.builder(...args));
            object._pool = this;
            return object;
        }
    }
    done(...objects) {
        // All objects in pool now considered "free"
        this.index = 0;
        for (const object of objects) {
            const poolIndex = this.objects.indexOf(object);
            // Build a new object to take the pool place
            this.objects[poolIndex] = this.builder(); // TODO problematic 0-arg only support
            this.objects[poolIndex]._pool = this;
            this.totalAllocations++;
            // Unhook object from the pool
            object._pool = undefined;
        }
        return objects;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/renderer.ts

// import { Pool, Poolable } from './pool';


class BatchRenderer {
    constructor(options) {
        var _a, _b, _c;
        this.priority = 0;
        this._buffer = null;
        this._maxCommandsPerBatch = 2000;
        this._batches = [];
        this._gl = options.gl;
        const command = options.command;
        this._verticesPerCommand = (_a = options === null || options === void 0 ? void 0 : options.verticesPerCommand) !== null && _a !== void 0 ? _a : 1;
        this._maxCommandsPerBatch = (_b = options === null || options === void 0 ? void 0 : options.maxCommandsPerBatch) !== null && _b !== void 0 ? _b : this._maxCommandsPerBatch;
        const batchFactory = (_c = options === null || options === void 0 ? void 0 : options.batchFactory) !== null && _c !== void 0 ? _c : (() => new BatchCommand(this._maxCommandsPerBatch));
        this.commands = new Pool(() => new command(), (c) => c.dispose(), this._maxCommandsPerBatch);
        this._batchPool = new Pool(batchFactory, (b) => b.dispose(), 100);
    }
    /**
     * Initialize render, builds shader and initialized webgl buffers
     */
    init() {
        const gl = this._gl;
        this.shader = this.buildShader(gl);
        // Initialize VBO
        // https://groups.google.com/forum/#!topic/webgl-dev-list/vMNXSNRAg8M
        this._vertices = new Float32Array(this.shader.vertexAttributeSize * this._verticesPerCommand * this._maxCommandsPerBatch);
        this._buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._buffer);
        gl.bufferData(gl.ARRAY_BUFFER, this._vertices, gl.DYNAMIC_DRAW);
    }
    get vertexSize() {
        return this.shader.vertexAttributeSize;
    }
    addCommand(cmd) {
        if (this._batches.length === 0) {
            this._batches.push(this._batchPool.get());
        }
        const lastBatch = this._batches[this._batches.length - 1];
        if (lastBatch.canAdd()) {
            lastBatch.add(cmd);
        }
        else {
            const newBatch = this._batchPool.get();
            newBatch.add(cmd);
            this._batches.push(newBatch);
        }
    }
    /**
     * Build batch geometry, submit to the gpu, and issue draw command to underlying webgl
     */
    render() {
        const gl = this._gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, this._buffer);
        this.shader.use();
        let drawCallCount = 0;
        let drawnImagesCount = 0;
        for (const batch of this._batches) {
            // Build all geometry and ship to GPU
            // interleave VBOs https://goharsha.com/lwjgl-tutorial-series/interleaving-buffer-objects/
            const vertexCount = this.buildBatchVertices(this._vertices, batch);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._vertices);
            this.renderBatch(gl, batch, vertexCount);
            drawnImagesCount += batch.commands.length;
            drawCallCount++;
        }
        this.commands.done();
        this._batchPool.done();
        this._batches.length = 0;
        GraphicsDiagnostics.DrawCallCount += drawCallCount;
        GraphicsDiagnostics.DrawnImagesCount += drawnImagesCount;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/line-renderer.ts






class DrawLine {
    constructor() {
        this.color = Color.Black;
        this.start = Vector.Zero;
        this.end = Vector.Zero;
    }
    dispose() {
        this.color.r = 0;
        this.color.g = 0;
        this.color.b = 0;
        this.color.a = 1;
        this.start.setTo(0, 0);
        this.end.setTo(0, 0);
        return this;
    }
}
class LineRenderer extends BatchRenderer {
    constructor(gl, _contextInfo) {
        super({ gl, command: DrawLine, verticesPerCommand: 2 });
        this._contextInfo = _contextInfo;
        this.init();
    }
    buildShader(gl) {
        const shader = new Shader(gl, line_vertex, line_fragment);
        shader.addAttribute('a_position', 2, gl.FLOAT);
        shader.addAttribute('a_color', 4, gl.FLOAT);
        shader.addUniformMatrix('u_matrix', this._contextInfo.matrix.data);
        return shader;
    }
    addLine(start, end, color) {
        const cmd = this.commands.get();
        cmd.start = this._contextInfo.transform.current.multv(start);
        cmd.end = this._contextInfo.transform.current.multv(end);
        cmd.color.r = color.r;
        cmd.color.g = color.g;
        cmd.color.b = color.b;
        cmd.color.a = cmd.color.a * this._contextInfo.state.current.opacity;
        this.addCommand(cmd);
    }
    buildBatchVertices(vertexBuffer, batch) {
        let index = 0;
        for (const command of batch.commands) {
            // Start
            vertexBuffer[index++] = command.start.x;
            vertexBuffer[index++] = command.start.y;
            vertexBuffer[index++] = command.color.r / 255;
            vertexBuffer[index++] = command.color.g / 255;
            vertexBuffer[index++] = command.color.b / 255;
            vertexBuffer[index++] = command.color.a;
            // End
            vertexBuffer[index++] = command.end.x;
            vertexBuffer[index++] = command.end.y;
            vertexBuffer[index++] = command.color.r / 255;
            vertexBuffer[index++] = command.color.g / 255;
            vertexBuffer[index++] = command.color.b / 255;
            vertexBuffer[index++] = command.color.a;
        }
        return index / this.vertexSize;
    }
    renderBatch(gl, _batch, vertexCount) {
        gl.drawArrays(gl.LINES, 0, vertexCount);
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/shaders/image-vertex.glsl
/* harmony default export */ const image_vertex = ("attribute vec4 a_position;\r\n\r\n// Opacity \r\nattribute float a_opacity;\r\nvarying float v_opacity;\r\n\r\nattribute vec4 a_color;\r\nvarying vec4 v_color;\r\n\r\n// UV coordinate\r\nattribute vec2 a_texcoord;\r\nvarying vec2 v_texcoord;\r\n\r\n// Texture number\r\nattribute lowp float a_textureIndex;\r\nvarying lowp float v_textureIndex;\r\n\r\nuniform mat4 u_matrix;\r\n\r\n\r\nvoid main() {\r\n   // Set the vertex position using the ortho transform matrix\r\n   gl_Position = u_matrix * a_position;\r\n\r\n   // Pass through the Opacity to the fragment shader\r\n   v_opacity = a_opacity;\r\n   // Pass through the UV coord to the fragment shader\r\n   v_texcoord = a_texcoord;\r\n   // Pass through the texture number to the fragment shader\r\n   v_textureIndex = a_textureIndex;\r\n   // Pass through the color to the fragment shader\r\n   v_color = a_color;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/shaders/image-fragment.glsl
/* harmony default export */ const image_fragment = ("#ifdef GL_OES_standard_derivatives\r\n#extension GL_OES_standard_derivatives : enable\r\n#endif\r\nprecision mediump float;\r\n\r\n// UV coord\r\nvarying vec2 v_texcoord;\r\n\r\n// Texture index\r\nvarying lowp float v_textureIndex;\r\n\r\n// Color coord to blend with image\r\nvarying lowp vec4 v_color;\r\n\r\n// Opacity\r\nvarying float v_opacity;\r\n\r\nuniform sampler2D u_textures[%%count%%];\r\n\r\nfloat circle(in vec2 st, in float radius) {\r\n  vec2 dist = st - vec2(0.5);\r\n  float r = dot(dist, dist) * 4.0;\r\n  float delta = fwidth(r);\r\n  return 1.0 - smoothstep(radius - delta, radius + delta, r);\r\n}\r\n\r\nvoid main() {\r\n  float r = 0.0, delta = 0.0, alpha = 1.0;\r\n   // In order to support the most efficient sprite batching, we have multiple\r\n   // textures loaded into the gpu (usually 8) this picker logic skips over textures\r\n   // that do not apply to a particular sprite.\r\n\r\n   vec4 color;\r\n   // -1 If there is no texture to sample we are drawing a solid geometry (rectangles)\r\n   if (v_textureIndex == -1.0) {\r\n     color = v_color;\r\n     color.w = color.w * v_opacity;\r\n   // -2 If there is no texture we are drawing a circle\r\n   } else if (v_textureIndex == -2.0) {\r\n     color = v_color;\r\n     color.a = color.a * circle(v_texcoord, .95);\r\n   } else {\r\n     // GLSL is templated out to pick the right texture and set the vec4 color\r\n      %%texture_picker%%\r\n   }\r\n   color.w = color.w * v_opacity;\r\n   gl_FragColor = color;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/draw-image-command.ts

var DrawCommandType;
(function (DrawCommandType) {
    DrawCommandType["Image"] = "image";
    DrawCommandType["Line"] = "line";
    DrawCommandType["Rectangle"] = "rectangle";
    DrawCommandType["Circle"] = "circle";
})(DrawCommandType || (DrawCommandType = {}));
class DrawImageCommand {
    constructor(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
        this._pool = undefined;
        this.snapToPixel = true;
        this.type = DrawCommandType.Image;
        this.opacity = 1;
        this.width = 0;
        this.height = 0;
        this.dest = [0, 0]; // x, y
        this.view = [0, 0, 0, 0]; // sx, sy, sw, sh
        this._geom = [
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0]
        ];
        this.init(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight);
    }
    init(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
        this.type = DrawCommandType.Image;
        this.image = image;
        this.width = (image === null || image === void 0 ? void 0 : image.width) || swidth || 0;
        this.height = (image === null || image === void 0 ? void 0 : image.height) || sheight || 0;
        this.view = [0, 0, swidth !== null && swidth !== void 0 ? swidth : image === null || image === void 0 ? void 0 : image.width, sheight !== null && sheight !== void 0 ? sheight : image === null || image === void 0 ? void 0 : image.height];
        this.dest = [sx, sy];
        // If destination is specified, update view and dest
        if (dx !== undefined && dy !== undefined && dwidth !== undefined && dheight !== undefined) {
            this.view = [sx, sy, swidth !== null && swidth !== void 0 ? swidth : image === null || image === void 0 ? void 0 : image.width, sheight !== null && sheight !== void 0 ? sheight : image === null || image === void 0 ? void 0 : image.height];
            this.dest = [dx, dy];
            this.width = dwidth;
            this.height = dheight;
        }
        let index = 0;
        this._geom[index++] = [this.dest[0], this.dest[1]];
        this._geom[index++] = [this.dest[0], this.dest[1] + this.height];
        this._geom[index++] = [this.dest[0] + this.width, this.dest[1]];
        this._geom[index++] = [this.dest[0] + this.width, this.dest[1]];
        this._geom[index++] = [this.dest[0], this.dest[1] + this.height];
        this._geom[index++] = [this.dest[0] + this.width, this.dest[1] + this.height];
        if (this.snapToPixel) {
            for (const point of this._geom) {
                point[0] = ~~point[0];
                point[1] = ~~point[1];
            }
        }
        return this;
    }
    initRect(color, start, width, height) {
        this.type = DrawCommandType.Rectangle;
        this.color = color;
        this.width = width;
        this.height = height;
        let index = 0;
        this._geom[index++] = [start.x, start.y];
        this._geom[index++] = [start.x, start.y + this.height];
        this._geom[index++] = [start.x + this.width, start.y];
        this._geom[index++] = [start.x + this.width, start.y];
        this._geom[index++] = [start.x, start.y + this.height];
        this._geom[index++] = [start.x + this.width, start.y + this.height];
        if (this.snapToPixel) {
            for (const point of this._geom) {
                point[0] = ~~point[0];
                point[1] = ~~point[1];
            }
        }
        return this;
    }
    initLine(color, start, end, thickness) {
        this.type = DrawCommandType.Line;
        this.color = color;
        const dir = end.sub(start).normalize();
        const normal = dir.perpendicular();
        const halfThick = thickness / 2;
        const startTop = normal.scale(halfThick).add(start);
        const startBottom = normal.scale(-halfThick).add(start);
        const endTop = normal.scale(halfThick).add(end);
        const endBottom = normal.scale(-halfThick).add(end);
        /**
         *    +---------------------^----------------------+
         *    |                     | (normal)             |
         *   (startx, starty)------------------>(endx, endy)
         *    |                                            |
         *    + -------------------------------------------+
         */
        let index = 0;
        this._geom[index++] = [startTop.x, startTop.y];
        this._geom[index++] = [endTop.x, endTop.y];
        this._geom[index++] = [startBottom.x, startBottom.y];
        this._geom[index++] = [startBottom.x, startBottom.y];
        this._geom[index++] = [endTop.x, endTop.y];
        this._geom[index++] = [endBottom.x, endBottom.y];
        if (this.snapToPixel) {
            for (const point of this._geom) {
                point[0] = ~~point[0];
                point[1] = ~~point[1];
            }
        }
        return this;
    }
    initCircle(pos, radius, color) {
        this.type = DrawCommandType.Circle;
        this.color = color;
        const topLeft = pos.add(vec(-radius, -radius));
        const topRight = pos.add(vec(radius, -radius));
        const bottomRight = pos.add(vec(radius, radius));
        const bottomLeft = pos.add(vec(-radius, radius));
        let index = 0;
        this._geom[index++] = [topLeft.x, topLeft.y];
        this._geom[index++] = [topRight.x, topRight.y];
        this._geom[index++] = [bottomLeft.x, bottomLeft.y];
        this._geom[index++] = [bottomLeft.x, bottomLeft.y];
        this._geom[index++] = [topRight.x, topRight.y];
        this._geom[index++] = [bottomRight.x, bottomRight.y];
        if (this.snapToPixel) {
            for (const point of this._geom) {
                point[0] = ~~point[0];
                point[1] = ~~point[1];
            }
        }
        return this;
    }
    dispose() {
        this.image = null;
        this.width = 0;
        this.height = 0;
        this.view = [0, 0, 0, 0];
        this.dest = [0, 0];
        let index = 0;
        this._geom[index++] = [this.dest[0], this.dest[1]];
        this._geom[index++] = [this.dest[0], this.dest[1] + this.height];
        this._geom[index++] = [this.dest[0] + this.width, this.dest[1]];
        this._geom[index++] = [this.dest[0] + this.width, this.dest[1]];
        this._geom[index++] = [this.dest[0], this.dest[1] + this.height];
        this._geom[index++] = [this.dest[0] + this.width, this.dest[1] + this.height];
        return this;
    }
    // todo weird
    applyTransform(transform, opacity) {
        if (transform) {
            for (let i = 0; i < this._geom.length; i++) {
                this._geom[i] = transform.multv(this._geom[i]);
                if (this.snapToPixel) {
                    this._geom[i] = [~~this._geom[i][0], ~~this._geom[i][1]];
                }
            }
        }
        this.opacity = opacity;
    }
    get geometry() {
        return this._geom;
    }
}
class DrawRectCommand {
    constructor(x, y, width, height) {
        this.dest = [0, 0];
        this.width = 0;
        this.height = 0;
        this.dest = [x, y];
        this.width = width;
        this.height = height;
    }
}
class DrawDebugRectCommand {
    constructor(bounds, color) {
        this.bounds = bounds;
        this.color = color;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/webgl-util.ts
/**
 * Checks if the current number is a power of two
 */
function isPowerOfTwo(x) {
    return (x & (x - 1)) === 0;
}
/**
 * Returns the next highest power of two
 */
function nextHighestPowerOfTwo(x) {
    --x;
    for (let i = 1; i < 32; i <<= 1) {
        x = x | (x >> i);
    }
    return x + 1;
}
/**
 * Returns the input number if a power of two, otherwise the next highest power of two
 */
function ensurePowerOfTwo(x) {
    if (!isPowerOfTwo(x)) {
        return nextHighestPowerOfTwo(x);
    }
    return x;
}

;// CONCATENATED MODULE: ./Graphics/Context/texture-loader.ts

/**
 * Manages loading image sources into webgl textures, a unique id is associated with all sources
 */
class TextureLoader {
    static registerContext(context) {
        TextureLoader._GL = context;
    }
    /**
     * Get the WebGL Texture from a source image
     * @param image
     */
    static get(image) {
        return TextureLoader._TEXTURE_MAP.get(image);
    }
    /**
     * Returns whether a source image has been loaded as a texture
     * @param image
     */
    static has(image) {
        return TextureLoader._TEXTURE_MAP.has(image);
    }
    /**
     * Loads a graphic into webgl and returns it's texture info, a webgl context must be previously registered
     * @param image Source graphic
     * @param forceUpdate Optionally force a texture to be reloaded, useful if the source graphic has changed
     */
    static load(image, forceUpdate = false) {
        // Ignore loading if webgl is not registered
        const gl = TextureLoader._GL;
        if (!gl) {
            return null;
        }
        let tex = null;
        // If reuse the texture if it's from the same source
        if (TextureLoader.has(image)) {
            tex = TextureLoader.get(image);
        }
        // Update existing webgl texture and return early
        if (tex) {
            if (forceUpdate) {
                gl.bindTexture(gl.TEXTURE_2D, tex);
                const source = TextureLoader.toPowerOfTwoImage(image);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
            }
            return tex;
        }
        // No texture exists create a new one
        tex = gl.createTexture();
        const source = TextureLoader.toPowerOfTwoImage(image);
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        // NEAREST for pixels
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
        TextureLoader._TEXTURE_MAP.set(image, tex);
        return tex;
    }
    /**
     * Converts source images into power of two images, WebGL only supports POT images
     * https://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences#Non-Power_of_Two_Texture_Support
     * @param image
     */
    static toPowerOfTwoImage(image) {
        const potCanvas = TextureLoader._POT_CANVAS;
        const potCtx = TextureLoader._POT_CTX;
        if (!isPowerOfTwo(image.width) || !isPowerOfTwo(image.height)) {
            // Scale up the texture to the next highest power of two dimensions.
            potCanvas.width = ensurePowerOfTwo(image.width);
            potCanvas.height = ensurePowerOfTwo(image.height);
            potCtx.imageSmoothingEnabled = false;
            potCtx.clearRect(0, 0, potCanvas.width, potCanvas.height);
            potCtx.drawImage(image, 0, 0, image.width, image.height);
            image = potCanvas;
        }
        return image;
    }
}
TextureLoader._POT_CANVAS = document.createElement('canvas');
TextureLoader._POT_CTX = TextureLoader._POT_CANVAS.getContext('2d');
TextureLoader._TEXTURE_MAP = new Map();

;// CONCATENATED MODULE: ./Graphics/Context/image-renderer.ts









class BatchImage extends BatchCommand {
    constructor(maxDraws, maxTextures) {
        super(maxDraws);
        this.maxDraws = maxDraws;
        this.maxTextures = maxTextures;
        this.textures = [];
        this.commands = [];
        this._graphicMap = {};
    }
    isFull() {
        if (this.commands.length >= this.maxDraws) {
            return true;
        }
        if (this.textures.length >= this.maxTextures) {
            return true;
        }
        return false;
    }
    canAdd() {
        if (this.commands.length >= this.maxDraws) {
            return false;
        }
        if (this.textures.length < this.maxTextures) {
            return true;
        }
        return false;
    }
    _isCommandFull() {
        return this.commands.length >= this.maxDraws;
    }
    _isTextureFull() {
        return this.textures.length >= this.maxTextures;
    }
    _wouldAddTexture(command) {
        return !this._graphicMap[command.image.id];
    }
    maybeAdd(command) {
        if ((this._isCommandFull() || this._isTextureFull()) && this._wouldAddTexture(command)) {
            return false;
        }
        this.add(command);
        return true;
    }
    add(command) {
        if (command.type === DrawCommandType.Image) {
            const texture = TextureLoader.load(command.image);
            if (this.textures.indexOf(texture) === -1) {
                this.textures.push(texture);
            }
        }
        this.commands.push(command);
    }
    bindTextures(gl) {
        // Bind textures in the correct order
        for (let i = 0; i < this.maxTextures; i++) {
            gl.activeTexture(gl.TEXTURE0 + i);
            gl.bindTexture(gl.TEXTURE_2D, this.textures[i] || this.textures[0]);
        }
    }
    getBatchTextureId(command) {
        if (command.image) {
            return this.textures.indexOf(TextureLoader.get(command.image));
        }
        return -1;
    }
    dispose() {
        this.clear();
        return this;
    }
    clear() {
        this.commands.length = 0;
        this.textures.length = 0;
        this._graphicMap = {};
    }
}
class ImageRenderer extends BatchRenderer {
    constructor(gl, _contextInfo) {
        super({
            gl,
            command: DrawImageCommand,
            // 6 verts per quad
            verticesPerCommand: 6,
            maxCommandsPerBatch: 2000,
            batchFactory: () => new BatchImage(2000, gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS))
        });
        this._contextInfo = _contextInfo;
        TextureLoader.registerContext(gl);
        this.init();
    }
    buildShader(gl) {
        // Initialilze default batch rendering shader
        const maxGPUTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        const shader = new Shader(gl, image_vertex, this._transformFragmentSource(image_fragment, maxGPUTextures));
        shader.addAttribute('a_position', 3, gl.FLOAT);
        shader.addAttribute('a_texcoord', 2, gl.FLOAT);
        shader.addAttribute('a_textureIndex', 1, gl.FLOAT);
        shader.addAttribute('a_opacity', 1, gl.FLOAT);
        shader.addAttribute('a_color', 4, gl.FLOAT);
        shader.addUniformMatrix('u_matrix', this._contextInfo.matrix.data);
        // Initialize texture slots to [0, 1, 2, 3, 4, .... maxGPUTextures]
        shader.addUniformIntegerArray('u_textures', [...Array(maxGPUTextures)].map((_, i) => i));
        return shader;
    }
    _transformFragmentSource(source, maxTextures) {
        let newSource = source.replace('%%count%%', maxTextures.toString());
        let texturePickerBuilder = '';
        for (let i = 0; i < maxTextures; i++) {
            if (i === 0) {
                texturePickerBuilder += `if (v_textureIndex <= ${i}.5) {\n`;
            }
            else {
                texturePickerBuilder += `   else if (v_textureIndex <= ${i}.5) {\n`;
            }
            texturePickerBuilder += `      color = texture2D(u_textures[${i}], v_texcoord);\n`;
            texturePickerBuilder += `   }\n`;
        }
        newSource = newSource.replace('%%texture_picker%%', texturePickerBuilder);
        return newSource;
    }
    addCircle(pos, radius, color) {
        const command = this.commands.get().initCircle(pos, radius, color);
        command.applyTransform(this._contextInfo.transform.current, this._contextInfo.state.current.opacity);
        this.addCommand(command);
    }
    addRectangle(color, pos, width, height) {
        const command = this.commands.get().initRect(color, pos, width, height);
        command.applyTransform(this._contextInfo.transform.current, this._contextInfo.state.current.opacity);
        this.addCommand(command);
    }
    addLine(color, start, end, thickness = 1) {
        const command = this.commands.get().initLine(color, start, end, thickness);
        command.applyTransform(this._contextInfo.transform.current, this._contextInfo.state.current.opacity);
        this.addCommand(command);
    }
    addImage(graphic, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
        const command = this.commands.get().init(graphic, sx, sy, swidth, sheight, dx, dy, dwidth, dheight);
        command.applyTransform(this._contextInfo.transform.current, this._contextInfo.state.current.opacity);
        this.addCommand(command);
    }
    renderBatch(gl, batch, vertexCount) {
        // Bind textures in the correct order
        batch.bindTextures(gl);
        // draw the quads
        gl.drawArrays(gl.TRIANGLES, 0, vertexCount);
    }
    buildBatchVertices(vertexBuffer, batch) {
        var _a, _b;
        let vertIndex = 0;
        let sx = 0;
        let sy = 0;
        let sw = 0;
        let sh = 0;
        let potWidth = 1;
        let potHeight = 1;
        let textureId = 0;
        let commandColor = Color.Transparent;
        for (const command of batch.commands) {
            sx = command.view[0];
            sy = command.view[1];
            sw = command.view[2];
            sh = command.view[3];
            potWidth = ensurePowerOfTwo(((_a = command.image) === null || _a === void 0 ? void 0 : _a.width) || command.width);
            potHeight = ensurePowerOfTwo(((_b = command.image) === null || _b === void 0 ? void 0 : _b.height) || command.height);
            textureId = batch.getBatchTextureId(command);
            if (command.type === DrawCommandType.Line || command.type === DrawCommandType.Rectangle) {
                textureId = -1; // sentinel for no image rect
                commandColor = command.color;
            }
            if (command.type === DrawCommandType.Circle) {
                textureId = -2; // sentinel for circle
                commandColor = command.color;
            }
            // potential optimization when divding by 2 (bitshift)
            // Modifying the images to poweroftwo images warp the UV coordinates
            let uvx0 = sx / potWidth;
            let uvy0 = sy / potHeight;
            let uvx1 = (sx + sw) / potWidth;
            let uvy1 = (sy + sh) / potHeight;
            if (textureId === -2) {
                uvx0 = 0;
                uvy0 = 0;
                uvx1 = 1;
                uvy1 = 1;
            }
            // Quad update
            // (0, 0, z) z-index doesn't work in batch rendering between batches
            vertexBuffer[vertIndex++] = command.geometry[0][0]; // x + 0 * width;
            vertexBuffer[vertIndex++] = command.geometry[0][1]; //y + 0 * height;
            vertexBuffer[vertIndex++] = 0;
            // UV coords
            vertexBuffer[vertIndex++] = uvx0; // 0;
            vertexBuffer[vertIndex++] = uvy0; // 0;
            // texture id
            vertexBuffer[vertIndex++] = textureId;
            // opacity
            vertexBuffer[vertIndex++] = command.opacity;
            // color
            vertexBuffer[vertIndex++] = commandColor.r / 255;
            vertexBuffer[vertIndex++] = commandColor.g / 255;
            vertexBuffer[vertIndex++] = commandColor.b / 255;
            vertexBuffer[vertIndex++] = commandColor.a;
            // (0, 1)
            vertexBuffer[vertIndex++] = command.geometry[1][0]; // x + 0 * width;
            vertexBuffer[vertIndex++] = command.geometry[1][1]; // y + 1 * height;
            vertexBuffer[vertIndex++] = 0;
            // UV coords
            vertexBuffer[vertIndex++] = uvx0; // 0;
            vertexBuffer[vertIndex++] = uvy1; // 1;
            // texture id
            vertexBuffer[vertIndex++] = textureId;
            // opacity
            vertexBuffer[vertIndex++] = command.opacity;
            // color
            vertexBuffer[vertIndex++] = commandColor.r / 255;
            vertexBuffer[vertIndex++] = commandColor.g / 255;
            vertexBuffer[vertIndex++] = commandColor.b / 255;
            vertexBuffer[vertIndex++] = commandColor.a;
            // (1, 0)
            vertexBuffer[vertIndex++] = command.geometry[2][0]; // x + 1 * width;
            vertexBuffer[vertIndex++] = command.geometry[2][1]; // y + 0 * height;
            vertexBuffer[vertIndex++] = 0;
            // UV coords
            vertexBuffer[vertIndex++] = uvx1; //1;
            vertexBuffer[vertIndex++] = uvy0; //0;
            // texture id
            vertexBuffer[vertIndex++] = textureId;
            // opacity
            vertexBuffer[vertIndex++] = command.opacity;
            // color
            vertexBuffer[vertIndex++] = commandColor.r / 255;
            vertexBuffer[vertIndex++] = commandColor.g / 255;
            vertexBuffer[vertIndex++] = commandColor.b / 255;
            vertexBuffer[vertIndex++] = commandColor.a;
            // (1, 0)
            vertexBuffer[vertIndex++] = command.geometry[3][0]; // x + 1 * width;
            vertexBuffer[vertIndex++] = command.geometry[3][1]; // y + 0 * height;
            vertexBuffer[vertIndex++] = 0;
            // UV coords
            vertexBuffer[vertIndex++] = uvx1; //1;
            vertexBuffer[vertIndex++] = uvy0; //0;
            // texture id
            vertexBuffer[vertIndex++] = textureId;
            // opacity
            vertexBuffer[vertIndex++] = command.opacity;
            // color
            vertexBuffer[vertIndex++] = commandColor.r / 255;
            vertexBuffer[vertIndex++] = commandColor.g / 255;
            vertexBuffer[vertIndex++] = commandColor.b / 255;
            vertexBuffer[vertIndex++] = commandColor.a;
            // (0, 1)
            vertexBuffer[vertIndex++] = command.geometry[4][0]; // x + 0 * width;
            vertexBuffer[vertIndex++] = command.geometry[4][1]; // y + 1 * height
            vertexBuffer[vertIndex++] = 0;
            // UV coords
            vertexBuffer[vertIndex++] = uvx0; // 0;
            vertexBuffer[vertIndex++] = uvy1; // 1;
            // texture id
            vertexBuffer[vertIndex++] = textureId;
            // opacity
            vertexBuffer[vertIndex++] = command.opacity;
            // color
            vertexBuffer[vertIndex++] = commandColor.r / 255;
            vertexBuffer[vertIndex++] = commandColor.g / 255;
            vertexBuffer[vertIndex++] = commandColor.b / 255;
            vertexBuffer[vertIndex++] = commandColor.a;
            // (1, 1)
            vertexBuffer[vertIndex++] = command.geometry[5][0]; // x + 1 * width;
            vertexBuffer[vertIndex++] = command.geometry[5][1]; // y + 1 * height;
            vertexBuffer[vertIndex++] = 0;
            // UV coords
            vertexBuffer[vertIndex++] = uvx1; // 1;
            vertexBuffer[vertIndex++] = uvy1; // 1;
            // texture id
            vertexBuffer[vertIndex++] = textureId;
            // opacity
            vertexBuffer[vertIndex++] = command.opacity;
            // color
            vertexBuffer[vertIndex++] = commandColor.r / 255;
            vertexBuffer[vertIndex++] = commandColor.g / 255;
            vertexBuffer[vertIndex++] = commandColor.b / 255;
            vertexBuffer[vertIndex++] = commandColor.a;
        }
        return vertIndex / this.vertexSize;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/shaders/point-vertex.glsl
/* harmony default export */ const point_vertex = ("attribute vec4 a_position;\r\nattribute vec4 a_color;\r\nattribute float a_size;\r\nvarying lowp vec4 v_color;\r\nuniform mat4 u_matrix;\r\n\r\nvoid main() {\r\n  gl_Position = u_matrix * a_position;\r\n  gl_PointSize = a_size * 2.0;\r\n  v_color = a_color;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/shaders/point-fragment.glsl
/* harmony default export */ const point_fragment = ("#ifdef GL_OES_standard_derivatives\r\n#extension GL_OES_standard_derivatives : enable\r\n#endif\r\n\r\nprecision mediump float;\r\nvarying lowp vec4 v_color;\r\n\r\nvoid main() {\r\n  float r = 0.0, delta = 0.0, alpha = 1.0;\r\n  vec2 cxy = 2.0 * gl_PointCoord - 1.0;\r\n  r = dot(cxy, cxy);\r\n  \r\n#ifdef GL_OES_standard_derivatives\r\n  delta = fwidth(r);\r\n  alpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);\r\n#else\r\n  if (r > 1.0) {\r\n    discard;\r\n  }\r\n#endif\r\n  gl_FragColor = vec4(v_color.rgb, v_color.a * alpha);\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/point-renderer.ts






// import { Random } from '../../Math/Index';
class DrawPoint {
    constructor() {
        this.point = Vector.Zero;
        this.color = Color.Black;
        this.size = 1;
    }
    dispose() {
        this.point.setTo(0, 0);
        this.color.r = 0;
        this.color.g = 0;
        this.color.b = 0;
        this.color.a = 1;
        this.size = 1;
        return this;
    }
}
class PointRenderer extends BatchRenderer {
    constructor(gl, _contextInfo) {
        super({ gl, command: DrawPoint, verticesPerCommand: 1 });
        this._contextInfo = _contextInfo;
        this.init();
    }
    buildShader(gl) {
        gl.getExtension('OES_standard_derivatives');
        const shader = new Shader(gl, point_vertex, point_fragment);
        shader.addAttribute('a_position', 2, gl.FLOAT);
        shader.addAttribute('a_color', 4, gl.FLOAT);
        shader.addAttribute('a_size', 1, gl.FLOAT);
        shader.addUniformMatrix('u_matrix', this._contextInfo.matrix.data);
        return shader;
    }
    addPoint(point, color, size) {
        const cmd = this.commands.get();
        cmd.point = this._contextInfo.transform.current.multv(point);
        cmd.color.r = color.r;
        cmd.color.g = color.g;
        cmd.color.b = color.b;
        cmd.color.a = color.a * this._contextInfo.state.current.opacity;
        cmd.size = size * Math.max(this._contextInfo.transform.current.getScaleX(), this._contextInfo.transform.current.getScaleY());
        this.addCommand(cmd);
    }
    buildBatchVertices(vertexBuffer, batch) {
        let index = 0;
        for (const command of batch.commands) {
            vertexBuffer[index++] = command.point.x;
            vertexBuffer[index++] = command.point.y;
            // normalize to [0, 1] for webgl
            vertexBuffer[index++] = command.color.r / 255;
            vertexBuffer[index++] = command.color.g / 255;
            vertexBuffer[index++] = command.color.b / 255;
            vertexBuffer[index++] = command.color.a;
            vertexBuffer[index++] = command.size;
        }
        return index / this.vertexSize;
    }
    renderBatch(gl, _batch, vertexCount) {
        gl.drawArrays(gl.POINTS, 0, vertexCount);
    }
}

;// CONCATENATED MODULE: ./Graphics/Graphic.ts


/**
 * A Graphic is the base Excalibur primitive for something that can be drawn to the [[ExcaliburGraphicsContext]].
 * [[Sprite]], [[Animation]], [[GraphicsGroup]], [[Canvas]], [[Rectangle]], [[Circle]], and [[Polygon]] all derive from the
 * [[Graphic]] abstract class.
 *
 * Implementors of a Graphic must override the abstract [[Graphic._drawImage]] method to render an image to the graphics context. Graphic
 * handles all the position, rotation, and scale transformations in [[Graphic._preDraw]] and [[Graphic._postDraw]]
 */
class Graphic {
    constructor(options) {
        var _a, _b, _c, _d, _e, _f;
        this.id = Graphic._ID++;
        /**
         * Gets or sets wether to show debug information about the graphic
         */
        this.showDebug = false;
        /**
         * Gets or sets the flipHorizontal, which will flip the graphic horizontally (across the y axis)
         */
        this.flipHorizontal = false;
        /**
         * Gets or sets the flipVertical, which will flip the graphic vertically (across the x axis)
         */
        this.flipVertical = false;
        /**
         * Gets or sets the rotation of the graphic
         */
        this.rotation = 0;
        /**
         * Gets or sets the opacity of the graphic, 0 is transparent, 1 is solid (opaque).
         */
        this.opacity = 1;
        /**
         * Gets or sets the scale of the graphic, this affects the width and
         */
        this.scale = Vector.One;
        /**
         * Gets or sets the origin of the graphic, if not set the center of the graphic is the origin
         */
        this.origin = null;
        this._width = 0;
        this._height = 0;
        if (options) {
            this.origin = (_a = options.origin) !== null && _a !== void 0 ? _a : this.origin;
            this.flipHorizontal = (_b = options.flipHorizontal) !== null && _b !== void 0 ? _b : this.flipHorizontal;
            this.flipVertical = (_c = options.flipVertical) !== null && _c !== void 0 ? _c : this.flipVertical;
            this.rotation = (_d = options.rotation) !== null && _d !== void 0 ? _d : this.rotation;
            this.opacity = (_e = options.opacity) !== null && _e !== void 0 ? _e : this.opacity;
            this.scale = (_f = options.scale) !== null && _f !== void 0 ? _f : this.scale;
        }
    }
    cloneGraphicOptions() {
        return {
            origin: this.origin ? this.origin.clone() : null,
            flipHorizontal: this.flipHorizontal,
            flipVertical: this.flipVertical,
            rotation: this.rotation,
            opacity: this.opacity,
            scale: this.scale ? this.scale.clone() : null
        };
    }
    /**
     * Gets or sets the width of the graphic (always positive)
     */
    get width() {
        return Math.abs(this._width * this.scale.x);
    }
    /**
     * Gets or sets the height of the graphic (always positive)
     */
    get height() {
        return Math.abs(this._height * this.scale.y);
    }
    set width(value) {
        this._width = value;
    }
    set height(value) {
        this._height = value;
    }
    /**
     * Gets a copy of the bounds in pixels occupied by the graphic on the the screen. This includes scale.
     */
    get localBounds() {
        return BoundingBox.fromDimension(this.width, this.height, Vector.Zero);
    }
    /**
     * Draw the whole graphic to the context including transform
     * @param ex The excalibur graphics context
     * @param x
     * @param y
     */
    draw(ex, x, y) {
        this._preDraw(ex, x, y);
        this._drawImage(ex, 0, 0);
        this._postDraw(ex);
    }
    /**
     * Apply affine transformations to the graphics context to manipulate the graphic before [[Graphic._drawImage]]
     * @param ex
     * @param x
     * @param y
     */
    _preDraw(ex, x, y) {
        ex.save();
        ex.translate(x, y);
        ex.scale(Math.abs(this.scale.x), Math.abs(this.scale.y));
        this._rotate(ex);
        this._flip(ex);
        // it is important to multiply alphas so graphics respect the current context
        ex.opacity = ex.opacity * this.opacity;
    }
    _rotate(ex) {
        var _a;
        const scaleDirX = this.scale.x > 0 ? 1 : -1;
        const scaleDirY = this.scale.y > 0 ? 1 : -1;
        const origin = (_a = this.origin) !== null && _a !== void 0 ? _a : vec(this.width / 2, this.height / 2);
        ex.translate(origin.x, origin.y);
        ex.rotate(this.rotation);
        // This is for handling direction changes 1 or -1, that way we don't have mismatched translates()
        ex.scale(scaleDirX, scaleDirY);
        ex.translate(-origin.x, -origin.y);
    }
    _flip(ex) {
        if (this.flipHorizontal) {
            ex.translate(this.width / this.scale.x, 0);
            ex.scale(-1, 1);
        }
        if (this.flipVertical) {
            ex.translate(0, this.height / this.scale.y);
            ex.scale(1, -1);
        }
    }
    /**
     * Apply any addtional work after [[Graphic._drawImage]] and restore the context state.
     * @param ex
     */
    _postDraw(ex) {
        if (this.showDebug) {
            ex.debug.drawRect(0, 0, this.width, this.height);
        }
        ex.restore();
    }
}
Graphic._ID = 0;

;// CONCATENATED MODULE: ./Util/Watch.ts
/**
 * Watch an object with a proxy, only fires if property value is different
 */
function watch(type, change) {
    if (!type) {
        return type;
    }
    if (type.__isProxy === undefined) {
        // expando hack to mark a proxy
        return new Proxy(type, {
            set: (obj, prop, value) => {
                // The default behavior to store the value
                if (obj[prop] !== value) {
                    obj[prop] = value;
                    // Avoid watching private junk
                    if (typeof prop === 'string') {
                        if (prop[0] !== '_') {
                            change(obj);
                        }
                    }
                }
                // Indicate success
                return true;
            },
            get: (obj, prop) => {
                if (prop !== '__isProxy') {
                    return obj[prop];
                }
                return true;
            }
        });
    }
    return type;
}
/**
 * Watch an object with a proxy, fires change on any property value change
 */
function watchAny(type, change) {
    if (!type) {
        return type;
    }
    if (type.__isProxy === undefined) {
        // expando hack to mark a proxy
        return new Proxy(type, {
            set: (obj, prop, value) => {
                // The default behavior to store the value
                obj[prop] = value;
                // Avoid watching private junk
                if (typeof prop === 'string') {
                    if (prop[0] !== '_') {
                        change(obj);
                    }
                }
                // Indicate success
                return true;
            },
            get: (obj, prop) => {
                if (prop !== '__isProxy') {
                    return obj[prop];
                }
                return true;
            }
        });
    }
    return type;
}

;// CONCATENATED MODULE: ./Graphics/Raster.ts







/**
 * A Raster is a Graphic that needs to be first painted to a HTMLCanvasElement before it can be drawn to the
 * [[ExcaliburGraphicsContext]]. This is useful for generating custom images using the 2D canvas api.
 *
 * Implementors must implemenet the [[Raster.execute]] method to rasterize their drawing.
 */
class Raster extends Graphic {
    constructor(options) {
        var _a, _b, _c, _d, _e, _f, _g;
        super(options);
        this._dirty = true;
        this._smoothing = false;
        this._color = watch(Color.Black, () => this.flagDirty());
        this._lineWidth = 1;
        this._lineDash = [];
        this._padding = 0;
        if (options) {
            this.color = (_a = options.color) !== null && _a !== void 0 ? _a : Color.Black;
            this.strokeColor = options === null || options === void 0 ? void 0 : options.strokeColor;
            this.smoothing = (_b = options.smoothing) !== null && _b !== void 0 ? _b : this.smoothing;
            this.lineWidth = (_c = options.lineWidth) !== null && _c !== void 0 ? _c : this.lineWidth;
            this.lineDash = (_d = options.lineDash) !== null && _d !== void 0 ? _d : this.lineDash;
            this.padding = (_e = options.padding) !== null && _e !== void 0 ? _e : this.padding;
        }
        this._bitmap = document.createElement('canvas');
        // get the default canvas width/height as a fallback
        const bitmapWidth = (_f = options === null || options === void 0 ? void 0 : options.width) !== null && _f !== void 0 ? _f : this._bitmap.width;
        const bitmapHeight = (_g = options === null || options === void 0 ? void 0 : options.height) !== null && _g !== void 0 ? _g : this._bitmap.height;
        // Rasters use power of two images as an optimization for webgl
        this.width = ensurePowerOfTwo(bitmapWidth);
        this.height = ensurePowerOfTwo(bitmapHeight);
        const maybeCtx = this._bitmap.getContext('2d');
        if (!maybeCtx) {
            /* istanbul ignore next */
            throw new Error('Browser does not support 2d canvas drawing, cannot create Raster graphic');
        }
        else {
            this._ctx = maybeCtx;
        }
    }
    cloneRasterOptions() {
        return {
            color: this.color ? this.color.clone() : null,
            strokeColor: this.strokeColor ? this.strokeColor.clone() : null,
            smoothing: this.smoothing,
            lineWidth: this.lineWidth,
            lineDash: this.lineDash,
            padding: this.padding
        };
    }
    /**
     * Gets whether the graphic is dirty, this means there are changes that haven't been re-rasterized
     */
    get dirty() {
        return this._dirty;
    }
    /**
     * Flags the graphic as dirty, meaning it must be re-rasterized before draw.
     * This should be called any time the graphics state changes such that it affects the outputed drawing
     */
    flagDirty() {
        this._dirty = true;
    }
    /**
     * Gets or sets the current width of the Raster graphic. Setting the width will cause the raster
     * to be flagged dirty causing a re-raster on the next draw.
     *
     * Any `padding`s set will be factored into the width
     */
    get width() {
        return this._getTotalWidth();
    }
    set width(value) {
        this._bitmap.width = value;
        this._originalWidth = value;
        this.flagDirty();
    }
    /**
     * Gets or sets the current height of the Raster graphic. Setting the height will cause the raster
     * to be flagged dirty causing a re-raster on the next draw.
     *
     * Any `padding` set will be factored into the height
     */
    get height() {
        return this._getTotalHeight();
    }
    set height(value) {
        this._bitmap.height = value;
        this._originalHeight = value;
        this.flagDirty();
    }
    _getTotalWidth() {
        var _a;
        return ((_a = this._originalWidth) !== null && _a !== void 0 ? _a : this._bitmap.width) + this.padding * 2;
    }
    _getTotalHeight() {
        var _a;
        return ((_a = this._originalHeight) !== null && _a !== void 0 ? _a : this._bitmap.height) + this.padding * 2;
    }
    /**
     * Returns the local bounds of the Raster including the padding
     */
    get localBounds() {
        return BoundingBox.fromDimension(this._getTotalWidth() * this.scale.x, this._getTotalHeight() * this.scale.y, Vector.Zero);
    }
    /**
     * Gets or sets the smoothing (anti-aliasing of the graphic). Setting the height will cause the raster
     * to be flagged dirty causing a re-raster on the next draw.
     */
    get smoothing() {
        return this._smoothing;
    }
    set smoothing(value) {
        this._smoothing = value;
        this.flagDirty();
    }
    /**
     * Gets or sets the fillStyle of the Raster graphic. Setting the fillStyle will cause the raster to be
     * flagged dirty causing a re-raster on the next draw.
     */
    get color() {
        return this._color;
    }
    set color(value) {
        var _a;
        if (!((_a = this._color) === null || _a === void 0 ? void 0 : _a.equal(value))) {
            this.flagDirty();
        }
        this._color = watch(value, () => this.flagDirty());
    }
    /**
     * Gets or sets the strokeStyle of the Raster graphic. Setting the strokeStyle will cause the raster to be
     * flagged dirty causing a re-raster on the next draw.
     */
    get strokeColor() {
        return this._strokeColor;
    }
    set strokeColor(value) {
        var _a;
        if (!((_a = this._strokeColor) === null || _a === void 0 ? void 0 : _a.equal(value))) {
            this.flagDirty();
        }
        this._strokeColor = watch(value, () => this.flagDirty());
    }
    /**
     * Gets or sets the line width of the Raster graphic. Setting the lineWidth will cause the raster to be
     * flagged dirty causing a re-raster on the next draw.
     */
    get lineWidth() {
        return this._lineWidth;
    }
    set lineWidth(value) {
        this._lineWidth = value;
        this.flagDirty();
    }
    get lineDash() {
        return this._lineDash;
    }
    set lineDash(value) {
        this._lineDash = value;
        this.flagDirty();
    }
    get padding() {
        return this._padding;
    }
    set padding(value) {
        this._padding = value;
        this.flagDirty();
    }
    /**
     * Rasterize the graphic to a bitmap making it usuable as in excalibur. Rasterize is called automatically if
     * the graphic is [[Raster.dirty]] on the next [[Graphic.draw]] call
     */
    rasterize() {
        this._dirty = false;
        this._ctx.clearRect(0, 0, this._getTotalWidth(), this._getTotalHeight());
        this._ctx.save();
        this._applyRasterProperites(this._ctx);
        this.execute(this._ctx);
        this._ctx.restore();
        // The webgl texture needs to be updated if it exists after a raster cycle
        TextureLoader.load(this._bitmap, true);
    }
    _applyRasterProperites(ctx) {
        var _a, _b, _c;
        this._bitmap.width = this._getTotalWidth();
        this._bitmap.height = this._getTotalHeight();
        ctx.translate(this.padding, this.padding);
        ctx.imageSmoothingEnabled = this.smoothing;
        ctx.lineWidth = this.lineWidth;
        ctx.setLineDash((_a = this.lineDash) !== null && _a !== void 0 ? _a : ctx.getLineDash());
        ctx.strokeStyle = (_b = this.strokeColor) === null || _b === void 0 ? void 0 : _b.toString();
        ctx.fillStyle = (_c = this.color) === null || _c === void 0 ? void 0 : _c.toString();
    }
    _drawImage(ex, x, y) {
        if (this._dirty) {
            this.rasterize();
        }
        ex.drawImage(this._bitmap, x, y);
    }
}

;// CONCATENATED MODULE: ./Graphics/Canvas.ts

/**
 * A canvas [[Graphic]] to provide an adapter between the 2D Canvas API and the [[ExcaliburGraphicsContext]].
 *
 * The [[Canvas]] works by re-rastering a draw handler to a HTMLCanvasElement for every draw which is then passed
 * to the [[ExcaliburGraphicsContext]] implementation as a rendered image.
 *
 * **Low performance API**
 */
class Canvas extends Raster {
    constructor(_options) {
        super(_options);
        this._options = _options;
    }
    /**
     * Return the 2D graphics context of this canvas
     */
    get ctx() {
        return this._ctx;
    }
    clone() {
        return new Canvas(Object.assign(Object.assign(Object.assign({}, this._options), this.cloneGraphicOptions()), this.cloneRasterOptions()));
    }
    execute(ctx) {
        var _a, _b;
        if ((_a = this._options) === null || _a === void 0 ? void 0 : _a.draw) {
            (_b = this._options) === null || _b === void 0 ? void 0 : _b.draw(ctx);
        }
        if (!this._options.cache) {
            this.flagDirty();
        }
    }
}

;// CONCATENATED MODULE: ./Events.ts
var EventTypes;
(function (EventTypes) {
    EventTypes["Kill"] = "kill";
    EventTypes["PreKill"] = "prekill";
    EventTypes["PostKill"] = "postkill";
    EventTypes["PreDraw"] = "predraw";
    EventTypes["PostDraw"] = "postdraw";
    EventTypes["PreDebugDraw"] = "predebugdraw";
    EventTypes["PostDebugDraw"] = "postdebugdraw";
    EventTypes["PreUpdate"] = "preupdate";
    EventTypes["PostUpdate"] = "postupdate";
    EventTypes["PreFrame"] = "preframe";
    EventTypes["PostFrame"] = "postframe";
    EventTypes["PreCollision"] = "precollision";
    EventTypes["CollisionStart"] = "collisionstart";
    EventTypes["CollisionEnd"] = "collisionend";
    EventTypes["PostCollision"] = "postcollision";
    EventTypes["Initialize"] = "initialize";
    EventTypes["Activate"] = "activate";
    EventTypes["Deactivate"] = "deactivate";
    EventTypes["ExitViewport"] = "exitviewport";
    EventTypes["EnterViewport"] = "enterviewport";
    EventTypes["ExitTrigger"] = "exit";
    EventTypes["EnterTrigger"] = "enter";
    EventTypes["Connect"] = "connect";
    EventTypes["Disconnect"] = "disconnect";
    EventTypes["Button"] = "button";
    EventTypes["Axis"] = "axis";
    EventTypes["Subscribe"] = "subscribe";
    EventTypes["Unsubscribe"] = "unsubscribe";
    EventTypes["Visible"] = "visible";
    EventTypes["Hidden"] = "hidden";
    EventTypes["Start"] = "start";
    EventTypes["Stop"] = "stop";
    EventTypes["PointerUp"] = "pointerup";
    EventTypes["PointerDown"] = "pointerdown";
    EventTypes["PointerMove"] = "pointermove";
    EventTypes["PointerEnter"] = "pointerenter";
    EventTypes["PointerLeave"] = "pointerleave";
    EventTypes["PointerCancel"] = "pointercancel";
    EventTypes["PointerWheel"] = "pointerwheel";
    EventTypes["Up"] = "up";
    EventTypes["Down"] = "down";
    EventTypes["Move"] = "move";
    EventTypes["Enter"] = "enter";
    EventTypes["Leave"] = "leave";
    EventTypes["Cancel"] = "cancel";
    EventTypes["Wheel"] = "wheel";
    EventTypes["Press"] = "press";
    EventTypes["Release"] = "release";
    EventTypes["Hold"] = "hold";
    EventTypes["PointerDragStart"] = "pointerdragstart";
    EventTypes["PointerDragEnd"] = "pointerdragend";
    EventTypes["PointerDragEnter"] = "pointerdragenter";
    EventTypes["PointerDragLeave"] = "pointerdragleave";
    EventTypes["PointerDragMove"] = "pointerdragmove";
})(EventTypes || (EventTypes = {}));
/**
 * Base event type in Excalibur that all other event types derive from. Not all event types are thrown on all Excalibur game objects,
 * some events are unique to a type, others are not.
 *
 */
class GameEvent {
    constructor() {
        this._bubbles = true;
    }
    /**
     * If set to false, prevents event from propagating to other actors. If true it will be propagated
     * to all actors that apply.
     */
    get bubbles() {
        return this._bubbles;
    }
    set bubbles(value) {
        this._bubbles = value;
    }
    /**
     * Prevents event from bubbling
     */
    stopPropagation() {
        this.bubbles = false;
    }
}
/**
 * The 'kill' event is emitted on actors when it is killed. The target is the actor that was killed.
 */
class KillEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * The 'prekill' event is emitted directly before an actor is killed.
 */
class PreKillEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * The 'postkill' event is emitted directly after the actor is killed.
 */
class PostKillEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * The 'start' event is emitted on engine when has started and is ready for interaction.
 */
class GameStartEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * The 'stop' event is emitted on engine when has been stopped and will no longer take input, update or draw.
 */
class GameStopEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * The 'predraw' event is emitted on actors, scenes, and engine before drawing starts. Actors' predraw happens inside their graphics
 * transform so that all drawing takes place with the actor as the origin.
 *
 */
class PreDrawEvent extends GameEvent {
    constructor(ctx, delta, target) {
        super();
        this.ctx = ctx;
        this.delta = delta;
        this.target = target;
    }
}
/**
 * The 'postdraw' event is emitted on actors, scenes, and engine after drawing finishes. Actors' postdraw happens inside their graphics
 * transform so that all drawing takes place with the actor as the origin.
 *
 */
class PostDrawEvent extends GameEvent {
    constructor(ctx, delta, target) {
        super();
        this.ctx = ctx;
        this.delta = delta;
        this.target = target;
    }
}
/**
 * The 'predebugdraw' event is emitted on actors, scenes, and engine before debug drawing starts.
 */
class PreDebugDrawEvent extends GameEvent {
    constructor(ctx, target) {
        super();
        this.ctx = ctx;
        this.target = target;
    }
}
/**
 * The 'postdebugdraw' event is emitted on actors, scenes, and engine after debug drawing starts.
 */
class PostDebugDrawEvent extends GameEvent {
    constructor(ctx, target) {
        super();
        this.ctx = ctx;
        this.target = target;
    }
}
/**
 * The 'preupdate' event is emitted on actors, scenes, camera, and engine before the update starts.
 */
class PreUpdateEvent extends GameEvent {
    constructor(engine, delta, target) {
        super();
        this.engine = engine;
        this.delta = delta;
        this.target = target;
    }
}
/**
 * The 'postupdate' event is emitted on actors, scenes, camera, and engine after the update ends.
 */
class PostUpdateEvent extends GameEvent {
    constructor(engine, delta, target) {
        super();
        this.engine = engine;
        this.delta = delta;
        this.target = target;
    }
}
/**
 * The 'preframe' event is emitted on the engine, before the frame begins.
 */
class PreFrameEvent extends GameEvent {
    constructor(engine, prevStats) {
        super();
        this.engine = engine;
        this.prevStats = prevStats;
        this.target = engine;
    }
}
/**
 * The 'postframe' event is emitted on the engine, after a frame ends.
 */
class PostFrameEvent extends GameEvent {
    constructor(engine, stats) {
        super();
        this.engine = engine;
        this.stats = stats;
        this.target = engine;
    }
}
/**
 * Event received when a gamepad is connected to Excalibur. [[Gamepads]] receives this event.
 */
class GamepadConnectEvent extends GameEvent {
    constructor(index, gamepad) {
        super();
        this.index = index;
        this.gamepad = gamepad;
        this.target = gamepad;
    }
}
/**
 * Event received when a gamepad is disconnected from Excalibur. [[Gamepads]] receives this event.
 */
class GamepadDisconnectEvent extends GameEvent {
    constructor(index, gamepad) {
        super();
        this.index = index;
        this.gamepad = gamepad;
        this.target = gamepad;
    }
}
/**
 * Gamepad button event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;
 */
class GamepadButtonEvent extends GameEvent {
    /**
     * @param button  The Gamepad button
     * @param value   A numeric value between 0 and 1
     */
    constructor(button, value, target) {
        super();
        this.button = button;
        this.value = value;
        this.target = target;
    }
}
/**
 * Gamepad axis event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;
 */
class GamepadAxisEvent extends GameEvent {
    /**
     * @param axis  The Gamepad axis
     * @param value A numeric value between -1 and 1
     */
    constructor(axis, value, target) {
        super();
        this.axis = axis;
        this.value = value;
        this.target = target;
    }
}
/**
 * Subscribe event thrown when handlers for events other than subscribe are added. Meta event that is received by
 * [[EventDispatcher|event dispatchers]].
 */
class SubscribeEvent extends GameEvent {
    constructor(topic, handler) {
        super();
        this.topic = topic;
        this.handler = handler;
    }
}
/**
 * Unsubscribe event thrown when handlers for events other than unsubscribe are removed. Meta event that is received by
 * [[EventDispatcher|event dispatchers]].
 */
class UnsubscribeEvent extends GameEvent {
    constructor(topic, handler) {
        super();
        this.topic = topic;
        this.handler = handler;
    }
}
/**
 * Event received by the [[Engine]] when the browser window is visible on a screen.
 */
class VisibleEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * Event received by the [[Engine]] when the browser window is hidden from all screens.
 */
class HiddenEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * Event thrown on an [[Actor|actor]] when a collision will occur this frame if it resolves
 */
class PreCollisionEvent extends GameEvent {
    /**
     * @param actor         The actor the event was thrown on
     * @param other         The actor that will collided with the current actor
     * @param side          The side that will be collided with the current actor
     * @param intersection  Intersection vector
     */
    constructor(actor, other, side, intersection) {
        super();
        this.other = other;
        this.side = side;
        this.intersection = intersection;
        this.target = actor;
    }
}
/**
 * Event thrown on an [[Actor|actor]] when a collision has been resolved (body reacted) this frame
 */
class PostCollisionEvent extends GameEvent {
    /**
     * @param actor         The actor the event was thrown on
     * @param other         The actor that did collide with the current actor
     * @param side          The side that did collide with the current actor
     * @param intersection  Intersection vector
     */
    constructor(actor, other, side, intersection) {
        super();
        this.other = other;
        this.side = side;
        this.intersection = intersection;
        this.target = actor;
    }
    get actor() {
        return this.target;
    }
    set actor(actor) {
        this.target = actor;
    }
}
class ContactStartEvent {
    constructor(target, other, contact) {
        this.target = target;
        this.other = other;
        this.contact = contact;
    }
}
class ContactEndEvent {
    constructor(target, other) {
        this.target = target;
        this.other = other;
    }
}
class CollisionPreSolveEvent {
    constructor(target, other, side, intersection, contact) {
        this.target = target;
        this.other = other;
        this.side = side;
        this.intersection = intersection;
        this.contact = contact;
    }
}
class CollisionPostSolveEvent {
    constructor(target, other, side, intersection, contact) {
        this.target = target;
        this.other = other;
        this.side = side;
        this.intersection = intersection;
        this.contact = contact;
    }
}
/**
 * Event thrown the first time an [[Actor|actor]] collides with another, after an actor is in contact normal collision events are fired.
 */
class CollisionStartEvent extends GameEvent {
    /**
     *
     * @param actor
     * @param other
     * @param contact
     */
    constructor(actor, other, contact) {
        super();
        this.other = other;
        this.contact = contact;
        this.target = actor;
    }
    get actor() {
        return this.target;
    }
    set actor(actor) {
        this.target = actor;
    }
}
/**
 * Event thrown when the [[Actor|actor]] is no longer colliding with another
 */
class CollisionEndEvent extends GameEvent {
    /**
     *
     */
    constructor(actor, other) {
        super();
        this.other = other;
        this.target = actor;
    }
    get actor() {
        return this.target;
    }
    set actor(actor) {
        this.target = actor;
    }
}
/**
 * Event thrown on an [[Actor]] and a [[Scene]] only once before the first update call
 */
class InitializeEvent extends GameEvent {
    /**
     * @param engine  The reference to the current engine
     */
    constructor(engine, target) {
        super();
        this.engine = engine;
        this.target = target;
    }
}
/**
 * Event thrown on a [[Scene]] on activation
 */
class ActivateEvent extends GameEvent {
    /**
     * @param oldScene  The reference to the old scene
     */
    constructor(oldScene, target) {
        super();
        this.oldScene = oldScene;
        this.target = target;
    }
}
/**
 * Event thrown on a [[Scene]] on deactivation
 */
class DeactivateEvent extends GameEvent {
    /**
     * @param newScene  The reference to the new scene
     */
    constructor(newScene, target) {
        super();
        this.newScene = newScene;
        this.target = target;
    }
}
/**
 * Event thrown on an [[Actor]] when it completely leaves the screen.
 */
class ExitViewPortEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * Event thrown on an [[Actor]] when it completely leaves the screen.
 */
class EnterViewPortEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
class EnterTriggerEvent extends GameEvent {
    constructor(target, actor) {
        super();
        this.target = target;
        this.actor = actor;
    }
}
class ExitTriggerEvent extends GameEvent {
    constructor(target, actor) {
        super();
        this.target = target;
        this.actor = actor;
    }
}

;// CONCATENATED MODULE: ./EventDispatcher.ts

class EventDispatcher {
    /**
     * @param target  The object that will be the recipient of events from this event dispatcher
     */
    constructor(target) {
        this._handlers = {};
        this._wiredEventDispatchers = [];
        this._target = target;
    }
    /**
     * Clears any existing handlers or wired event dispatchers on this event dispatcher
     */
    clear() {
        this._handlers = {};
        this._wiredEventDispatchers = [];
    }
    /**
     * Emits an event for target
     * @param eventName  The name of the event to publish
     * @param event      Optionally pass an event data object to the handler
     */
    emit(eventName, event) {
        if (!eventName) {
            // key not mapped
            return;
        }
        eventName = eventName.toLowerCase();
        const target = this._target;
        if (!event) {
            event = new GameEvent();
        }
        try {
            if (!event.target) {
                event.target = target;
            }
        }
        catch (_a) {
            // pass
        }
        let i, len;
        if (this._handlers[eventName]) {
            i = 0;
            len = this._handlers[eventName].length;
            for (i; i < len; i++) {
                this._handlers[eventName][i].call(target, event);
            }
        }
        i = 0;
        len = this._wiredEventDispatchers.length;
        for (i; i < len; i++) {
            this._wiredEventDispatchers[i].emit(eventName, event);
        }
    }
    /**
     * Subscribe an event handler to a particular event name, multiple handlers per event name are allowed.
     * @param eventName  The name of the event to subscribe to
     * @param handler    The handler callback to fire on this event
     */
    on(eventName, handler) {
        eventName = eventName.toLowerCase();
        if (!this._handlers[eventName]) {
            this._handlers[eventName] = [];
        }
        this._handlers[eventName].push(handler);
        // meta event handlers
        if (eventName !== 'unsubscribe' && eventName !== 'subscribe') {
            this.emit('subscribe', new SubscribeEvent(eventName, handler));
        }
    }
    /**
     * Unsubscribe an event handler(s) from an event. If a specific handler
     * is specified for an event, only that handler will be unsubscribed.
     * Otherwise all handlers will be unsubscribed for that event.
     *
     * @param eventName  The name of the event to unsubscribe
     * @param handler    Optionally the specific handler to unsubscribe
     */
    off(eventName, handler) {
        eventName = eventName.toLowerCase();
        const eventHandlers = this._handlers[eventName];
        if (eventHandlers) {
            // if no explicit handler is give with the event name clear all handlers
            if (!handler) {
                this._handlers[eventName].length = 0;
            }
            else {
                const index = eventHandlers.indexOf(handler);
                this._handlers[eventName].splice(index, 1);
            }
        }
        // meta event handlers
        if (eventName !== 'unsubscribe' && eventName !== 'subscribe') {
            this.emit('unsubscribe', new UnsubscribeEvent(eventName, handler));
        }
    }
    /**
     * Once listens to an event one time, then unsubscribes from that event
     *
     * @param eventName The name of the event to subscribe to once
     * @param handler   The handler of the event that will be auto unsubscribed
     */
    once(eventName, handler) {
        const metaHandler = (event) => {
            const ev = event || new GameEvent();
            try {
                ev.target = ev.target || this._target;
            }
            catch (_a) {
                // pass
            }
            this.off(eventName, handler);
            handler.call(ev.target, ev);
        };
        this.on(eventName, metaHandler);
    }
    /**
     * Wires this event dispatcher to also receive events from another
     */
    wire(eventDispatcher) {
        eventDispatcher._wiredEventDispatchers.push(this);
    }
    /**
     * Unwires this event dispatcher from another
     */
    unwire(eventDispatcher) {
        const index = eventDispatcher._wiredEventDispatchers.indexOf(this);
        if (index > -1) {
            eventDispatcher._wiredEventDispatchers.splice(index, 1);
        }
    }
}

;// CONCATENATED MODULE: ./Resources/Resource.ts


/**
 * The [[Resource]] type allows games built in Excalibur to load generic resources.
 * For any type of remote resource it is recommended to use [[Resource]] for preloading.
 */
class Resource {
    /**
     * @param path          Path to the remote resource
     * @param responseType  The type to expect as a response: "" | "arraybuffer" | "blob" | "document" | "json" | "text";
     * @param bustCache     Whether or not to cache-bust requests
     */
    constructor(path, responseType, bustCache = true) {
        this.path = path;
        this.responseType = responseType;
        this.bustCache = bustCache;
        this.data = null;
        this.logger = Logger.getInstance();
        this.events = new EventDispatcher(this);
    }
    /**
     * Returns true if the Resource is completely loaded and is ready
     * to be drawn.
     */
    isLoaded() {
        return this.data !== null;
    }
    _cacheBust(uri) {
        const query = /\?\w*=\w*/;
        if (query.test(uri)) {
            uri += '&__=' + Date.now();
        }
        else {
            uri += '?__=' + Date.now();
        }
        return uri;
    }
    /**
     * Begin loading the resource and returns a promise to be resolved on completion
     */
    load() {
        return new Promise((resolve, reject) => {
            // Exit early if we already have data
            if (this.data !== null) {
                this.logger.debug('Already have data for resource', this.path);
                this.events.emit('complete', this.data);
                resolve(this.data);
                return;
            }
            const request = new XMLHttpRequest();
            request.open('GET', this.bustCache ? this._cacheBust(this.path) : this.path, true);
            request.responseType = this.responseType;
            request.addEventListener('loadstart', (e) => this.events.emit('loadstart', e));
            request.addEventListener('progress', (e) => this.events.emit('progress', e));
            request.addEventListener('error', (e) => this.events.emit('error', e));
            request.addEventListener('load', (e) => this.events.emit('load', e));
            request.addEventListener('load', () => {
                // XHR on file:// success status is 0, such as with PhantomJS
                if (request.status !== 0 && request.status !== 200) {
                    this.logger.error('Failed to load resource ', this.path, ' server responded with error code', request.status);
                    this.events.emit('error', request.response);
                    reject(new Error(request.statusText));
                    return;
                }
                this.data = request.response;
                this.events.emit('complete', this.data);
                this.logger.debug('Completed loading resource', this.path);
                resolve(this.data);
            });
            request.send();
        });
    }
}

;// CONCATENATED MODULE: ./Drawing/SpriteEffects.ts
/**
 * @module
 * @deprecated
 * These effects can be applied to any bitmap image but are mainly used
 * for [[Sprite]] effects or [[Animation]] effects.
 */
var SpriteEffects_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * @typedoc
 */


/**
 * Applies the "Grayscale" effect to a sprite, removing color information.
 * @deprecated [[Grayscale]] will be removed in v0.26.0
 */
let Grayscale = class Grayscale {
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        const avg = (pixel[firstPixel + 0] + pixel[firstPixel + 1] + pixel[firstPixel + 2]) / 3;
        pixel[firstPixel + 0] = avg;
        pixel[firstPixel + 1] = avg;
        pixel[firstPixel + 2] = avg;
    }
};
Grayscale = SpriteEffects_decorate([
    obsolete({
        message: 'Grayscale will be removed in v0.26.0'
    })
], Grayscale);

/**
 * Applies the "Invert" effect to a sprite, inverting the pixel colors.
 * @deprecated [[Invert]] will be removed in v0.26.0
 */
let Invert = class Invert {
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        pixel[firstPixel + 0] = 255 - pixel[firstPixel + 0];
        pixel[firstPixel + 1] = 255 - pixel[firstPixel + 1];
        pixel[firstPixel + 2] = 255 - pixel[firstPixel + 2];
    }
};
Invert = SpriteEffects_decorate([
    obsolete({
        message: 'Invert will be removed in v0.26.0'
    })
], Invert);

/**
 * Applies the "Opacity" effect to a sprite, setting the alpha of all pixels to a given value.
 * @deprecated [[Opacity]] will be removed in v0.26.0
 */
let Opacity = class Opacity {
    /**
     * @param opacity  The new opacity of the sprite from 0-1.0
     */
    constructor(opacity) {
        this.opacity = opacity;
    }
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        if (pixel[firstPixel + 3] !== 0) {
            pixel[firstPixel + 3] = Math.round(this.opacity * pixel[firstPixel + 3]);
        }
    }
};
Opacity = SpriteEffects_decorate([
    obsolete({
        message: 'Opacity will be removed in v0.26.0'
    })
], Opacity);

/**
 * Applies the "Colorize" effect to a sprite, changing the color channels of all the pixels to an
 * average of the original color and the provided color
 * @deprecated [[Colorize]] will be removed in v0.26.0
 */
let Colorize = class Colorize {
    /**
     * @param color  The color to apply to the sprite
     */
    constructor(color) {
        this.color = color;
    }
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        if (pixel[firstPixel + 3] !== 0) {
            pixel[firstPixel + 0] = (pixel[firstPixel + 0] + this.color.r) / 2;
            pixel[firstPixel + 1] = (pixel[firstPixel + 1] + this.color.g) / 2;
            pixel[firstPixel + 2] = (pixel[firstPixel + 2] + this.color.b) / 2;
        }
    }
};
Colorize = SpriteEffects_decorate([
    obsolete({
        message: 'Colorize will be removed in v0.26.0'
    })
], Colorize);

/**
 * Applies the "Lighten" effect to a sprite, changes the lightness of the color according to HSL
 * @deprecated [[Lighten]] will be removed in v0.26.0
 */
let Lighten = class Lighten {
    /**
     * @param factor  The factor of the effect between 0-1
     */
    constructor(factor = 0.1) {
        this.factor = factor;
    }
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        const color = Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).lighten(this.factor);
        pixel[firstPixel + 0] = color.r;
        pixel[firstPixel + 1] = color.g;
        pixel[firstPixel + 2] = color.b;
        pixel[firstPixel + 3] = color.a;
    }
};
Lighten = SpriteEffects_decorate([
    obsolete({
        message: 'Lighten will be removed in v0.26.0'
    })
], Lighten);

/**
 * Applies the "Darken" effect to a sprite, changes the darkness of the color according to HSL
 * @deprecated [[Darken]] will be removed in v0.26.0
 */
let Darken = class Darken {
    /**
     * @param factor  The factor of the effect between 0-1
     */
    constructor(factor = 0.1) {
        this.factor = factor;
    }
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        const color = Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).darken(this.factor);
        pixel[firstPixel + 0] = color.r;
        pixel[firstPixel + 1] = color.g;
        pixel[firstPixel + 2] = color.b;
        pixel[firstPixel + 3] = color.a;
    }
};
Darken = SpriteEffects_decorate([
    obsolete({
        message: 'Darken will be removed v0.26.0'
    })
], Darken);

/**
 * Applies the "Saturate" effect to a sprite, saturates the color according to HSL
 * @deprecated [[Saturate]] will be removed in v0.26.0
 */
let Saturate = class Saturate {
    /**
     * @param factor  The factor of the effect between 0-1
     */
    constructor(factor = 0.1) {
        this.factor = factor;
    }
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        const color = Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).saturate(this.factor);
        pixel[firstPixel + 0] = color.r;
        pixel[firstPixel + 1] = color.g;
        pixel[firstPixel + 2] = color.b;
        pixel[firstPixel + 3] = color.a;
    }
};
Saturate = SpriteEffects_decorate([
    obsolete({
        message: 'Saturate will be removed in v0.26.0'
    })
], Saturate);

/**
 * Applies the "Desaturate" effect to a sprite, desaturates the color according to HSL
 * @deprecated [[Desaturate]] will be removed in v0.26.0
 */
let Desaturate = class Desaturate {
    /**
     * @param factor  The factor of the effect between 0-1
     */
    constructor(factor = 0.1) {
        this.factor = factor;
    }
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        const color = Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).desaturate(this.factor);
        pixel[firstPixel + 0] = color.r;
        pixel[firstPixel + 1] = color.g;
        pixel[firstPixel + 2] = color.b;
        pixel[firstPixel + 3] = color.a;
    }
};
Desaturate = SpriteEffects_decorate([
    obsolete({
        message: 'Desaturate will be removed in v0.26.0'
    })
], Desaturate);

/**
 * Applies the "Fill" effect to a sprite, changing the color channels of all non-transparent pixels to match
 * a given color
 * @deprecated [[Fill]] will be removed in v0.26.0
 */
let Fill = class Fill {
    /**
     * @param color  The color to apply to the sprite
     */
    constructor(color) {
        this.color = color;
    }
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        if (pixel[firstPixel + 3] !== 0) {
            pixel[firstPixel + 0] = this.color.r;
            pixel[firstPixel + 1] = this.color.g;
            pixel[firstPixel + 2] = this.color.b;
        }
    }
};
Fill = SpriteEffects_decorate([
    obsolete({
        message: 'Fill will be removed in v0.26.0'
    })
], Fill);


;// CONCATENATED MODULE: ./Drawing/Texture.ts
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


/**
 * The [[Texture]] object allows games built in Excalibur to load image resources.
 * [[Texture]] is an [[Loadable]] which means it can be passed to a [[Loader]]
 * to pre-load before starting a level or game.
 * @deprecated
 */
class Texture {
    /**
     * @param path       Path to the image resource or a base64 string representing an image "data:image/png;base64,iVB..."
     * @param bustCache  Optionally load texture with cache busting
     */
    constructor(path, bustCache = true) {
        this.path = path;
        this.bustCache = bustCache;
        this._sprite = null;
        this.loaded = new Promise(resolve => {
            this._loadedResolve = resolve;
        });
        this._resource = new Resource(path, 'blob', bustCache);
        this._sprite = new Sprite_Sprite(this, 0, 0, 0, 0);
    }
    get image() {
        return this.data;
    }
    /**
     * Returns true if the Texture is completely loaded and is ready
     * to be drawn.
     */
    isLoaded() {
        return !!this.data;
    }
    /**
     * Begins loading the texture and returns a promise to be resolved on completion
     */
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // Load base64 or blob if needed
                let url;
                if (!this.path.includes('data:image/')) {
                    const blob = yield this._resource.load();
                    url = URL.createObjectURL(blob);
                }
                else {
                    url = this.path;
                }
                // Decode the image
                const image = new Image();
                image.src = url;
                yield image.decode();
                // Set results
                this.data = image;
                this.width = this._sprite.width = image.naturalWidth;
                this.height = this._sprite.height = image.naturalHeight;
                this._sprite = new Sprite_Sprite(this, 0, 0, this.width, this.height);
            }
            catch (_a) {
                yield Promise.reject('Error loading texture');
            }
            // todo emit complete
            this._loadedResolve(this.data);
            return this.data;
        });
    }
    asSprite() {
        return this._sprite;
    }
}

;// CONCATENATED MODULE: ./Configurable.ts
/**
 * Configurable helper extends base type and makes all properties available as option bag arguments
 * @internal
 * @param base
 */
function Configurable(base) {
    return class extends base {
        assign(props) {
            //set the value of every property that was passed in,
            //if the constructor previously set this value, it will be overridden here
            for (const k in props) {
                // eslint-disable-next-line
                if (typeof this[k] !== 'function') {
                    // eslint-disable-next-line
                    this[k] = props[k];
                }
            }
        }
        constructor(...args) {
            super(...args);
            //get the number of arguments that aren't undefined. TS passes a value to all parameters
            //of whatever ctor is the implementation, so args.length doesn't work here.
            const size = args.filter(function (value) {
                return value !== undefined;
            }).length;
            if (size === 1 && args[0] && typeof args[0] === 'object' && !(args[0] instanceof Array)) {
                this.assign(args[0]);
            }
        }
    };
}

;// CONCATENATED MODULE: ./Drawing/Sprite.ts
var Sprite_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Sprite_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};








/**
 * @hidden
 * @deprecated Use [[Sprite]]
 */
class SpriteImpl {
    /**
     * @param imageOrConfig  The backing image texture to build the Sprite, or Sprite option bag
     * @param x      The x position of the sprite
     * @param y      The y position of the sprite
     * @param width  The width of the sprite in pixels
     * @param height The height of the sprite in pixels
     */
    constructor(imageOrConfig, x, y, width, height) {
        this.x = 0;
        this.y = 0;
        this.rotation = 0.0;
        this.anchor = Vector.Half;
        this.offset = Vector.Zero;
        this.scale = Vector.One;
        /**
         * Default: false, should the sprite be drawn around the anchor or from the top left.
         * Sprite rotations/scaling still happen around the anchor regardless of this setting.
         */
        this.drawAroundAnchor = false;
        this.logger = Logger.getInstance();
        /**
         * Draws the sprite flipped vertically
         */
        this.flipVertical = false;
        /**
         * Draws the sprite flipped horizontally
         */
        this.flipHorizontal = false;
        this.effects = [];
        this.width = 0;
        this.height = 0;
        this._spriteCanvas = null;
        this._spriteCtx = null;
        this._pixelData = null;
        this._pixelsLoaded = false;
        this._dirtyEffect = true;
        this._opacity = 1;
        let image = imageOrConfig;
        if (imageOrConfig && !(imageOrConfig instanceof Texture)) {
            x = imageOrConfig.x | 0;
            y = imageOrConfig.y | 0;
            width = imageOrConfig.width | 0;
            height = imageOrConfig.height | 0;
            image = imageOrConfig.image;
            if (!image) {
                const message = 'An image texture is required to construct a sprite';
                throw new Error(message);
            }
        }
        this.x = x || 0;
        this.y = y || 0;
        this.texture = image;
        this._spriteCanvas = document.createElement('canvas');
        this._spriteCanvas.width = width;
        this._spriteCanvas.height = height;
        this._spriteCtx = this._spriteCanvas.getContext('2d');
        this._initPixelsFromTexture();
        this.width = width;
        this.height = height;
    }
    get drawWidth() {
        return Math.abs(this.width * this.scale.x);
    }
    get drawHeight() {
        return Math.abs(this.height * this.scale.y);
    }
    _initPixelsFromTexture() {
        return Sprite_awaiter(this, void 0, void 0, function* () {
            try {
                const image = yield this.texture.loaded;
                this.width = this.width || image.naturalWidth;
                this.height = this.height || image.naturalHeight;
                this._spriteCanvas.width = this._spriteCanvas.width || image.naturalWidth;
                this._spriteCanvas.height = this._spriteCanvas.height || image.naturalHeight;
                this._loadPixels();
                this._dirtyEffect = true;
            }
            catch (e) {
                this.logger.error('Error loading texture ', this.texture.path, e);
            }
        });
    }
    _loadPixels() {
        if (this.texture.isLoaded() && !this._pixelsLoaded) {
            const naturalWidth = this.texture.image.naturalWidth || 0;
            const naturalHeight = this.texture.image.naturalHeight || 0;
            if (this.width > naturalWidth) {
                this.logger.warn(`The sprite width ${this.width} exceeds the width 
                              ${naturalWidth} of the backing texture ${this.texture.path}`);
            }
            if (this.width <= 0 || naturalWidth <= 0) {
                throw new Error(`The width of a sprite cannot be 0 or negative, sprite width: ${this.width}, original width: ${naturalWidth}`);
            }
            if (this.height > naturalHeight) {
                this.logger.warn(`The sprite height ${this.height} exceeds the height 
                              ${naturalHeight} of the backing texture ${this.texture.path}`);
            }
            if (this.height <= 0 || naturalHeight <= 0) {
                throw new Error(`The height of a sprite cannot be 0 or negative, sprite height: ${this.height}, original height: ${naturalHeight}`);
            }
            this._flushTexture();
            this._pixelsLoaded = true;
        }
    }
    _flushTexture() {
        const naturalWidth = this.texture.image.naturalWidth || 0;
        const naturalHeight = this.texture.image.naturalHeight || 0;
        this._spriteCtx.clearRect(0, 0, this.width, this.height);
        this._spriteCtx.drawImage(this.texture.image, clamp(this.x, 0, naturalWidth), clamp(this.y, 0, naturalHeight), clamp(this.width, 0, naturalWidth), clamp(this.height, 0, naturalHeight), 0, 0, this.width, this.height);
    }
    /**
     * Applies the [[Opacity]] effect to a sprite, setting the alpha of all pixels to a given value
     */
    opacity(value) {
        this._opacity = value;
    }
    /**
     * Applies the [[Grayscale]] effect to a sprite, removing color information.
     */
    grayscale() {
        this.addEffect(new Grayscale());
    }
    /**
     * Applies the [[Invert]] effect to a sprite, inverting the pixel colors.
     */
    invert() {
        this.addEffect(new Invert());
    }
    /**
     * Applies the [[Fill]] effect to a sprite, changing the color channels of all non-transparent pixels to match a given color
     */
    fill(color) {
        this.addEffect(new Fill(color));
    }
    /**
     * Applies the [[Colorize]] effect to a sprite, changing the color channels of all pixels to be the average of the original color
     * and the provided color.
     */
    colorize(color) {
        this.addEffect(new Colorize(color));
    }
    /**
     * Applies the [[Lighten]] effect to a sprite, changes the lightness of the color according to HSL
     */
    lighten(factor = 0.1) {
        this.addEffect(new Lighten(factor));
    }
    /**
     * Applies the [[Darken]] effect to a sprite, changes the darkness of the color according to HSL
     */
    darken(factor = 0.1) {
        this.addEffect(new Darken(factor));
    }
    /**
     * Applies the [[Saturate]] effect to a sprite, saturates the color according to HSL
     */
    saturate(factor = 0.1) {
        this.addEffect(new Saturate(factor));
    }
    /**
     * Applies the [[Desaturate]] effect to a sprite, desaturates the color according to HSL
     */
    desaturate(factor = 0.1) {
        this.addEffect(new Desaturate(factor));
    }
    /**
     * Adds a new [[SpriteEffect]] to this drawing.
     * @param effect  Effect to add to the this drawing
     */
    addEffect(effect) {
        this.effects.push(effect);
        // We must check if the texture and the backing sprite pixels are loaded as well before
        // an effect can be applied
        if (!this.texture.isLoaded() || !this._pixelsLoaded) {
            this._dirtyEffect = true;
        }
        else {
            this._applyEffects();
        }
    }
    removeEffect(param) {
        let indexToRemove = -1;
        if (typeof param === 'number') {
            indexToRemove = param;
        }
        else {
            indexToRemove = this.effects.indexOf(param);
        }
        // bounds check
        if (indexToRemove < 0 || indexToRemove >= this.effects.length) {
            return;
        }
        this.effects.splice(indexToRemove, 1);
        // We must check if the texture and the backing sprite pixels are loaded as well before
        // an effect can be applied
        if (!this.texture.isLoaded() || !this._pixelsLoaded) {
            this._dirtyEffect = true;
        }
        else {
            this._applyEffects();
        }
    }
    _applyEffects() {
        this._flushTexture();
        if (this.effects.length > 0) {
            this._pixelData = this._spriteCtx.getImageData(0, 0, this.width, this.height);
            const len = this.effects.length;
            for (let i = 0; i < len; i++) {
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        this.effects[i].updatePixel(x, y, this._pixelData);
                    }
                }
            }
            this._spriteCtx.clearRect(0, 0, this.width, this.height);
            this._spriteCtx.putImageData(this._pixelData, 0, 0);
        }
        this._dirtyEffect = false;
    }
    /**
     * Clears all effects from the drawing and return it to its original state.
     */
    clearEffects() {
        this.effects.length = 0;
        this._applyEffects();
    }
    /**
     * Resets the internal state of the drawing (if any)
     */
    reset() {
        // do nothing
    }
    debugDraw(ctx, x, y) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(this.rotation);
        const xpoint = this.drawWidth * this.anchor.x;
        const ypoint = this.drawHeight * this.anchor.y;
        ctx.strokeStyle = Color.Black.toString();
        ctx.strokeRect(-xpoint, -ypoint, this.drawWidth, this.drawHeight);
        ctx.restore();
    }
    draw(ctxOrOptions, x, y) {
        if (ctxOrOptions instanceof CanvasRenderingContext2D) {
            this._drawWithOptions({ ctx: ctxOrOptions, x, y });
        }
        else {
            this._drawWithOptions(ctxOrOptions);
        }
    }
    _drawWithOptions(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const { ctx, x, y, rotation, drawWidth, drawHeight, anchor, offset, opacity, flipHorizontal, flipVertical } = Object.assign(Object.assign({}, options), { rotation: (_a = options.rotation) !== null && _a !== void 0 ? _a : this.rotation, drawWidth: (_b = options.drawWidth) !== null && _b !== void 0 ? _b : this.width, drawHeight: (_c = options.drawHeight) !== null && _c !== void 0 ? _c : this.height, flipHorizontal: (_d = options.flipHorizontal) !== null && _d !== void 0 ? _d : this.flipHorizontal, flipVertical: (_e = options.flipVertical) !== null && _e !== void 0 ? _e : this.flipVertical, anchor: (_f = options.anchor) !== null && _f !== void 0 ? _f : this.anchor, offset: (_g = options.offset) !== null && _g !== void 0 ? _g : this.offset, opacity: ((_h = options.opacity) !== null && _h !== void 0 ? _h : 1) * ((_j = this._opacity) !== null && _j !== void 0 ? _j : 1) });
        if (this._dirtyEffect) {
            this._applyEffects();
        }
        // calculating current dimensions
        const anchorX = drawWidth * anchor.x + offset.x;
        const anchorY = drawHeight * anchor.y + offset.y;
        const scaleDirX = this.scale.x > 0 ? 1 : -1;
        const scaleDirY = this.scale.y > 0 ? 1 : -1;
        ctx.save();
        // Move the draw point of origin
        ctx.translate(x, y);
        // Rotate and scale around anchor point
        // This requires a bit of explaination, scale coordinates first positive flipping or rotating
        ctx.scale(Math.abs(this.scale.x), Math.abs(this.scale.y));
        if (this.drawAroundAnchor) {
            // In the case where you want the anchor to match with the point of draw
            // Otherwise sprites are always drawn from top-left
            ctx.translate(-anchorX, -anchorY);
        }
        ctx.translate(anchorX, anchorY);
        ctx.rotate(rotation);
        // This is for handling direction changes 1 or -1, that way we don't have mismatched translates()
        ctx.scale(scaleDirX, scaleDirY);
        ctx.translate(-anchorX, -anchorY);
        if (flipHorizontal) {
            ctx.translate(drawWidth, 0);
            ctx.scale(-1, 1);
        }
        if (flipVertical) {
            ctx.translate(0, drawHeight);
            ctx.scale(1, -1);
        }
        const oldAlpha = ctx.globalAlpha;
        ctx.globalAlpha = opacity;
        // Context is already rotated and scaled
        ctx.drawImage(this._spriteCanvas, 0, 0, this.width, this.height, // source
        0, 0, this.width, this.height); // dest
        ctx.globalAlpha = oldAlpha;
        ctx.restore();
    }
    /**
     * Produces a copy of the current sprite
     */
    clone() {
        const result = new Sprite_Sprite(this.texture, this.x, this.y, this.width, this.height);
        result.anchor = this.anchor.clone();
        result.scale = this.scale.clone();
        result.rotation = this.rotation;
        result.flipHorizontal = this.flipHorizontal;
        result.flipVertical = this.flipVertical;
        const len = this.effects.length;
        for (let i = 0; i < len; i++) {
            result.addEffect(this.effects[i]);
        }
        return result;
    }
}
/**
 * A [[LegacyDrawing.Sprite]] is one of the main drawing primitives. It is responsible for drawing
 * images or parts of images from a [[LegacyDrawing.Texture]] resource to the screen.
 * @deprecated Use [[Sprite]]
 */
let Sprite_Sprite = class Sprite extends Configurable(SpriteImpl) {
    constructor(imageOrConfig, x, y, width, height) {
        super(imageOrConfig, x, y, width, height);
    }
};
Sprite_Sprite = Sprite_decorate([
    obsolete({
        message: 'Label.clearTextShadow will be removed in v0.26.0',
        alternateMethod: 'Use Label.font.shadow'
    })
], Sprite_Sprite);


;// CONCATENATED MODULE: ./Graphics/Sprite.ts




class Sprite extends Graphic {
    constructor(options) {
        var _a, _b;
        super(options);
        this.image = options.image;
        const { width, height } = options;
        this.sourceView = (_a = options.sourceView) !== null && _a !== void 0 ? _a : { x: 0, y: 0, width: width !== null && width !== void 0 ? width : 0, height: height !== null && height !== void 0 ? height : 0 };
        this.destSize = (_b = options.destSize) !== null && _b !== void 0 ? _b : { width: width !== null && width !== void 0 ? width : 0, height: height !== null && height !== void 0 ? height : 0 };
        this._updateSpriteDimensions();
        this.image.ready.then(() => {
            this._updateSpriteDimensions();
        });
    }
    static from(image) {
        return new Sprite({
            image: image
        });
    }
    _updateSpriteDimensions() {
        var _a, _b, _c, _d, _e, _f;
        const { width: nativeWidth, height: nativeHeight } = this.image;
        // This code uses || to avoid 0's
        // If the source is not specified, use the native dimension
        this.sourceView.width = ((_a = this.sourceView) === null || _a === void 0 ? void 0 : _a.width) || nativeWidth;
        this.sourceView.height = ((_b = this.sourceView) === null || _b === void 0 ? void 0 : _b.height) || nativeHeight;
        // If the destination is not specified, use the source if specified, then native
        this.destSize.width = ((_c = this.destSize) === null || _c === void 0 ? void 0 : _c.width) || ((_d = this.sourceView) === null || _d === void 0 ? void 0 : _d.width) || nativeWidth;
        this.destSize.height = ((_e = this.destSize) === null || _e === void 0 ? void 0 : _e.height) || ((_f = this.sourceView) === null || _f === void 0 ? void 0 : _f.height) || nativeHeight;
        this.width = Math.ceil(this.destSize.width);
        this.height = Math.ceil(this.destSize.height);
    }
    _preDraw(ex, x, y) {
        if (this.image.isLoaded()) {
            this._updateSpriteDimensions();
        }
        super._preDraw(ex, x, y);
    }
    _drawImage(ex, x, y) {
        if (this.image.isLoaded()) {
            this._updateSpriteDimensions();
            ex.drawImage(this.image.image, this.sourceView.x, this.sourceView.y, this.sourceView.width, this.sourceView.height, x, y, this.destSize.width, this.destSize.height);
        }
    }
    /**
     * Create a ImageSource from legacy texture
     * @param sprite
     */
    static fromLegacySprite(sprite) {
        const tex = sprite.texture;
        const image = ImageSource.fromLegacyTexture(tex);
        return new Sprite({
            image,
            sourceView: {
                x: sprite.x,
                y: sprite.y,
                width: sprite.width,
                height: sprite.height
            }
        });
    }
    /**
     * Converts a sprite to a Legacy sprite
     * @deprecated
     * @param sprite
     * @returns LegacyDrawing.Sprite
     */
    static toLegacySprite(sprite) {
        const image = sprite.image;
        const tex = new Texture(image.path);
        tex.data = image.image;
        return new Sprite_Sprite(tex, sprite.sourceView.x, sprite.sourceView.y, sprite.sourceView.width, sprite.sourceView.height);
    }
    clone() {
        return new Sprite(Object.assign({ image: this.image, sourceView: Object.assign({}, this.sourceView), destSize: Object.assign({}, this.destSize) }, this.cloneGraphicOptions()));
    }
}

;// CONCATENATED MODULE: ./Graphics/ImageSource.ts
var ImageSource_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



class ImageSource {
    /**
     * The path to the image, can also be a data url like 'data:image/'
     * @param path
     */
    constructor(path, bustCache = false) {
        this.path = path;
        this._logger = Logger.getInstance();
        /**
         * Access to the underlying html image elmeent
         */
        this.data = new Image();
        this._resource = new Resource(path, 'blob', bustCache);
        if (path.endsWith('.svg') || path.endsWith('.gif')) {
            this._logger.warn(`Image type is not fully supported, you may have mixed results ${path}. Fully supported: jpg, bmp, and png`);
        }
        this.ready = new Promise((resolve) => {
            this._loadedResolve = resolve;
        });
    }
    /**
     * The original size of the source image in pixels
     */
    get width() {
        return this.image.naturalWidth;
    }
    /**
     * The original height of the source image in pixels
     */
    get height() {
        return this.image.naturalHeight;
    }
    /**
     * Returns true if the Texture is completely loaded and is ready
     * to be drawn.
     */
    isLoaded() {
        return !!this.data.src;
    }
    get image() {
        return this.data;
    }
    /**
     * Begins loading the image and returns a promise that resolves when the image is loaded
     */
    load() {
        return ImageSource_awaiter(this, void 0, void 0, function* () {
            if (this.isLoaded()) {
                return this.data;
            }
            try {
                // Load base64 or blob if needed
                let url;
                if (!this.path.includes('data:image/')) {
                    const blob = yield this._resource.load();
                    url = URL.createObjectURL(blob);
                }
                else {
                    url = this.path;
                }
                // Decode the image
                const image = new Image();
                image.src = url;
                yield image.decode();
                // Set results
                this.data = image;
            }
            catch (error) {
                throw `Error loading ImageSource from path '${this.path}' with error [${error.message}]`;
            }
            // todo emit complete
            this._loadedResolve(this.data);
            return this.data;
        });
    }
    /**
     * Build a sprite from this ImageSource
     */
    toSprite() {
        return Sprite.from(this);
    }
    /**
     * Create a ImageSource from legacy texture
     * @param tex
     */
    static fromLegacyTexture(tex) {
        const image = new ImageSource(tex.path);
        if (tex.isLoaded()) {
            image.data = tex.data;
        }
        else {
            tex.loaded.then(() => {
                image.data = tex.data;
            });
        }
        return image;
    }
    /**
     * Unload images from memory
     */
    unload() {
        this.data = new Image();
    }
}

;// CONCATENATED MODULE: ./Drawing/Animation.ts
var Animation_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};






/**
 * @hidden
 * @deprecated Use [[Animation]]
 */
class AnimationImpl {
    /**
     * Typically you will use a [[SpriteSheet]] to generate an [[Animation]].
     *
     * @param engineOrConfig  Reference to the current game engine
     * @param sprites  An array of sprites to create the frames for the animation
     * @param speed   The number in milliseconds to display each frame in the animation
     * @param loop    Indicates whether the animation should loop after it is completed
     */
    constructor(engineOrConfig, sprites, speed, loop) {
        /**
         * The sprite frames to play, in order. See [[SpriteSheet.getAnimationForAll]] to quickly
         * generate an [[Animation]].
         */
        this.sprites = [];
        /**
         * Current frame index being shown
         */
        this.currentFrame = 0;
        this._timeLeftInFrame = 0;
        this._idempotencyToken = -1;
        this.anchor = Vector.Zero;
        this.rotation = 0.0;
        this.scale = Vector.One;
        /**
         * Indicates whether the animation should loop after it is completed
         */
        this.loop = true;
        /**
         * Indicates the frame index the animation should freeze on for a non-looping
         * animation. By default it is the last frame.
         */
        this.freezeFrame = -1;
        /**
         * Flip each frame vertically. Sets [[Sprite.flipVertical]].
         */
        this.flipVertical = false;
        /**
         * Flip each frame horizontally. Sets [[Sprite.flipHorizontal]].
         */
        this.flipHorizontal = false;
        this.drawWidth = 0;
        this.drawHeight = 0;
        this.width = 0;
        this.height = 0;
        this._opacity = 1;
        let engine = engineOrConfig;
        if (engineOrConfig && !(engineOrConfig instanceof Engine)) {
            const config = engineOrConfig;
            engine = config.engine;
            sprites = config.sprites;
            speed = config.speed;
            loop = config.loop;
        }
        this.sprites = sprites;
        this.speed = speed;
        this._engine = engine;
        this._timeLeftInFrame = this.speed;
        if (loop != null) {
            this.loop = loop;
        }
        if (sprites && sprites[0]) {
            this.drawHeight = sprites[0] ? sprites[0].drawHeight : 0;
            this.drawWidth = sprites[0] ? sprites[0].drawWidth : 0;
            this.width = sprites[0] ? sprites[0].width : 0;
            this.height = sprites[0] ? sprites[0].height : 0;
            this.freezeFrame = sprites.length - 1;
        }
    }
    /**
     * Applies the opacity effect to a sprite, setting the alpha of all pixels to a given value
     */
    opacity(value) {
        this._opacity = value;
    }
    /**
     * Applies the grayscale effect to a sprite, removing color information.
     */
    grayscale() {
        this.addEffect(new Grayscale());
    }
    /**
     * Applies the invert effect to a sprite, inverting the pixel colors.
     */
    invert() {
        this.addEffect(new Invert());
    }
    /**
     * Applies the fill effect to a sprite, changing the color channels of all non-transparent pixels to match a given color
     */
    fill(color) {
        this.addEffect(new Fill(color));
    }
    /**
     * Applies the colorize effect to a sprite, changing the color channels of all pixels to be the average of the original color and the
     * provided color.
     */
    colorize(color) {
        this.addEffect(new Colorize(color));
    }
    /**
     * Applies the lighten effect to a sprite, changes the lightness of the color according to hsl
     */
    lighten(factor = 0.1) {
        this.addEffect(new Lighten(factor));
    }
    /**
     * Applies the darken effect to a sprite, changes the darkness of the color according to hsl
     */
    darken(factor = 0.1) {
        this.addEffect(new Darken(factor));
    }
    /**
     * Applies the saturate effect to a sprite, saturates the color according to hsl
     */
    saturate(factor = 0.1) {
        this.addEffect(new Saturate(factor));
    }
    /**
     * Applies the desaturate effect to a sprite, desaturates the color according to hsl
     */
    desaturate(factor = 0.1) {
        this.addEffect(new Desaturate(factor));
    }
    /**
     * Add a [[SpriteEffect]] manually
     */
    addEffect(effect) {
        for (const i in this.sprites) {
            this.sprites[i].addEffect(effect);
        }
    }
    removeEffect(param) {
        for (const i in this.sprites) {
            this.sprites[i].removeEffect(param);
        }
    }
    /**
     * Clear all sprite effects
     */
    clearEffects() {
        for (const i in this.sprites) {
            this.sprites[i].clearEffects();
        }
    }
    _setAnchor(point) {
        //if (!this.anchor.equals(point)) {
        for (const i in this.sprites) {
            this.sprites[i].anchor.setTo(point.x, point.y);
        }
        //}
    }
    _setRotation(radians) {
        //if (this.rotation !== radians) {
        for (const i in this.sprites) {
            this.sprites[i].rotation = radians;
        }
        //}
    }
    _setScale(scale) {
        //if (!this.scale.equals(scale)) {
        for (const i in this.sprites) {
            this.sprites[i].scale = scale;
        }
        //}
    }
    /**
     * Resets the animation to first frame.
     */
    reset() {
        this.currentFrame = 0;
    }
    /**
     * Indicates whether the animation is complete, animations that loop are never complete.
     */
    isDone() {
        return !this.loop && this.currentFrame >= this.sprites.length;
    }
    /**
     * Not meant to be called by game developers. Ticks the animation forward internally and
     * calculates whether to change to the frame.
     * @internal
     */
    tick(elapsed, idempotencyToken) {
        if (this._idempotencyToken === idempotencyToken) {
            return;
        }
        this._idempotencyToken = idempotencyToken;
        this._timeLeftInFrame -= elapsed;
        if (this._timeLeftInFrame <= 0) {
            this.currentFrame = this.loop ? (this.currentFrame + 1) % this.sprites.length : this.currentFrame + 1;
            this._timeLeftInFrame = this.speed;
        }
        this._updateValues();
        const current = this.sprites[this.currentFrame];
        if (current) {
            this.width = current.width;
            this.height = current.height;
            this.drawWidth = current.drawWidth;
            this.drawHeight = current.drawHeight;
        }
    }
    _updateValues() {
        this._setAnchor(this.anchor);
        this._setRotation(this.rotation);
        this._setScale(this.scale);
    }
    /**
     * Skips ahead a specified number of frames in the animation
     * @param frames  Frames to skip ahead
     */
    skip(frames) {
        this.currentFrame = (this.currentFrame + frames) % this.sprites.length;
    }
    draw(ctxOrOptions, x, y) {
        if (ctxOrOptions instanceof CanvasRenderingContext2D) {
            this._drawWithOptions({ ctx: ctxOrOptions, x, y });
        }
        else {
            this._drawWithOptions(ctxOrOptions);
        }
    }
    _drawWithOptions(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const animOptions = Object.assign(Object.assign({}, options), { rotation: (_a = options.rotation) !== null && _a !== void 0 ? _a : this.rotation, drawWidth: (_b = options.drawWidth) !== null && _b !== void 0 ? _b : this.drawWidth, drawHeight: (_c = options.drawHeight) !== null && _c !== void 0 ? _c : this.drawHeight, flipHorizontal: (_d = options.flipHorizontal) !== null && _d !== void 0 ? _d : this.flipHorizontal, flipVertical: (_e = options.flipVertical) !== null && _e !== void 0 ? _e : this.flipVertical, anchor: (_f = options.anchor) !== null && _f !== void 0 ? _f : this.anchor, opacity: ((_g = options.opacity) !== null && _g !== void 0 ? _g : 1) * ((_h = this._opacity) !== null && _h !== void 0 ? _h : 1) });
        this._updateValues();
        let currSprite;
        if (this.currentFrame < this.sprites.length) {
            currSprite = this.sprites[this.currentFrame];
            currSprite.draw(animOptions);
        }
        if (this.freezeFrame !== -1 && this.currentFrame >= this.sprites.length) {
            currSprite = this.sprites[clamp(this.freezeFrame, 0, this.sprites.length - 1)];
            currSprite.draw(animOptions);
        }
        // add the calculated width
        if (currSprite) {
            this.drawWidth = currSprite.drawWidth;
            this.drawHeight = currSprite.drawHeight;
        }
    }
    /**
     * Plays an animation at an arbitrary location in the game.
     * @param x  The x position in the game to play
     * @param y  The y position in the game to play
     */
    play(x, y) {
        this.reset();
        this._engine.playAnimation(this, x, y);
    }
}
/**
 * Animations allow you to display a series of images one after another,
 * creating the illusion of change. Generally these images will come from a [[SpriteSheet]] source.
 * @deprecated Use [[Animation]]
 */
let Animation_Animation = class Animation extends Configurable(AnimationImpl) {
    constructor(engineOrConfig, images, speed, loop) {
        super(engineOrConfig, images, speed, loop);
    }
};
Animation_Animation = Animation_decorate([
    obsolete({
        message: 'Animation will be removed in v0.26.0',
        alternateMethod: 'Use Graphics.Animation'
    })
], Animation_Animation);


;// CONCATENATED MODULE: ./Graphics/FontCommon.ts
/**
 * Enum representing the different font size units
 * https://developer.mozilla.org/en-US/docs/Web/CSS/font-size
 */
var FontUnit;
(function (FontUnit) {
    /**
     * Em is a scalable unit, 1 em is equal to the current font size of the current element, parent elements can effect em values
     */
    FontUnit["Em"] = "em";
    /**
     * Rem is similar to the Em, it is a scalable unit. 1 rem is equal to the font size of the root element
     */
    FontUnit["Rem"] = "rem";
    /**
     * Pixel is a unit of length in screen pixels
     */
    FontUnit["Px"] = "px";
    /**
     * Point is a physical unit length (1/72 of an inch)
     */
    FontUnit["Pt"] = "pt";
    /**
     * Percent is a scalable unit similar to Em, the only difference is the Em units scale faster when Text-Size stuff
     */
    FontUnit["Percent"] = "%";
})(FontUnit || (FontUnit = {}));
/**
 * Enum representing the different horizontal text alignments
 */
var TextAlign;
(function (TextAlign) {
    /**
     * The text is left-aligned.
     */
    TextAlign["Left"] = "left";
    /**
     * The text is right-aligned.
     */
    TextAlign["Right"] = "right";
    /**
     * The text is centered.
     */
    TextAlign["Center"] = "center";
    /**
     * The text is aligned at the normal start of the line (left-aligned for left-to-right locales,
     * right-aligned for right-to-left locales).
     */
    TextAlign["Start"] = "start";
    /**
     * The text is aligned at the normal end of the line (right-aligned for left-to-right locales,
     * left-aligned for right-to-left locales).
     */
    TextAlign["End"] = "end";
})(TextAlign || (TextAlign = {}));
/**
 * Enum representing the different baseline text alignments
 */
var BaseAlign;
(function (BaseAlign) {
    /**
     * The text baseline is the top of the em square.
     */
    BaseAlign["Top"] = "top";
    /**
     * The text baseline is the hanging baseline.  Currently unsupported; this will act like
     * alphabetic.
     */
    BaseAlign["Hanging"] = "hanging";
    /**
     * The text baseline is the middle of the em square.
     */
    BaseAlign["Middle"] = "middle";
    /**
     * The text baseline is the normal alphabetic baseline.
     */
    BaseAlign["Alphabetic"] = "alphabetic";
    /**
     * The text baseline is the ideographic baseline; this is the bottom of
     * the body of the characters, if the main body of characters protrudes
     * beneath the alphabetic baseline.  Currently unsupported; this will
     * act like alphabetic.
     */
    BaseAlign["Ideographic"] = "ideographic";
    /**
     * The text baseline is the bottom of the bounding box.  This differs
     * from the ideographic baseline in that the ideographic baseline
     * doesn't consider descenders.
     */
    BaseAlign["Bottom"] = "bottom";
})(BaseAlign || (BaseAlign = {}));
/**
 * Enum representing the different possible font styles
 */
var FontStyle;
(function (FontStyle) {
    FontStyle["Normal"] = "normal";
    FontStyle["Italic"] = "italic";
    FontStyle["Oblique"] = "oblique";
})(FontStyle || (FontStyle = {}));
var Direction;
(function (Direction) {
    Direction["LeftToRight"] = "ltr";
    Direction["RightToLeft"] = "rtl";
})(Direction || (Direction = {}));

;// CONCATENATED MODULE: ./Drawing/SpriteSheet.ts
var SpriteSheet_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};









/**
 * Sprite sheets are a useful mechanism for slicing up image resources into
 * separate sprites or for generating in game animations. [[Sprite|Sprites]] are organized
 * in row major order in the [[SpriteSheet]].
 * @deprecated Will be removed in v0.26.0
 */
class SpriteSheet_SpriteSheet {
    /**
     * @param imageOrConfigOrSprites The backing image texture to build the SpriteSheet, option bag, or sprite list
     * @param columns   The number of columns in the image texture
     * @param rows      The number of rows in the image texture
     * @param spWidth   The width of each individual sprite in pixels
     * @param spHeight  The height of each individual sprite in pixels
     * @param spacing   The spacing between every sprite in a spritesheet
     */
    constructor(imageOrConfigOrSprites, columns, rows, spWidth, spHeight, spacing) {
        this._sprites = [];
        this._image = null;
        this._columns = 0;
        this._rows = 0;
        this._spWidth = 0;
        this._spHeight = 0;
        this._spacing = 0;
        let loadFromImage = false;
        if (imageOrConfigOrSprites instanceof Array) {
            this._sprites = imageOrConfigOrSprites;
        }
        else {
            if (imageOrConfigOrSprites && !(imageOrConfigOrSprites instanceof Texture)) {
                this._columns = imageOrConfigOrSprites.columns;
                this._rows = imageOrConfigOrSprites.rows;
                this._spWidth = imageOrConfigOrSprites.spWidth;
                this._spHeight = imageOrConfigOrSprites.spHeight;
                this._image = imageOrConfigOrSprites.image;
                this._spacing = imageOrConfigOrSprites.spacing || 0;
            }
            else {
                this._image = imageOrConfigOrSprites;
                this._columns = columns;
                this._rows = rows;
                this._spWidth = spWidth;
                this._spHeight = spHeight;
                this._spacing = spacing || 0;
            }
            this._sprites = new Array(this._columns * this._rows);
            loadFromImage = true;
        }
        // Inspect actual image dimensions with preloading
        if (this.image instanceof Texture) {
            let isWidthError = false;
            let isHeightError = false;
            if (this.image.isLoaded()) {
                isWidthError = this.spWidth * this.columns > this.image.image.naturalWidth;
                isHeightError = this.spHeight * this.rows > this.image.image.naturalHeight;
                if (isWidthError) {
                    throw new RangeError(`SpriteSheet specified is wider, ` +
                        `${this.columns} cols x ${this.spWidth} pixels > ${this.image.image.naturalWidth} ` +
                        `pixels than image width`);
                }
                if (isHeightError) {
                    throw new RangeError(`SpriteSheet specified is taller, ` +
                        `${this.rows} rows x ${this.spHeight} pixels > ${this.image.image.naturalHeight} ` +
                        `pixels than image height`);
                }
            }
        }
        if (loadFromImage) {
            const spacing = this.getSpacingDimensions();
            for (let row = 0; row < this.rows; row++) {
                for (let col = 0; col < this.columns; col++) {
                    this._sprites[col + row * this.columns] = new Sprite_Sprite(this.image, col * this.spWidth + spacing.margin * col + spacing.left, row * this.spHeight + spacing.margin * row + spacing.top, this.spWidth, this.spHeight);
                }
            }
        }
    }
    /**
     * Gets the raw spacing dimensions for the sprites in the sheet, which can be a fixed number or custom dimensions.
     */
    get spacing() {
        return this._spacing;
    }
    /**
     * Get a copy of the backing sprite array
     */
    get sprites() {
        return [...this._sprites];
    }
    /**
     * The backing texture used for the sprite sheet
     */
    get image() {
        return this._image;
    }
    /**
     * The number of columns in the sheet
     */
    get columns() {
        return this._columns;
    }
    /**
     * The number of rows in the sheet
     */
    get rows() {
        return this._rows;
    }
    /**
     * The width of the individual sprites
     */
    get spWidth() {
        return this._spWidth;
    }
    /**
     * The height of the individual sprites
     */
    get spHeight() {
        return this._spHeight;
    }
    /**
     * Gets the calculated spacing dimensions based on whether spacing
     * is a fixed number or has different values for each dimension
     */
    getSpacingDimensions() {
        var _a, _b, _c;
        if (typeof this.spacing === 'number') {
            return {
                left: this.spacing,
                top: this.spacing,
                margin: this.spacing
            };
        }
        else {
            return {
                left: (_a = this.spacing.left) !== null && _a !== void 0 ? _a : 0,
                top: (_b = this.spacing.top) !== null && _b !== void 0 ? _b : 0,
                margin: (_c = this.spacing.margin) !== null && _c !== void 0 ? _c : 0
            };
        }
    }
    /**
     * Create an animation from the this SpriteSheet by listing out the
     * sprite indices. Sprites are organized in row major order in the SpriteSheet.
     * @param engine   Reference to the current game [[Engine]]
     * @param indices  An array of sprite indices to use in the animation
     * @param speed    The number in milliseconds to display each frame in the animation
     */
    getAnimationByIndices(engine, indices, speed) {
        let images = indices.map((index) => {
            return this.sprites[index];
        });
        images = images.map(function (i) {
            return i.clone();
        });
        return new Animation_Animation(engine, images, speed);
    }
    /**
     * Create an animation from the this SpriteSheet by specifying the range of
     * images with the beginning (inclusive) and ending (exclusive) index
     * For example `getAnimationBetween(engine, 0, 5, 200)` returns an animation with 5 frames.
     * @param engine      Reference to the current game Engine
     * @param beginIndex  The index to start taking frames (inclusive)
     * @param endIndex    The index to stop taking frames (exclusive)
     * @param speed       The number in milliseconds to display each frame in the animation
     */
    getAnimationBetween(engine, beginIndex, endIndex, speed) {
        let images = this.sprites.slice(beginIndex, endIndex);
        images = images.map(function (i) {
            return i.clone();
        });
        return new Animation_Animation(engine, images, speed);
    }
    /**
     * Treat the entire SpriteSheet as one animation, organizing the frames in
     * row major order.
     * @param engine  Reference to the current game [[Engine]]
     * @param speed   The number in milliseconds to display each frame the animation
     */
    getAnimationForAll(engine, speed) {
        const sprites = this.sprites.map(function (i) {
            return i.clone();
        });
        return new Animation_Animation(engine, sprites, speed);
    }
    /**
     * Retrieve a specific sprite from the SpriteSheet by its index. Sprites are organized
     * in row major order in the SpriteSheet.
     * @param index  The index of the sprite
     */
    getSprite(index) {
        if (index >= 0 && index < this.sprites.length) {
            return this.sprites[index];
        }
        else {
            throw new Error('Invalid index: ' + index);
        }
    }
    /**
     * Get an animation with bespoke sprite coordinates. This is useful if the SpriteSheet is
     * packed and not a uniform width or height. The resulting [[Animation]] will have the height and width of the
     * largest dimension (width, height) from among the sprite coordinates
     * @param engine
     * @param spriteCoordinates
     * @param speed
     */
    getAnimationByCoords(engine, spriteCoordinates, speed) {
        let maxWidth = 0;
        let maxHeight = 0;
        const sprites = new Array(spriteCoordinates.length);
        for (let i = 0; i < spriteCoordinates.length; i++) {
            const coord = spriteCoordinates[i];
            // no need to pass image again if using a spritesheet
            coord.image = coord.image || this.image;
            maxWidth = Math.max(maxWidth, coord.drawWidth);
            maxHeight = Math.max(maxHeight, coord.drawHeight);
            sprites[i] = new Sprite_Sprite(coord);
        }
        const anim = new Animation_Animation(engine, sprites, speed);
        anim.drawWidth = maxWidth;
        anim.drawHeight = maxHeight;
        return anim;
    }
}
/**
 * Sprite fonts are a used in conjunction with a [[Label]] to specify
 * a particular bitmap as a font. Note that some font features are not
 * supported by Sprite fonts.
 * @deprecated Will be removed into v0.26.0
 */
let SpriteFont = class SpriteFont extends SpriteSheet_SpriteSheet {
    /**
     * @param imageOrConfig   The backing image texture to build the SpriteFont or the sprite font option bag
     * @param alphabet        A string representing all the characters in the image, in row major order.
     * @param caseInsensitive  Indicate whether this font takes case into account
     * @param columns         The number of columns of characters in the image
     * @param rows            The number of rows of characters in the image
     * @param spWidth         The width of each character in pixels
     * @param spHeight        The height of each character in pixels
     */
    constructor(imageOrConfig, alphabet, caseInsensitive, columns, rows, spWidth, spHeight, spacing) {
        super(imageOrConfig instanceof Texture
            ? {
                image: imageOrConfig,
                spWidth: spWidth,
                spHeight: spHeight,
                rows: rows,
                columns: columns,
                spacing: spacing || 0
            }
            : imageOrConfig);
        this._currentColor = Color.Black;
        this._currentOpacity = 1.0;
        this._spriteRecord = {};
        // text shadow
        this._textShadowOn = false;
        this._textShadowDirty = true;
        this._textShadowColor = Color.Black;
        this._textShadowSprites = {};
        this._shadowOffsetX = 5;
        this._shadowOffsetY = 5;
        if (imageOrConfig && !(imageOrConfig instanceof Texture)) {
            alphabet = imageOrConfig.alphabet;
            caseInsensitive = imageOrConfig.caseInsensitive;
        }
        this.alphabet = alphabet;
        this.caseInsensitive = caseInsensitive;
        this._spriteRecord = this.getTextSprites();
    }
    /**
     * Returns a dictionary that maps each character in the alphabet to the appropriate [[Sprite]].
     */
    getTextSprites() {
        const lookup = {};
        for (let i = 0; i < this.alphabet.length; i++) {
            let char = this.alphabet[i];
            if (this.caseInsensitive) {
                char = char.toLowerCase();
            }
            lookup[char] = this.sprites[i].clone();
        }
        return lookup;
    }
    /**
     * Sets the text shadow for sprite fonts
     * @param offsetX      The x offset in pixels to place the shadow
     * @param offsetY      The y offset in pixels to place the shadow
     * @param shadowColor  The color of the text shadow
     */
    setTextShadow(offsetX, offsetY, shadowColor) {
        this._textShadowOn = true;
        this._shadowOffsetX = offsetX;
        this._shadowOffsetY = offsetY;
        this._textShadowColor = shadowColor.clone();
        this._textShadowDirty = true;
        for (const character in this._spriteRecord) {
            this._textShadowSprites[character] = this._spriteRecord[character].clone();
        }
    }
    /**
     * Toggles text shadows on or off
     */
    useTextShadow(on) {
        this._textShadowOn = on;
        if (on) {
            this.setTextShadow(5, 5, this._textShadowColor);
        }
    }
    /**
     * Draws the current sprite font
     */
    draw(ctx, text, x, y, options) {
        options = this._parseOptions(options);
        if (this._currentColor.toString() !== options.color.toString() || this._currentOpacity !== options.opacity) {
            this._currentOpacity = options.opacity;
            this._currentColor = options.color;
            for (const char in this._spriteRecord) {
                this._spriteRecord[char].clearEffects();
                this._spriteRecord[char].fill(options.color);
                this._spriteRecord[char].opacity(options.opacity);
            }
        }
        if (this._textShadowOn && this._textShadowDirty && this._textShadowColor) {
            for (const characterShadow in this._textShadowSprites) {
                this._textShadowSprites[characterShadow].clearEffects();
                this._textShadowSprites[characterShadow].addEffect(new Fill(this._textShadowColor.clone()));
            }
            this._textShadowDirty = false;
        }
        // find the current length of text in pixels
        const sprite = this.sprites[0];
        // find the current height fo the text in pixels
        const height = sprite.height;
        // calculate appropriate scale for font size
        const scale = options.fontSize / height;
        const length = text.length * sprite.width * scale + text.length * options.letterSpacing;
        let currX = x;
        if (options.textAlign === TextAlign.Left || options.textAlign === TextAlign.Start) {
            currX = x;
        }
        else if (options.textAlign === TextAlign.Right || options.textAlign === TextAlign.End) {
            currX = x - length;
        }
        else if (options.textAlign === TextAlign.Center) {
            currX = x - length / 2;
        }
        let currY = y - height * scale;
        if (options.baseAlign === BaseAlign.Top || options.baseAlign === BaseAlign.Hanging) {
            currY = y;
        }
        else if (options.baseAlign === BaseAlign.Ideographic ||
            options.baseAlign === BaseAlign.Bottom ||
            options.baseAlign === BaseAlign.Alphabetic) {
            currY = y - height * scale;
        }
        else if (options.baseAlign === BaseAlign.Middle) {
            currY = y - (height * scale) / 2;
        }
        for (let i = 0; i < text.length; i++) {
            let character = text[i];
            if (this.caseInsensitive) {
                character = character.toLowerCase();
            }
            try {
                // if text shadow
                if (this._textShadowOn) {
                    this._textShadowSprites[character].drawAroundAnchor = false;
                    this._textShadowSprites[character].scale = vec(scale, scale);
                    this._textShadowSprites[character].draw(ctx, currX + this._shadowOffsetX, currY + this._shadowOffsetY);
                }
                const charSprite = this._spriteRecord[character];
                charSprite.drawAroundAnchor = false;
                charSprite.scale = vec(scale, scale);
                charSprite.draw(ctx, currX, currY);
                currX += charSprite.drawWidth + options.letterSpacing;
            }
            catch (e) {
                Logger.getInstance().error(`SpriteFont Error drawing char ${character}`);
            }
        }
    }
    _parseOptions(options) {
        return {
            fontSize: options.fontSize || 10,
            letterSpacing: options.letterSpacing || 0,
            color: options.color || Color.Black,
            textAlign: typeof options.textAlign === undefined ? TextAlign.Left : options.textAlign,
            baseAlign: typeof options.baseAlign === undefined ? BaseAlign.Bottom : options.baseAlign,
            maxWidth: options.maxWidth || -1,
            opacity: options.opacity || 0
        };
    }
};
SpriteFont = SpriteSheet_decorate([
    obsolete({
        message: 'SpriteSheet will be removed in v0.26.0',
        alternateMethod: 'Use Graphics.SpriteSheet'
    })
], SpriteFont);


;// CONCATENATED MODULE: ./Graphics/SpriteSheet.ts



/**
 * Represents a collection of sprites from a source image with some organization in a grid
 */
class SpriteSheet {
    /**
     * Build a new sprite sheet from a list of sprites
     *
     * Use [[SpriteSheet.fromImageSource]] to create a SpriteSheet from an [[ImageSource]] organized in a grid
     * @param options
     */
    constructor(options) {
        this._logger = Logger.getInstance();
        this.sprites = [];
        const { sprites, rows, columns } = options;
        this.sprites = sprites;
        this.rows = rows !== null && rows !== void 0 ? rows : 1;
        this.columns = columns !== null && columns !== void 0 ? columns : this.sprites.length;
    }
    /**
     * Find a sprite by their x/y position in the SpriteSheet, for example `getSprite(0, 0)` is the [[Sprite]] in the top-left
     * @param x
     * @param y
     */
    getSprite(x, y) {
        if (x >= this.columns || x < 0) {
            this._logger.warn(`No sprite exists in the SpriteSheet at (${x}, ${y}), x: ${x} should be between 0 and ${this.columns - 1}`);
            return null;
        }
        if (y >= this.rows || y < 0) {
            this._logger.warn(`No sprite exists in the SpriteSheet at (${x}, ${y}), y: ${y} should be between 0 and ${this.rows - 1}`);
            return null;
        }
        const spriteIndex = x + y * this.columns;
        return this.sprites[spriteIndex];
    }
    /**
     * To a graphics sprite sheet from a legacy sprite sheet
     */
    static fromLegacySpriteSheet(legacySpriteSheet) {
        const sprites = legacySpriteSheet.sprites.map(oldSprite => Sprite.fromLegacySprite(oldSprite));
        return new SpriteSheet({
            sprites
        });
    }
    /**
     * @deprecated
     * @param spriteSheet
     * @returns
     */
    static toLegacySpriteSheet(spriteSheet) {
        const sprites = spriteSheet.sprites.map(sprite => Sprite.toLegacySprite(sprite));
        return new SpriteSheet_SpriteSheet(sprites);
    }
    /**
     * Create a SpriteSheet from an [[ImageSource]] organized in a grid
     *
     * Example:
     * ```
     * const spriteSheet = SpriteSheet.fromImageSource({
     *   image: imageSource,
     *   grid: {
     *     rows: 5,
     *     columns: 2,
     *     spriteWidth: 32, // pixels
     *     spriteHeight: 32 // pixels
     *   },
     *   // Optionally specify spacing
     *   spacing: {
     *     // pixels from the top left to start the sprite parsing
     *     originOffset: {
     *       x: 5,
     *       y: 5
     *     },
     *     // pixels between each sprite while parsing
     *     margin: {
     *       x: 1,
     *       y: 1
     *     }
     *   }
     * })
     * ```
     *
     * @param options
     */
    static fromImageSource(options) {
        var _a;
        const sprites = [];
        options.spacing = (_a = options.spacing) !== null && _a !== void 0 ? _a : {};
        const { image, grid: { rows, columns: cols, spriteWidth, spriteHeight }, spacing: { originOffset, margin } } = options;
        const offsetDefaults = Object.assign({ x: 0, y: 0 }, originOffset);
        const marginDefaults = Object.assign({ x: 0, y: 0 }, margin);
        for (let x = 0; x < cols; x++) {
            for (let y = 0; y < rows; y++) {
                sprites[x + y * cols] = new Sprite({
                    image: image,
                    sourceView: {
                        x: x * spriteWidth + marginDefaults.x * x + offsetDefaults.x,
                        y: y * spriteHeight + marginDefaults.y * y + offsetDefaults.y,
                        width: spriteWidth,
                        height: spriteHeight
                    },
                    destSize: { height: spriteHeight, width: spriteWidth }
                });
            }
        }
        return new SpriteSheet({
            sprites: sprites,
            rows: rows,
            columns: cols
        });
    }
}

;// CONCATENATED MODULE: ./Graphics/SpriteFont.ts




class SpriteFont_SpriteFont extends Graphic {
    constructor(options) {
        super(options);
        this._text = '';
        this._dirty = true;
        this.alphabet = '';
        this.shadow = null;
        this.caseInsensitive = false;
        this.spacing = 0;
        this._logger = Logger.getInstance();
        this._sprites = [];
        const { alphabet, spriteSheet, caseInsensitive, spacing, shadow } = options;
        this.alphabet = alphabet;
        this.spriteSheet = spriteSheet;
        this.caseInsensitive = caseInsensitive !== null && caseInsensitive !== void 0 ? caseInsensitive : this.caseInsensitive;
        this.spacing = spacing !== null && spacing !== void 0 ? spacing : this.spacing;
        this.shadow = shadow !== null && shadow !== void 0 ? shadow : this.shadow;
        this.spriteSheet.sprites[0].image.ready.then(() => {
            this._updateDimensions();
        });
    }
    static fromLegacySpriteFont(spriteFont) {
        const sprites = spriteFont.sprites.map(Sprite.fromLegacySprite);
        return new SpriteFont_SpriteFont({
            alphabet: spriteFont.alphabet,
            spacing: 0,
            caseInsensitive: spriteFont.caseInsensitive,
            spriteSheet: new SpriteSheet({
                sprites
            })
        });
    }
    _getCharacterSprites(text) {
        if (!this._dirty) {
            return this._sprites;
        }
        const results = [];
        // handle case insenstive
        const textToRender = this.caseInsensitive ? text.toLocaleLowerCase() : text;
        const alphabet = this.caseInsensitive ? this.alphabet.toLocaleLowerCase() : this.alphabet;
        // for each letter in text
        for (let letterIndex = 0; letterIndex < textToRender.length; letterIndex++) {
            // find the sprite index in alphabet , if there is an error pick the first
            const letter = textToRender[letterIndex];
            let spriteIndex = alphabet.indexOf(letter);
            if (spriteIndex === -1) {
                spriteIndex = 0;
                this._logger.warn(`SpriteFont - Cannot find letter '${letter}' in configured alphabet '${alphabet}'`);
            }
            const letterSprite = this.spriteSheet.sprites[spriteIndex];
            if (letterSprite) {
                results.push(letterSprite);
            }
            else {
                this._logger.warn(`SpriteFont - Cannot find sprite for '${letter}' at index '${spriteIndex}' in configured SpriteSheet`);
            }
        }
        this._dirty = false;
        return (this._sprites = results);
    }
    _updateDimensions() {
        const sprites = this._getCharacterSprites(this._text);
        let width = 0;
        let height = 0;
        for (const sprite of sprites) {
            width += sprite.width + this.spacing;
            height = Math.max(height, sprite.height);
        }
        this.width = width;
        this.height = height;
    }
    updateText(text) {
        if (this._text !== text) {
            this._dirty = true;
            this._text = text;
            this._updateDimensions();
        }
    }
    _preDraw(ex, x, y) {
        this._updateDimensions();
        super._preDraw(ex, x, y);
    }
    _drawImage(ex, x, y) {
        let cursor = 0;
        for (const sprite of this._getCharacterSprites(this._text)) {
            // draw it in the right spot and increase the cursor by sprite width
            sprite.draw(ex, x + cursor, y);
            cursor += sprite.width + this.spacing;
        }
    }
    render(ex, text, x, y) {
        if (this._text !== text) {
            this._dirty = true;
            this._text = text;
        }
        if (this.shadow) {
            ex.save();
            ex.translate(this.shadow.offset.x, this.shadow.offset.y);
            this.draw(ex, x, y);
            ex.restore();
        }
        this.draw(ex, x, y);
    }
    clone() {
        return new SpriteFont_SpriteFont({
            alphabet: this.alphabet,
            spriteSheet: this.spriteSheet,
            spacing: this.spacing
        });
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/debug-font.png
/* harmony default export */ const debug_font = ("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAAwCAYAAAD+f6R/AAAAAXNSR0IArs4c6QAABcJJREFUeJztnemu7CgMhGE07//KmT9NhrAFVzkQndQntXRP3/bCZkwCSQhCCCGEEEIIIYQQQog/TRz953Ecx/nDGIe/vdNhlc9tIz605Fk/ZmWfsO1hn9Gxuv1KHbvb3iL/VN+d1WORbyr7yR/5b9M4vjNeqko6jPJHq5wGHU151o9J2Udse9hndCxuv0rH7rY3yD/Wdyf13MrnQeDfkZIUSGKM4ff3cWN82pEZuTyQGX2IxeyR63va//8VNCYCq+1yEkLtWyagXv1P1r1H+110gP3PzT4gT8uW/mdQ8mUG8E9DqOz4MS9ICKGbXpS2BpnIrRzYeS96cll08INlCMl2/glzdcfazuuPqQO03lmqrBHsf272Q6NODXj6zzZIJd/LAHYTg3Mays5gBi7ZR27fOgs0yj8rm36DLMFiPgkAdXHKOwUQeMCQ/adSh/qBQrT/tPxbAwA9+DOZEILPAATSuHMgTv7+Auk/df2lHPCZLvMSLJe34LkEQ9PwXF1SRTllMYgvIaflqyVAjLGbsiCDcOK76jflxZ+sINPyROc5071yKWK5CJTV3dMp6+tBlyCtNlhAq/+XbWoBDcRNXYBMzD4VvQygSuPYC2jGGaSSOxXfy3dTUEsanIvNeepm38N/hssSALTPZnAXfwIYRJn2b7UBcw0FKX+nDdAMpm2j9WVnxrUa7TXaVAca/B+TgaAVh6R/rH0P/5m01dt/RLYViJn+w/bhVX2P7f/duqom5qb02pRLCLGIMgBU1wCEEN9BAUCID6MAIMSHUQAQ4sMoAAjxYRQAhPgwd1uB0fuZ7H3cnn2P+9mr/Pe4B8/eB/fwP4eRtci/0f6OfTCPt/9oHwC6G6y19RHZDumxmwzR4eE/s/2Tte/q/+XLdc9DeJ19diesQc/j7Z8fCe4tAS4CxZ7sp7eiJi7HiZmjmOTGJs+93CbS3nP0XIPH3vW8/qz6QPnX2QdsV/1uw/iZYvg8ACeHd28rpPzfNfhL+7vkw/4Ou9s+Onhbv91elpKZ48Dl6bzpwwibHigRArf+Ptk9+L3Y1Q5OB4LgCeSBw1iuB3GeJh1/HrX/zF0A9Mk+u45zMkc3r4rWPomma5+p/514LB+Zo93MErJ1JHxXPzByGa/licRYVKbpeQCoQ6Q8yxuCwJF9IPsoDkHAo/3Tx26cvA4EtJ/n04w8QOq/mrR7ddfLAC5BYFNlVI/0CnOVUflOpvJUQMx9AIMIW/nWDM67/qw0+95v9goBqD9j+72u/KD9U89IbnQbMIR2Zbneh5zUY7Hdk7XIP3UffVb+r+wDYAZLq+1n1+C7y3/ny2r7p5yeByDEh9HzAIQQJwoAQnwYBQAhPowCgBBjoNu3hNxSFACE6INuKvPajPZ4EFEAEKINcybGYzOd247WEd3TgA2jlmjEyrd+j9hvfVbD2PWQ3ZmGlu2HyO8og8eBuNUvNYWoDgMVpwHTJoLWdz1Y+ZYOy5uF7t6PPruZxANrud1lQXkP0jsGz/Yz+vGGMuygFyhSPcJnc1pMnQZElc+cRnoAlxdTvoDuK7puqF7uCQy+3fyFMiA02/vJQHh7DQDogMPTSGFNA56HTzbZ9yAfBOb1Zyo3qGM3MfMZ3f76huXf6xlmAHknMlLNXsBBBvbljIz9Uyz5Y5TzIBLR/qy/rNyrZ8+L/0BZ0m+tgXD0OK5XZxC/9P7I/g4hVFvzXf1/6i5A7+3AlijMPBLMZfCvuAp7A9rY56ApHitmLQc7c8bOv6ftAxlM9Xp35nkEK7nJetBsaMhtAAAuOLQGXwhh2dXQnn1rZ/a42BI3dL7L+jkFAbQddwdA9Ah35yMKhgEgVT46EFh5D4jz+OgavNKxeBCd1wDSJ/97oR8eoJkLi9t9/BDgDHTJ5NE7Dnzechh914OVv9M1K9PCqsfqb88XVg9qN9lm6nG176UPu+zn17GOxuO0vOWEEC/j+LFKTgghlvEfYJaLS+SA2O0AAAAASUVORK5CYII=");
;// CONCATENATED MODULE: ./Graphics/Context/debug-text.ts


/**
 * Internal debugtext helper
 */
class DebugText {
    constructor() {
        /**
         * base64 font
         */
        this.fontSheet = debug_font;
        this.size = 16;
        this.load();
    }
    load() {
        this._imageSource = new ImageSource(this.fontSheet);
        return this._imageSource.load().then(() => {
            this._spriteSheet = SpriteSheet.fromImageSource({
                image: this._imageSource,
                grid: {
                    rows: 3,
                    columns: 16,
                    spriteWidth: 16,
                    spriteHeight: 16
                }
            });
            this._spriteFont = new SpriteFont_SpriteFont({
                alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ,!\'&."?-()+ ',
                caseInsensitive: true,
                spriteSheet: this._spriteSheet,
                spacing: -6
            });
        });
    }
    /**
     * Writes debug text using the built in sprint font
     * @param ctx
     * @param text
     * @param pos
     */
    write(ctx, text, pos) {
        if (this._imageSource.isLoaded()) {
            this._spriteFont.render(ctx, text, pos.x, pos.y);
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/ExcaliburGraphicsContextWebGL.ts












class ExcaliburGraphicsContextWebGLDebug {
    constructor(_webglCtx) {
        this._webglCtx = _webglCtx;
        this._debugText = new DebugText();
    }
    /**
     * Draw a debugging rectangle to the context
     * @param x
     * @param y
     * @param width
     * @param height
     */
    drawRect(x, y, width, height, rectOptions = { color: Color.Black }) {
        this.drawLine(vec(x, y), vec(x + width, y), Object.assign({}, rectOptions));
        this.drawLine(vec(x + width, y), vec(x + width, y + height), Object.assign({}, rectOptions));
        this.drawLine(vec(x + width, y + height), vec(x, y + height), Object.assign({}, rectOptions));
        this.drawLine(vec(x, y + height), vec(x, y), Object.assign({}, rectOptions));
    }
    /**
     * Draw a debugging line to the context
     * @param start
     * @param end
     * @param lineOptions
     */
    drawLine(start, end, lineOptions = { color: Color.Black }) {
        this._webglCtx.__lineRenderer.addLine(start, end, lineOptions.color);
    }
    /**
     * Draw a debugging point to the context
     * @param point
     * @param pointOptions
     */
    drawPoint(point, pointOptions = { color: Color.Black, size: 5 }) {
        this._webglCtx.__pointRenderer.addPoint(point, pointOptions.color, pointOptions.size);
    }
    drawText(text, pos) {
        this._debugText.write(this._webglCtx, text, pos);
    }
}
class ExcaliburGraphicsContextWebGL {
    constructor(options) {
        this._transform = new TransformStack();
        this._state = new StateStack();
        this.snapToPixel = true;
        this.smoothing = false;
        this.backgroundColor = Color.ExcaliburBlue;
        this.debug = new ExcaliburGraphicsContextWebGLDebug(this);
        const { canvasElement, enableTransparency, smoothing, snapToPixel, backgroundColor } = options;
        this.__gl = canvasElement.getContext('webgl', {
            antialias: smoothing !== null && smoothing !== void 0 ? smoothing : this.smoothing,
            premultipliedAlpha: false,
            alpha: enableTransparency !== null && enableTransparency !== void 0 ? enableTransparency : true,
            depth: true,
            powerPreference: 'high-performance'
        });
        this.snapToPixel = snapToPixel !== null && snapToPixel !== void 0 ? snapToPixel : this.snapToPixel;
        this.smoothing = smoothing !== null && smoothing !== void 0 ? smoothing : this.smoothing;
        this.backgroundColor = backgroundColor !== null && backgroundColor !== void 0 ? backgroundColor : this.backgroundColor;
        this._init();
    }
    get opacity() {
        return this._state.current.opacity;
    }
    set opacity(value) {
        this._state.current.opacity = value;
    }
    get width() {
        return this.__gl.canvas.width;
    }
    get height() {
        return this.__gl.canvas.height;
    }
    /**
     * Checks the underlying webgl implementation if the requested internal resolution is supported
     * @param dim
     */
    checkIfResolutionSupported(dim) {
        // Slight hack based on this thread https://groups.google.com/g/webgl-dev-list/c/AHONvz3oQTo
        const gl = this.__gl;
        // If any dimension is greater than max texture size (divide by 4 bytes per pixel)
        const maxDim = gl.getParameter(gl.MAX_TEXTURE_SIZE) / 4;
        let supported = true;
        if (dim.width > maxDim || dim.height > maxDim) {
            supported = false;
        }
        return supported;
    }
    _init() {
        const gl = this.__gl;
        // Setup viewport and view matrix
        this._ortho = Matrix.ortho(0, gl.canvas.width, gl.canvas.height, 0, 400, -400);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        // Clear background
        gl.clearColor(this.backgroundColor.r / 255, this.backgroundColor.g / 255, this.backgroundColor.b / 255, this.backgroundColor.a);
        gl.clear(gl.COLOR_BUFFER_BIT);
        // Enable alpha blending
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        this.__pointRenderer = new PointRenderer(gl, { matrix: this._ortho, transform: this._transform, state: this._state });
        this.__lineRenderer = new LineRenderer(gl, { matrix: this._ortho, transform: this._transform, state: this._state });
        this.__imageRenderer = new ImageRenderer(gl, { matrix: this._ortho, transform: this._transform, state: this._state });
        // 2D ctx shim
        this._canvas = new Canvas({
            width: gl.canvas.width,
            height: gl.canvas.height
        });
        this.__ctx = this._canvas.ctx;
    }
    resetTransform() {
        this._transform.current = Matrix.identity();
    }
    updateViewport() {
        const gl = this.__gl;
        this._ortho = this._ortho = Matrix.ortho(0, gl.canvas.width, gl.canvas.height, 0, 400, -400);
        this.__pointRenderer.shader.addUniformMatrix('u_matrix', this._ortho.data);
        this.__lineRenderer.shader.addUniformMatrix('u_matrix', this._ortho.data);
        this.__imageRenderer.shader.addUniformMatrix('u_matrix', this._ortho.data);
        // 2D ctx shim
        this._canvas.width = gl.canvas.width;
        this._canvas.height = gl.canvas.height;
    }
    drawImage(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
        if (swidth === 0 || sheight === 0) {
            return; // zero dimension dest exit early
        }
        else if (dwidth === 0 || dheight === 0) {
            return; // zero dimension dest exit early
        }
        else if (image.width === 0 || image.height === 0) {
            return; // zero dimension source exit early
        }
        if (!image) {
            Logger.getInstance().warn('Cannot draw a null or undefined image');
            // tslint:disable-next-line: no-console
            if (console.trace) {
                // tslint:disable-next-line: no-console
                console.trace();
            }
            return;
        }
        this.__imageRenderer.addImage(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight);
    }
    drawLine(start, end, color, thickness = 1) {
        this.__imageRenderer.addLine(color, start, end, thickness);
    }
    drawRectangle(pos, width, height, color) {
        this.__imageRenderer.addRectangle(color, pos, width, height);
    }
    drawCircle(pos, radius, color) {
        this.__imageRenderer.addCircle(pos, radius, color);
    }
    save() {
        this._transform.save();
        this._state.save();
    }
    restore() {
        this._transform.restore();
        this._state.restore();
    }
    translate(x, y) {
        this._transform.translate(this.snapToPixel ? ~~x : x, this.snapToPixel ? ~~y : y);
    }
    rotate(angle) {
        this._transform.rotate(angle);
    }
    scale(x, y) {
        this._transform.scale(x, y);
    }
    transform(matrix) {
        this._transform.current = matrix;
    }
    clear() {
        const gl = this.__gl;
        gl.clearColor(this.backgroundColor.r / 255, this.backgroundColor.g / 255, this.backgroundColor.b / 255, this.backgroundColor.a);
        // Clear the context with the newly set color. This is
        // the function call that actually does the drawing.
        gl.clear(gl.COLOR_BUFFER_BIT);
        GraphicsDiagnostics.clear();
    }
    /**
     * Flushes all batched rendering to the screen
     */
    flush() {
        const gl = this.__gl;
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        this.__imageRenderer.render();
        this.__lineRenderer.render();
        this.__pointRenderer.render();
    }
}

;// CONCATENATED MODULE: ./Screen.ts





/**
 * Enum representing the different display modes available to Excalibur.
 */
var DisplayMode;
(function (DisplayMode) {
    /**
     * Default, use a specified resolution for the game. Like 800x600 pixels for example.
     */
    DisplayMode["Fixed"] = "Fixed";
    /**
     * Fit to screen using as much space as possible while maintaining aspect ratio and resolution.
     * This is not the same as [[Screen.goFullScreen]] but behaves in a similar way maintaining aspect ratio.
     *
     * You may want to center your game here is an example
     * ```html
     * <!-- html -->
     * <body>
     * <main>
     *   <canvas id="game"></canvas>
     * </main>
     * </body>
     * ```
     *
     * ```css
     * // css
     * main {
     *   display: flex;
     *   align-items: center;
     *   justify-content: center;
     *   height: 100%;
     *   width: 100%;
     * }
     * ```
     *
     */
    DisplayMode["FitScreen"] = "FitScreen";
    /**
     * Fill the entire screen's css width/height for the game resolution dynamically. This means the resolution of the game will
     * change dynamically as the window is resized. This is not the same as [[Screen.goFullScreen]]
     */
    DisplayMode["FillScreen"] = "FillScreen";
    /**
     * Fit to parent element width/height using as much space as possible while maintaining aspect ratio and resolution.
     */
    DisplayMode["FitContainer"] = "FitContainer";
    /**
     * Use the parent DOM container's css width/height for the game resolution dynamically
     */
    DisplayMode["FillContainer"] = "FillContainer";
    /**
     * Allow the game to be positioned with the [[EngineOptions.position]] option
     * @deprecated Use CSS to position the game canvas, will be removed in v0.26.0
     */
    DisplayMode["Position"] = "Position";
})(DisplayMode || (DisplayMode = {}));
/**
 * Convenience class for quick resolutions
 * Mostly sourced from https://emulation.gametechwiki.com/index.php/Resolution
 */
class Resolution {
    /* istanbul ignore next */
    static get SVGA() {
        return { width: 800, height: 600 };
    }
    /* istanbul ignore next */
    static get Standard() {
        return { width: 1920, height: 1080 };
    }
    /* istanbul ignore next */
    static get Atari2600() {
        return { width: 160, height: 192 };
    }
    /* istanbul ignore next */
    static get GameBoy() {
        return { width: 160, height: 144 };
    }
    /* istanbul ignore next */
    static get GameBoyAdvance() {
        return { width: 240, height: 160 };
    }
    /* istanbul ignore next */
    static get NintendoDS() {
        return { width: 256, height: 192 };
    }
    /* istanbul ignore next */
    static get NES() {
        return { width: 256, height: 224 };
    }
    /* istanbul ignore next */
    static get SNES() {
        return { width: 256, height: 244 };
    }
}
/**
 * The Screen handles all aspects of interacting with the screen for Excalibur.
 */
class Screen {
    constructor(options) {
        var _a, _b, _c;
        this._antialiasing = true;
        this._resolutionStack = [];
        this._viewportStack = [];
        this._pixelRatioOverride = null;
        this._isFullScreen = false;
        this._isDisposed = false;
        this._logger = Logger.getInstance();
        this._fullscreenChangeHandler = () => {
            this._isFullScreen = !this._isFullScreen;
            this._logger.debug('Fullscreen Change', this._isFullScreen);
        };
        this._pixelRatioChangeHandler = () => {
            this._logger.debug('Pixel Ratio Change', window.devicePixelRatio);
            this._devicePixelRatio = this._calculateDevicePixelRatio();
            this.applyResolutionAndViewport();
        };
        this._resizeHandler = () => {
            const parent = this.parent;
            this._logger.debug('View port resized');
            this._setResolutionAndViewportByDisplayMode(parent);
            this.applyResolutionAndViewport();
        };
        // Asking the window.devicePixelRatio is expensive we do it once
        this._devicePixelRatio = this._calculateDevicePixelRatio();
        this._alreadyWarned = false;
        this.viewport = options.viewport;
        this.resolution = (_a = options.resolution) !== null && _a !== void 0 ? _a : Object.assign({}, this.viewport);
        this._displayMode = (_b = options.displayMode) !== null && _b !== void 0 ? _b : DisplayMode.Fixed;
        this._canvas = options.canvas;
        this._ctx = options.context;
        this._antialiasing = (_c = options.antialiasing) !== null && _c !== void 0 ? _c : this._antialiasing;
        this._browser = options.browser;
        this._position = options.position;
        this._pixelRatioOverride = options.pixelRatio;
        this._applyDisplayMode();
        this._mediaQueryList = this._browser.window.nativeComponent.matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);
        this._mediaQueryList.addEventListener('change', this._pixelRatioChangeHandler);
        this._canvas.addEventListener('fullscreenchange', this._fullscreenChangeHandler);
        this.applyResolutionAndViewport();
    }
    dispose() {
        if (!this._isDisposed) {
            // Clean up handlers
            this._isDisposed = true;
            this._browser.window.off('resize', this._resizeHandler);
            if (this._resizeObserver) {
                this._resizeObserver.disconnect();
            }
            this.parent.removeEventListener('resize', this._resizeHandler);
            this._mediaQueryList.removeEventListener('change', this._pixelRatioChangeHandler);
            this._canvas.removeEventListener('fullscreenchange', this._fullscreenChangeHandler);
        }
    }
    _calculateDevicePixelRatio() {
        if (window.devicePixelRatio < 1) {
            return 1;
        }
        const devicePixelRatio = window.devicePixelRatio || 1;
        return devicePixelRatio;
    }
    get pixelRatio() {
        if (this._pixelRatioOverride) {
            return this._pixelRatioOverride;
        }
        return this._devicePixelRatio;
    }
    get isHiDpi() {
        return this.pixelRatio !== 1;
    }
    get displayMode() {
        return this._displayMode;
    }
    get canvas() {
        return this._canvas;
    }
    get parent() {
        return ((this.displayMode === DisplayMode.FillContainer || this.displayMode === DisplayMode.FitContainer
            ? this.canvas.parentElement || document.body
            : window));
    }
    get resolution() {
        return this._resolution;
    }
    set resolution(resolution) {
        this._resolution = resolution;
    }
    get viewport() {
        if (this._viewport) {
            return this._viewport;
        }
        return this._resolution;
    }
    set viewport(viewport) {
        this._viewport = viewport;
    }
    get aspectRatio() {
        return this._resolution.width / this._resolution.height;
    }
    get scaledWidth() {
        return this._resolution.width * this.pixelRatio;
    }
    get scaledHeight() {
        return this._resolution.height * this.pixelRatio;
    }
    setCurrentCamera(camera) {
        this._camera = camera;
    }
    pushResolutionAndViewport() {
        this._resolutionStack.push(this.resolution);
        this._viewportStack.push(this.viewport);
        this.resolution = Object.assign({}, this.resolution);
        this.viewport = Object.assign({}, this.viewport);
    }
    peekViewport() {
        return this._viewportStack[this._viewportStack.length - 1];
    }
    peekResolution() {
        return this._resolutionStack[this._resolutionStack.length - 1];
    }
    popResolutionAndViewport() {
        this.resolution = this._resolutionStack.pop();
        this.viewport = this._viewportStack.pop();
    }
    applyResolutionAndViewport() {
        this._canvas.width = this.scaledWidth;
        this._canvas.height = this.scaledHeight;
        if (this._ctx instanceof ExcaliburGraphicsContextWebGL) {
            const supported = this._ctx.checkIfResolutionSupported({
                width: this.scaledWidth,
                height: this.scaledHeight
            });
            if (!supported && !this._alreadyWarned) {
                this._alreadyWarned = true; // warn once
                this._logger.warn(`The currently configured resolution (${this.resolution.width}x${this.resolution.height})` +
                    ' is too large for the platform WebGL implementation, this may work but cause WebGL rendering to behave oddly.' +
                    ' Try reducing the resolution or disabling Hi DPI scaling to avoid this' +
                    ' (read more here https://excaliburjs.com/docs/screens#understanding-viewport--resolution).');
            }
        }
        if (this._antialiasing) {
            this._canvas.style.imageRendering = 'auto';
        }
        else {
            this._canvas.style.imageRendering = 'pixelated';
            // Fall back to 'crisp-edges' if 'pixelated' is not supported
            // Currently for firefox https://developer.mozilla.org/en-US/docs/Web/CSS/image-rendering
            if (this._canvas.style.imageRendering === '') {
                this._canvas.style.imageRendering = 'crisp-edges';
            }
        }
        this._canvas.style.width = this.viewport.width + 'px';
        this._canvas.style.height = this.viewport.height + 'px';
        // After messing with the canvas width/height the graphics context is invalidated and needs to have some properties reset
        this._ctx.updateViewport();
        this._ctx.resetTransform();
        this._ctx.scale(this.pixelRatio, this.pixelRatio);
        this._ctx.smoothing = this._antialiasing;
    }
    get antialiasing() {
        return this._antialiasing;
    }
    set antialiasing(isSmooth) {
        this._antialiasing = isSmooth;
        this._ctx.smoothing = this._antialiasing;
    }
    /**
     * Returns true if excalibur is fullscreened using the browser fullscreen api
     */
    get isFullScreen() {
        return this._isFullScreen;
    }
    /**
     * Requests to go fullscreen using the browser fullscreen api, requires user interaction to be successful.
     * For example, wire this to a user click handler.
     */
    goFullScreen() {
        return this._canvas.requestFullscreen();
    }
    /**
     * Requests to exit fullscreen using the browser fullscreen api
     */
    exitFullScreen() {
        return document.exitFullscreen();
    }
    /**
     * Takes a coordinate in normal html page space, for example from a pointer move event, and translates it to
     * Excalibur screen space.
     *
     * Excalibur screen space starts at the top left (0, 0) corner of the viewport, and extends to the
     * bottom right corner (resolutionX, resolutionY)
     * @param point
     */
    pageToScreenCoordinates(point) {
        let newX = point.x;
        let newY = point.y;
        if (!this._isFullScreen) {
            newX -= getPosition(this._canvas).x;
            newY -= getPosition(this._canvas).y;
        }
        // if fullscreen api on it centers with black bars
        // we need to adjust the screen to world coordinates in this case
        if (this._isFullScreen) {
            if (window.innerWidth / this.aspectRatio < window.innerHeight) {
                const screenHeight = window.innerWidth / this.aspectRatio;
                const screenMarginY = (window.innerHeight - screenHeight) / 2;
                newY = ((newY - screenMarginY) / screenHeight) * this.viewport.height;
                newX = (newX / window.innerWidth) * this.viewport.width;
            }
            else {
                const screenWidth = window.innerHeight * this.aspectRatio;
                const screenMarginX = (window.innerWidth - screenWidth) / 2;
                newX = ((newX - screenMarginX) / screenWidth) * this.viewport.width;
                newY = (newY / window.innerHeight) * this.viewport.height;
            }
        }
        newX = (newX / this.viewport.width) * this.resolution.width;
        newY = (newY / this.viewport.height) * this.resolution.height;
        return new Vector(newX, newY);
    }
    /**
     * Takes a coordinate in Excalibur screen space, and translates it to normal html page space. For example,
     * this is where html elements might live if you want to position them relative to Excalibur.
     *
     * Excalibur screen space starts at the top left (0, 0) corner of the viewport, and extends to the
     * bottom right corner (resolutionX, resolutionY)
     * @param point
     */
    screenToPageCoordinates(point) {
        let newX = point.x;
        let newY = point.y;
        newX = (newX / this.resolution.width) * this.viewport.width;
        newY = (newY / this.resolution.height) * this.viewport.height;
        if (this._isFullScreen) {
            if (window.innerWidth / this.aspectRatio < window.innerHeight) {
                const screenHeight = window.innerWidth / this.aspectRatio;
                const screenMarginY = (window.innerHeight - screenHeight) / 2;
                newY = (newY / this.viewport.height) * screenHeight + screenMarginY;
                newX = (newX / this.viewport.width) * window.innerWidth;
            }
            else {
                const screenWidth = window.innerHeight * this.aspectRatio;
                const screenMarginX = (window.innerWidth - screenWidth) / 2;
                newX = (newX / this.viewport.width) * screenWidth + screenMarginX;
                newY = (newY / this.viewport.height) * window.innerHeight;
            }
        }
        if (!this._isFullScreen) {
            newX += getPosition(this._canvas).x;
            newY += getPosition(this._canvas).y;
        }
        return new Vector(newX, newY);
    }
    /**
     * Takes a coordinate in Excalibur screen space, and translates it to Excalibur world space.
     *
     * World space is where [[Entity|entities]] in Excalibur live by default [[CoordPlane.World]]
     * and extends infinitely out relative from the [[Camera]].
     * @param point  Screen coordinate to convert
     */
    screenToWorldCoordinates(point) {
        var _a, _b, _c, _d;
        let newX = point.x;
        let newY = point.y;
        // transform back to world space
        newX = (newX / this.resolution.width) * this.drawWidth;
        newY = (newY / this.resolution.height) * this.drawHeight;
        // transform based on zoom
        newX = newX - this.halfDrawWidth;
        newY = newY - this.halfDrawHeight;
        // shift by camera focus
        newX += (_b = (_a = this._camera) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : 0;
        newY += (_d = (_c = this._camera) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : 0;
        return new Vector(newX, newY);
    }
    /**
     * Takes a coordinate in Excalibur world space, and translates it to Excalibur screen space.
     *
     * Screen space is where [[ScreenElement|screen elements]] and [[Entity|entities]] with [[CoordPlane.Screen]] live.
     * @param point  World coordinate to convert
     */
    worldToScreenCoordinates(point) {
        var _a, _b, _c, _d;
        let screenX = point.x;
        let screenY = point.y;
        // shift by camera focus
        screenX -= (_b = (_a = this._camera) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : 0;
        screenY -= (_d = (_c = this._camera) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : 0;
        // transform back on zoom
        screenX = screenX + this.halfDrawWidth;
        screenY = screenY + this.halfDrawHeight;
        // transform back to screen space
        screenX = (screenX / this.drawWidth) * this.resolution.width;
        screenY = (screenY / this.drawHeight) * this.resolution.height;
        return new Vector(screenX, screenY);
    }
    pageToWorldCoordinates(point) {
        const screen = this.pageToScreenCoordinates(point);
        return this.screenToWorldCoordinates(screen);
    }
    worldToPageCoordinates(point) {
        const screen = this.worldToScreenCoordinates(point);
        return this.screenToPageCoordinates(screen);
    }
    /**
     * Returns a BoundingBox of the top left corner of the screen
     * and the bottom right corner of the screen.
     *
     * World bounds are in world coordinates, useful for culling objects offscreen
     */
    getWorldBounds() {
        const left = this.screenToWorldCoordinates(Vector.Zero).x;
        const top = this.screenToWorldCoordinates(Vector.Zero).y;
        const right = left + this.drawWidth;
        const bottom = top + this.drawHeight;
        return new BoundingBox(left, top, right, bottom);
    }
    /**
     * The width of the game canvas in pixels (physical width component of the
     * resolution of the canvas element)
     */
    get canvasWidth() {
        return this.canvas.width;
    }
    /**
     * Returns half width of the game canvas in pixels (half physical width component)
     */
    get halfCanvasWidth() {
        return this.canvas.width / 2;
    }
    /**
     * The height of the game canvas in pixels, (physical height component of
     * the resolution of the canvas element)
     */
    get canvasHeight() {
        return this.canvas.height;
    }
    /**
     * Returns half height of the game canvas in pixels (half physical height component)
     */
    get halfCanvasHeight() {
        return this.canvas.height / 2;
    }
    /**
     * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawWidth() {
        if (this._camera) {
            return this.resolution.width / this._camera.zoom;
        }
        return this.resolution.width;
    }
    /**
     * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawWidth() {
        return this.drawWidth / 2;
    }
    /**
     * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawHeight() {
        if (this._camera) {
            return this.resolution.height / this._camera.zoom;
        }
        return this.resolution.height;
    }
    /**
     * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawHeight() {
        return this.drawHeight / 2;
    }
    /**
     * Returns screen center coordinates including zoom and device pixel ratio.
     */
    get center() {
        return vec(this.halfDrawWidth, this.halfDrawHeight);
    }
    _computeFit() {
        document.body.style.margin = '0px';
        document.body.style.overflow = 'hidden';
        const aspect = this.aspectRatio;
        let adjustedWidth = 0;
        let adjustedHeight = 0;
        if (window.innerWidth / aspect < window.innerHeight) {
            adjustedWidth = window.innerWidth;
            adjustedHeight = window.innerWidth / aspect;
        }
        else {
            adjustedWidth = window.innerHeight * aspect;
            adjustedHeight = window.innerHeight;
        }
        this.viewport = {
            width: adjustedWidth,
            height: adjustedHeight
        };
    }
    _computeFitContainer() {
        const aspect = this.aspectRatio;
        let adjustedWidth = 0;
        let adjustedHeight = 0;
        const parent = this.canvas.parentElement;
        if (parent.clientWidth / aspect < parent.clientHeight) {
            adjustedWidth = parent.clientWidth;
            adjustedHeight = parent.clientWidth / aspect;
        }
        else {
            adjustedWidth = parent.clientHeight * aspect;
            adjustedHeight = parent.clientHeight;
        }
        this.viewport = {
            width: adjustedWidth,
            height: adjustedHeight
        };
    }
    _applyDisplayMode() {
        if (this.displayMode === DisplayMode.Position) {
            this._initializeDisplayModePosition(this._position);
        }
        else {
            this._setResolutionAndViewportByDisplayMode(this.parent);
            // watch resizing
            if (this.parent instanceof Window) {
                this._browser.window.on('resize', this._resizeHandler);
            }
            else {
                this._resizeObserver = new ResizeObserver(() => {
                    this._resizeHandler();
                });
                this._resizeObserver.observe(this.parent);
            }
            this.parent.addEventListener('resize', this._resizeHandler);
        }
    }
    /**
     * Sets the resoultion and viewport based on the selected display mode.
     */
    _setResolutionAndViewportByDisplayMode(parent) {
        if (this.displayMode === DisplayMode.FillContainer) {
            this.resolution = {
                width: parent.clientWidth,
                height: parent.clientHeight
            };
            this.viewport = this.resolution;
        }
        if (this.displayMode === DisplayMode.FillScreen) {
            document.body.style.margin = '0px';
            document.body.style.overflow = 'hidden';
            this.resolution = {
                width: parent.innerWidth,
                height: parent.innerHeight
            };
            this.viewport = this.resolution;
        }
        if (this.displayMode === DisplayMode.FitScreen) {
            this._computeFit();
        }
        if (this.displayMode === DisplayMode.FitContainer) {
            this._computeFitContainer();
        }
    }
    _initializeDisplayModePosition(position) {
        if (!position) {
            throw new Error('DisplayMode of Position was selected but no position option was given');
        }
        else {
            this.canvas.style.display = 'block';
            this.canvas.style.position = 'absolute';
            if (typeof position === 'string') {
                const specifiedPosition = position.split(' ');
                switch (specifiedPosition[0]) {
                    case 'top':
                        this.canvas.style.top = '0px';
                        break;
                    case 'bottom':
                        this.canvas.style.bottom = '0px';
                        break;
                    case 'middle':
                        this.canvas.style.top = '50%';
                        const offsetY = -this.halfDrawHeight;
                        this.canvas.style.marginTop = offsetY.toString();
                        break;
                    default:
                        throw new Error('Invalid Position Given');
                }
                if (specifiedPosition[1]) {
                    switch (specifiedPosition[1]) {
                        case 'left':
                            this.canvas.style.left = '0px';
                            break;
                        case 'right':
                            this.canvas.style.right = '0px';
                            break;
                        case 'center':
                            this.canvas.style.left = '50%';
                            const offsetX = -this.halfDrawWidth;
                            this.canvas.style.marginLeft = offsetX.toString();
                            break;
                        default:
                            throw new Error('Invalid Position Given');
                    }
                }
            }
            else {
                if (position.top) {
                    typeof position.top === 'number'
                        ? (this.canvas.style.top = position.top.toString() + 'px')
                        : (this.canvas.style.top = position.top);
                }
                if (position.right) {
                    typeof position.right === 'number'
                        ? (this.canvas.style.right = position.right.toString() + 'px')
                        : (this.canvas.style.right = position.right);
                }
                if (position.bottom) {
                    typeof position.bottom === 'number'
                        ? (this.canvas.style.bottom = position.bottom.toString() + 'px')
                        : (this.canvas.style.bottom = position.bottom);
                }
                if (position.left) {
                    typeof position.left === 'number'
                        ? (this.canvas.style.left = position.left.toString() + 'px')
                        : (this.canvas.style.left = position.left);
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./Resources/Sound/AudioContext.ts
/**
 * Internal class used to build instances of AudioContext
 */
/* istanbul ignore next */
class AudioContextFactory {
    static create() {
        if (!this._INSTANCE) {
            if (window.AudioContext || window.webkitAudioContext) {
                this._INSTANCE = new AudioContext();
            }
        }
        return this._INSTANCE;
    }
}
AudioContextFactory._INSTANCE = null;

;// CONCATENATED MODULE: ./Util/WebAudio.ts


/**
 * Patch for detecting legacy web audio in browsers
 * @internal
 * @param source
 */
function isLegacyWebAudioSource(source) {
    return !!source.playbackState;
}
class WebAudio {
    /**
     * Play an empty sound to unlock Safari WebAudio context. Call this function
     * right after a user interaction event.
     * @source https://paulbakaus.com/tutorials/html5/web-audio-on-ios/
     */
    static unlock() {
        const promise = new Promise((resolve, reject) => {
            if (WebAudio._UNLOCKED || !AudioContextFactory.create()) {
                return resolve(true);
            }
            const unlockTimeoutTimer = setTimeout(() => {
                Logger.getInstance().warn('Excalibur was unable to unlock the audio context, audio probably will not play in this browser.');
                resolve(false);
            }, 200);
            const audioContext = AudioContextFactory.create();
            audioContext.resume().then(() => {
                // create empty buffer and play it
                const buffer = audioContext.createBuffer(1, 1, 22050);
                const source = audioContext.createBufferSource();
                let ended = false;
                source.buffer = buffer;
                source.connect(audioContext.destination);
                source.onended = () => (ended = true);
                source.start(0);
                // by checking the play state after some time, we know if we're really unlocked
                setTimeout(() => {
                    if (isLegacyWebAudioSource(source)) {
                        if (source.playbackState === source.PLAYING_STATE || source.playbackState === source.FINISHED_STATE) {
                            WebAudio._UNLOCKED = true;
                        }
                    }
                    else {
                        if (audioContext.currentTime > 0 || ended) {
                            WebAudio._UNLOCKED = true;
                        }
                    }
                }, 0);
                clearTimeout(unlockTimeoutTimer);
                resolve(true);
            }, () => {
                reject();
            });
        });
        return promise;
    }
    static isUnlocked() {
        return this._UNLOCKED;
    }
}
WebAudio._UNLOCKED = false;

;// CONCATENATED MODULE: ./Class.ts

/**
 * Excalibur base class that provides basic functionality such as [[EventDispatcher]]
 * and extending abilities for vanilla Javascript projects
 */
class Class {
    constructor() {
        this.eventDispatcher = new EventDispatcher(this);
    }
    /**
     * Alias for `addEventListener`. You can listen for a variety of
     * events off of the engine; see the events section below for a complete list.
     * @param eventName  Name of the event to listen for
     * @param handler    Event handler for the thrown event
     */
    on(eventName, handler) {
        this.eventDispatcher.on(eventName, handler);
    }
    /**
     * Alias for `removeEventListener`. If only the eventName is specified
     * it will remove all handlers registered for that specific event. If the eventName
     * and the handler instance are specified only that handler will be removed.
     *
     * @param eventName  Name of the event to listen for
     * @param handler    Event handler for the thrown event
     */
    off(eventName, handler) {
        this.eventDispatcher.off(eventName, handler);
    }
    /**
     * Emits a new event
     * @param eventName   Name of the event to emit
     * @param eventObject Data associated with this event
     */
    emit(eventName, eventObject) {
        this.eventDispatcher.emit(eventName, eventObject);
    }
    /**
     * Once listens to an event one time, then unsubscribes from that event
     *
     * @param eventName The name of the event to subscribe to once
     * @param handler   The handler of the event that will be auto unsubscribed
     */
    once(eventName, handler) {
        this.eventDispatcher.once(eventName, handler);
    }
}

;// CONCATENATED MODULE: ./Util/DrawUtil.ts

/* istanbul ignore next */
/**
 * Draw a line on canvas context
 *
 * @param ctx The canvas context
 * @param color The color of the line
 * @param x1 The start x coordinate
 * @param y1 The start y coordinate
 * @param x2 The ending x coordinate
 * @param y2 The ending y coordinate
 * @param thickness The line thickness
 * @param cap The [[LineCapStyle]] (butt, round, or square)
 */
function line(ctx, color = Color.Red, x1, y1, x2, y2, thickness = 1, cap = 'butt') {
    ctx.beginPath();
    ctx.lineWidth = thickness;
    ctx.lineCap = cap;
    ctx.strokeStyle = color.toString();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.closePath();
    ctx.stroke();
}
/* istanbul ignore next */
/**
 * Draw the vector as a point onto the canvas.
 */
function point(ctx, color = Color.Red, point) {
    ctx.beginPath();
    ctx.strokeStyle = color.toString();
    ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
    ctx.closePath();
    ctx.stroke();
}
/**
 * Draw the vector as a line onto the canvas starting a origin point.
 */
/* istanbul ignore next */
/**
 *
 */
function vector(ctx, color, origin, vector, scale = 1.0) {
    const c = color ? color.toString() : 'blue';
    const v = vector.scale(scale);
    ctx.beginPath();
    ctx.strokeStyle = c;
    ctx.moveTo(origin.x, origin.y);
    ctx.lineTo(origin.x + v.x, origin.y + v.y);
    ctx.closePath();
    ctx.stroke();
}
/**
 * Draw a round rectangle on a canvas context
 *
 * @param ctx The canvas context
 * @param x The top-left x coordinate
 * @param y The top-left y coordinate
 * @param width The width of the rectangle
 * @param height The height of the rectangle
 * @param radius The border radius of the rectangle
 * @param stroke The [[Color]] to stroke rectangle with
 * @param fill The [[Color]] to fill rectangle with
 */
function roundRect(ctx, x, y, width, height, radius = 5, stroke = Color.White, fill = null) {
    let br;
    if (typeof radius === 'number') {
        br = { tl: radius, tr: radius, br: radius, bl: radius };
    }
    else {
        const defaultRadius = { tl: 0, tr: 0, br: 0, bl: 0 };
        for (const prop in defaultRadius) {
            if (defaultRadius.hasOwnProperty(prop)) {
                const side = prop;
                br[side] = radius[side] || defaultRadius[side];
            }
        }
    }
    ctx.beginPath();
    ctx.moveTo(x + br.tl, y);
    ctx.lineTo(x + width - br.tr, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + br.tr);
    ctx.lineTo(x + width, y + height - br.br);
    ctx.quadraticCurveTo(x + width, y + height, x + width - br.br, y + height);
    ctx.lineTo(x + br.bl, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - br.bl);
    ctx.lineTo(x, y + br.tl);
    ctx.quadraticCurveTo(x, y, x + br.tl, y);
    ctx.closePath();
    if (fill) {
        ctx.fillStyle = fill.toString();
        ctx.fill();
    }
    if (stroke) {
        ctx.strokeStyle = stroke.toString();
        ctx.stroke();
    }
}
/**
 *
 */
function circle(ctx, x, y, radius, stroke = Color.White, fill = null) {
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.closePath();
    if (fill) {
        ctx.fillStyle = fill.toString();
        ctx.fill();
    }
    if (stroke) {
        ctx.strokeStyle = stroke.toString();
        ctx.stroke();
    }
}

;// CONCATENATED MODULE: ./Loader.logo.png
/* harmony default export */ const Loader_logo = ("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAdQAAAB2CAYAAABxhGI9AAAACXBIWXMAAAsSAAALEgHS3X78AAAKnUlEQVR42u3dP2wjSx0H8N8hJIonIRmJjsq0SBR+BQ1dcqKhe0lD77SvSwpKkJKGPulpktfRIMUdEqKIqV57rpAokM4dbSiyq7ONPTP7x39ifz7SFbnEnp3xer47O7uzH15fXwMA6OYHmgAABCoACFQAEKgAgEAFAIEKAAIVAAQqACBQAUCgAoBABQCBCgAIVAAQqAAgUAFAoAIAAhUABCoACFQAEKgAgECFLbmOiNeFf2PbAyz68Pr6qhUgbRwR92v+/zwiJrYHMEKFMmcN///UtgcQqFBk1PD/97U9Qx8VCFSgu4EmAIEKAAIVAAQqACBQ4Z25jojP8eX+0WtNAgIVaOY+Im5j+eKh24h41jQgUIEyZ7F5NaPU7wCBCiwYd/w9cOB+qAlgJ3KLLow0EV198803RWvJfvfddx+0lhEqHKu5JgAjVCBvlhmFzjQRXUekHz9+TP79y8uLRjNChXfvoePvAYEKxNtj1e42/O5JoIJABcrdRMRVLM+X3kTEpaaB988cKuzWg9EobTWdMx0Oly8uN4dqhAoARqgnaN3arHfqu7OyH8ItKLVB/P+CEfMTHyGPY3npx1m8zWGDEeoBfUk/xdti57dr/r1Wv2+6EPow3tZ5rRdS72s1neuF97xvWd+XTH0/V+UMttDWqbI/r2nrxfp+jv2uSjSO7S+OXy/A/3lN+9xX5T5HxEUPZZ0tfB71+w57eJ/HFu+z+jkv1u92YX9fbI/HhX3JA9rp5MPr66tWaG9UfUGbrHIzi7cLUyYFf/tpTady03EEeL8mUJ6i7MKYNvWNqr4Pe2jradXO60LrvPAz2PQ5RPX684ah8dxD+2zantnCgVipSVV+m/tgB9W2DDq2Sx/vM95wcHhZhWVJm8yrv58cSgfTdc70+++/X/r522+/tUKSEepBqo+om4ZLPerMjUwuNnQCtx1GWJtee1FwdD5uWd86xLs8UaVt2aNEO1/saZ/Z5rYMW4zq6v34rGV9Bg3q2eZ9SkeNm9qwyUh30OPIHYFKx5FG03C7znSOqYBq+qW/zpQ3anH037TNHluG6f0WPsPhHvab4QFty7ogOeuxDYcNy2/zu2214WNYWxmBurNO8bGn97pNBOO8xy/9uCorZZ4I2r4C7aJgO7ZV9iE49Dm6NvOWx+pWE9CUq3zbdTp9doz38TbXtzqH9RT5CyWe422OaZoZGeZCabrhPQY9HjwsjpTvCg4YtlE2+Ta/j2bzn8fqrDqgm+6yUHOmAvWUjAtGhbNYvsBknDnqH1Qhc7VmxHgeb/NbudA5j/UXlYwif2p6luhAc9teu1npiHKnDs8if6tCm7JLX3NKpgttXe9ruc9mHMd7a83iwdxF5vt8tutARaCeklRnNK9C8WnNF7geJQ4T4XG3JhSnVdilQrG+yOnrlVHfsEGYzhNBn7Lu6tS7+HJafJQ4EMiNlNqWXZ9WPvVgnVYHG5M1ByDXkT6leX2EgTqJtyt45yv7S2qO3sEZjZhDLXeR+YKdJ0Zdk8QocvH9N732KrNtq+FZ/zzIHABcJrYpd+Xv14lOd5ap76SgrduW/VTQ1qcQpqnbgu4ifZvUMNpd9XuoZmvCtPaQ2Y/BCHVLgbrJTeRPDdVf6pfMKDU2fOkHmVFFfXr3MsouLsnNvV5kRoe5+s431PeuoKPqWnaurY/ZPBEeqwceN4l96iwO6H7Mjq4y7VGPVNe10VaZMzVCPVWpI/Z6FZbcv5fMqGCU+dLfFGzj58jP8+bCdJCo7yzKTwdOF0bu9Ug7V4c+yz7FJfYeGoysUss0HssIdVZwYLDujMqlESoCdTtGsZtbHnJBeNdDSJSs0jTKdMJN1HNX54Wv7bvsU9NkVJVa13dX+/wuArV0X/l5RHyo/lnfF4G6p6DrS0kHdtXhy35TGErDPYZUn2WfWqDOo/lVqdMD2O/hKJhD7S/odukymq9s02QN4EEPR/zbaOumZc+r15zK1Zqznl9jsfiemTM1QmV3HUuTkedlg9HIQzRbUD93dfC+2tpj2fIHEH2+RqCCQH13gZq7hWXTNpVu19OB1fc9nQ0AKOKUb5lU0P1kDyOneoWk0lOZ9cIP0x7qu8+2BhCoR2wYu1+e7DmaXzBSsu5vaX1ne2zrpmUPTmxf7PM1Dm4y/vC7ny7Nif7+z/9ZmtM0Z3panPLtPmra9f16bcK0Dpbnwk43Vd/RHtu6zfNQTy1QBy3aqG2g9nVmxml+BOoJyT3NpWmn9xhfFnu4bvDa+44BXhqqfdf3uUF9+yz77AT31Yue2mjecYQ62NLfgkA9ghHqLNEhNem4H1c6vdyDxhf/bpz5m4coW/c39wi6VH2bPtHlcaV9cvXts+zxCe6rTeqc2ndL7uGd93QwM9bFcAzMoZZ7SgTBbWx+asui61h/iq1+RmjqdbnQXQ3T1DNQ63V/U9ucqm/pMzPb1rePsk/1iTOjgvatR4W3Lc8ULB78pELyrnAfeTcj1NU509/86mfJ33/8+Mf00a05UyPUEw7UVCeWG/WNEiExyHRMt5ltW30izUPk18ytt7lNfc8i//DvtvXto+ySA5BjljsLUF8lPkqMPEtW1JomDsiGBZ9Byb4NAvUITSN9GuwsIj6t6UTOqk7jJREkmzqli8xIs96udSO20sX0H1vW92IL9e1a9rgqVyf91gbPsTy9UD9n9lOkT8k+RfkFR5PMNqxOcdSf32PBvg3vilO+zdxE+okx9Wm0ph36XYsRZCpMF993GOk5qvqB3Dct6jvssb67KvuUNJ3frw92bhr8/STSF0JdRPMLpUCgnsgo9S76PZ246ZFk1wWvK5m3vVoYvW1Sz7nN91jfXbQ1ZQc7TW6HeaoOalypG/8/p/rP1aNAc6ZHzSnfdqPUPhdy2PQw6Nz9gSVhuhiqueUHR3uu7y7K3rdDX4u46ZrPbUa0IFBZ0seKQ3XQTRt2vm3W/a2DbNKys++rvm3ep6+y1x2UdP3bWU9lzra47U1GmlctX/sQ23t+aOlByLTh/4NAPaCRxtcdO5HLSJ/6vNtCwGx67VPmPbvWd1q9frKHtp4kAqRJ2HR9j762JfX3bZ//elPtj13PPDx1+D5tqk/Xi6NO8SHz7MmH19dXrdBNfVFP6T2PT1UHNit87/t4m5+aRH+nQBdvqyhZDKJLfZs8h7XPsqdV2ZOV+tanKB8aln0dyxdAXbV4j4gvt4oMOrbP6vbU73NW7TMlbdTnPrWpfqXfh9HKZ9vke7KuTeZRNtXRSe6+1FV//ce/ln5eXfsXgcqXzr6+9261M3moOoa7E6nvTZTfy7iNsmfb7kjfgXGsvxe0vihsEts9HTquPpt1q1vtahu2TqAiUAEEKj0zhwoARqgAu/OnX/442WH+9xc/Wvr58re/Tr7f41/+ZsRqhAoACFQAEKgAcHjMoQJskJsz/eqrr5Z+vvr7v5fmQFevAl5lztQIFQAQqAAgUAHgIJlDBdhgdQ41N2eKESoAIFABQKACwFEwhwoARqgAIFABQKACAAIVAAQqAAhUABCoAIBABQCBCgACFQAEKgAgUAFAoAKAQAUAgQoACFQAEKgAIFABQKACAAIVAAQqAAhUABCoAIBABQCBCgACFQAQqAAgUAFAoAKAQAUAlvwPcFDns1DsH4sAAAAASUVORK5CYII=");
// EXTERNAL MODULE: ./Loader.css
var Loader_0 = __webpack_require__(1388);
;// CONCATENATED MODULE: ./Loader.ts
var Loader_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};








/**
 * Pre-loading assets
 *
 * The loader provides a mechanism to preload multiple resources at
 * one time. The loader must be passed to the engine in order to
 * trigger the loading progress bar.
 *
 * The [[Loader]] itself implements [[Loadable]] so you can load loaders.
 *
 * ## Example: Pre-loading resources for a game
 *
 * ```js
 * // create a loader
 * var loader = new ex.Loader();
 *
 * // create a resource dictionary (best practice is to keep a separate file)
 * var resources = {
 *   TextureGround: new ex.Texture("/images/textures/ground.png"),
 *   SoundDeath: new ex.Sound("/sound/death.wav", "/sound/death.mp3")
 * };
 *
 * // loop through dictionary and add to loader
 * for (var loadable in resources) {
 *   if (resources.hasOwnProperty(loadable)) {
 *     loader.addResource(resources[loadable]);
 *   }
 * }
 *
 * // start game
 * game.start(loader).then(function () {
 *   console.log("Game started!");
 * });
 * ```
 *
 * ## Customize the Loader
 *
 * The loader can be customized to show different, text, logo, background color, and button.
 *
 * ```typescript
 * const loader = new ex.Loader([playerTexture]);
 *
 * // The loaders button text can simply modified using this
 * loader.playButtonText = 'Start the best game ever';
 *
 * // The logo can be changed by inserting a base64 image string here
 *
 * loader.logo = 'data:image/png;base64,iVBORw...';
 * loader.logoWidth = 15;
 * loader.logoHeight = 14;
 *
 * // The background color can be changed like so by supplying a valid CSS color string
 *
 * loader.backgroundColor = 'red'
 * loader.backgroundColor = '#176BAA'
 *
 * // To build a completely new button
 * loader.startButtonFactory = () => {
 *     let myButton = document.createElement('button');
 *     myButton.textContent = 'The best button';
 *     return myButton;
 * };
 *
 * engine.start(loader).then(() => {});
 * ```
 */
class Loader extends Class {
    /**
     * @param loadables  Optionally provide the list of resources you want to load at constructor time
     */
    constructor(loadables) {
        super();
        this.canvas = new Canvas({
            smoothing: true,
            draw: this.draw.bind(this)
        });
        this._resourceList = [];
        this._index = 0;
        this._playButtonShown = false;
        this._resourceCount = 0;
        this._numLoaded = 0;
        this._progressCounts = {};
        this._totalCounts = {};
        // logo drawing stuff
        // base64 string encoding of the excalibur logo (logo-white.png)
        this.logo = Loader_logo;
        this.logoWidth = 468;
        this.logoHeight = 118;
        /**
         * Gets or sets the color of the loading bar, default is [[Color.White]]
         */
        this.loadingBarColor = Color.White;
        /**
         * Gets or sets the background color of the loader as a hex string
         */
        this.backgroundColor = '#176BAA';
        this.suppressPlayButton = false;
        /** Loads the css from Loader.css */
        this._playButtonStyles = Loader_0/* default.toString */.Z.toString();
        /**
         * Get/set play button text
         */
        this.playButtonText = 'Play game';
        /**
         * Return a html button element for excalibur to use as a play button
         */
        this.startButtonFactory = () => {
            let buttonElement = document.getElementById('excalibur-play');
            if (!buttonElement) {
                buttonElement = document.createElement('button');
            }
            buttonElement.id = 'excalibur-play';
            buttonElement.textContent = this.playButtonText;
            buttonElement.style.display = 'none';
            return buttonElement;
        };
        if (loadables) {
            this.addResources(loadables);
        }
    }
    get _image() {
        if (!this._imageElement) {
            this._imageElement = new Image();
            this._imageElement.src = this.logo;
        }
        return this._imageElement;
    }
    get playButtonRootElement() {
        return this._playButtonRootElement;
    }
    get playButtonElement() {
        return this._playButtonElement;
    }
    get _playButton() {
        const existingRoot = document.getElementById('excalibur-play-root');
        if (existingRoot) {
            this._playButtonRootElement = existingRoot;
        }
        if (!this._playButtonRootElement) {
            this._playButtonRootElement = document.createElement('div');
            this._playButtonRootElement.id = 'excalibur-play-root';
            this._playButtonRootElement.style.position = 'absolute';
            document.body.appendChild(this._playButtonRootElement);
        }
        if (!this._styleBlock) {
            this._styleBlock = document.createElement('style');
            this._styleBlock.textContent = this._playButtonStyles;
            document.head.appendChild(this._styleBlock);
        }
        if (!this._playButtonElement) {
            this._playButtonElement = this.startButtonFactory();
            this._playButtonRootElement.appendChild(this._playButtonElement);
        }
        return this._playButtonElement;
    }
    wireEngine(engine) {
        this._engine = engine;
        this.canvas.width = this._engine.canvas.width;
        this.canvas.height = this._engine.canvas.height;
    }
    /**
     * Add a resource to the loader to load
     * @param loadable  Resource to add
     */
    addResource(loadable) {
        const key = this._index++;
        this._resourceList.push(loadable);
        this._progressCounts[key] = 0;
        this._totalCounts[key] = 1;
        this._resourceCount++;
    }
    /**
     * Add a list of resources to the loader to load
     * @param loadables  The list of resources to load
     */
    addResources(loadables) {
        let i = 0;
        const len = loadables.length;
        for (i; i < len; i++) {
            this.addResource(loadables[i]);
        }
    }
    /**
     * Returns true if the loader has completely loaded all resources
     */
    isLoaded() {
        return this._numLoaded === this._resourceCount;
    }
    /**
     * Shows the play button and returns a promise that resolves when clicked
     */
    showPlayButton() {
        var _a;
        if (this.suppressPlayButton) {
            this.hidePlayButton();
            return Promise.resolve();
        }
        else {
            const resizeHandler = () => {
                this._positionPlayButton();
            };
            if ((_a = this._engine) === null || _a === void 0 ? void 0 : _a.browser) {
                this._engine.browser.window.on('resize', resizeHandler);
            }
            this._playButtonShown = true;
            this._playButton.style.display = 'block';
            document.body.addEventListener('keyup', (evt) => {
                if (evt.key === 'Enter') {
                    this._playButton.click();
                }
            });
            const promise = new Promise((resolve) => {
                const startButtonHandler = (e) => {
                    var _a;
                    // We want to stop propogation to keep bubbling to the engine pointer handlers
                    e.stopPropagation();
                    // Hide Button after click
                    this.hidePlayButton();
                    if ((_a = this._engine) === null || _a === void 0 ? void 0 : _a.browser) {
                        this._engine.browser.window.off('resize', resizeHandler);
                    }
                    resolve();
                };
                this._playButton.addEventListener('click', startButtonHandler);
                this._playButton.addEventListener('touchend', startButtonHandler);
                this._playButton.addEventListener('pointerup', startButtonHandler);
            });
            return promise;
        }
    }
    hidePlayButton() {
        this._playButtonShown = false;
        this._playButton.style.display = 'none';
    }
    /**
     * Clean up generated elements for the loader
     */
    dispose() {
        if (this._playButtonRootElement.parentElement) {
            this._playButtonRootElement.removeChild(this._playButtonElement);
            document.body.removeChild(this._playButtonRootElement);
            document.head.removeChild(this._styleBlock);
            this._playButtonRootElement = null;
            this._playButtonElement = null;
            this._styleBlock = null;
        }
    }
    update(_engine, _delta) {
        // override me
    }
    /**
     * Begin loading all of the supplied resources, returning a promise
     * that resolves when loading of all is complete
     */
    load() {
        return Loader_awaiter(this, void 0, void 0, function* () {
            yield Promise.all(this._resourceList.map((r) => r.load().finally(() => {
                // capture progress
                this._numLoaded++;
            })));
            // short delay in showing the button for aesthetics
            yield delay(200);
            yield this.showPlayButton();
            // Unlock browser AudioContext in after user gesture
            // See: https://github.com/excaliburjs/Excalibur/issues/262
            // See: https://github.com/excaliburjs/Excalibur/issues/1031
            yield WebAudio.unlock();
            return (this.data = this._resourceList);
        });
    }
    markResourceComplete() {
        this._numLoaded++;
    }
    /**
     * Returns the progess of the loader as a number between [0, 1] inclusive.
     */
    get progress() {
        return this._resourceCount > 0 ? clamp(this._numLoaded, 0, this._resourceCount) / this._resourceCount : 1;
    }
    _positionPlayButton() {
        const screenHeight = this._engine.screen.viewport.height;
        const screenWidth = this._engine.screen.viewport.width;
        if (this._playButtonRootElement) {
            const left = this._engine.canvas.offsetLeft;
            const top = this._engine.canvas.offsetTop;
            const buttonWidth = this._playButton.clientWidth;
            const buttonHeight = this._playButton.clientHeight;
            if (this.playButtonPosition) {
                this._playButtonRootElement.style.left = `${this.playButtonPosition.x}px`;
                this._playButtonRootElement.style.top = `${this.playButtonPosition.y}px`;
            }
            else {
                this._playButtonRootElement.style.left = `${left + screenWidth / 2 - buttonWidth / 2}px`;
                this._playButtonRootElement.style.top = `${top + screenHeight / 2 - buttonHeight / 2 + 100}px`;
            }
        }
    }
    /**
     * Loader draw function. Draws the default Excalibur loading screen.
     * Override `logo`, `logoWidth`, `logoHeight` and `backgroundColor` properties
     * to customize the drawing, or just override entire method.
     */
    draw(ctx) {
        const canvasHeight = this._engine.canvasHeight / this._engine.pixelRatio;
        const canvasWidth = this._engine.canvasWidth / this._engine.pixelRatio;
        this._positionPlayButton();
        ctx.fillStyle = this.backgroundColor;
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        let logoY = canvasHeight / 2;
        const width = Math.min(this.logoWidth, canvasWidth * 0.75);
        let logoX = canvasWidth / 2 - width / 2;
        if (this.logoPosition) {
            logoX = this.logoPosition.x;
            logoY = this.logoPosition.y;
        }
        const imageHeight = Math.floor(width * (this.logoHeight / this.logoWidth)); // OG height/width factor
        const oldAntialias = this._engine.getAntialiasing();
        this._engine.setAntialiasing(true);
        if (!this.logoPosition) {
            ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, logoX, logoY - imageHeight - 20, width, imageHeight);
        }
        else {
            ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, logoX, logoY, width, imageHeight);
        }
        // loading box
        if (!this.suppressPlayButton && this._playButtonShown) {
            this._engine.setAntialiasing(oldAntialias);
            return;
        }
        let loadingX = logoX;
        let loadingY = logoY;
        if (this.loadingBarPosition) {
            loadingX = this.loadingBarPosition.x;
            loadingY = this.loadingBarPosition.y;
        }
        ctx.lineWidth = 2;
        roundRect(ctx, loadingX, loadingY, width, 20, 10, this.loadingBarColor);
        const progress = width * this.progress;
        const margin = 5;
        const progressWidth = progress - margin * 2;
        const height = 20 - margin * 2;
        roundRect(ctx, loadingX + margin, loadingY + margin, progressWidth > 10 ? progressWidth : 10, height, 5, null, this.loadingBarColor);
        this._engine.setAntialiasing(oldAntialias);
    }
}

;// CONCATENATED MODULE: ./Util/Detector.ts

/**
 * This is the list of features that will be used to log the supported
 * features to the console when Detector.logBrowserFeatures() is called.
 */
const REPORTED_FEATURES = {
    webgl: 'WebGL',
    webaudio: 'WebAudio',
    gamepadapi: 'Gamepad API'
};
/**
 * Excalibur internal feature detection helper class
 */
class Detector {
    constructor() {
        this._features = null;
        this.failedTests = [];
        // critical browser features required for ex to run
        this._criticalTests = {
            // Test canvas/2d context support
            canvasSupport: function () {
                const elem = document.createElement('canvas');
                return !!(elem.getContext && elem.getContext('2d'));
            },
            // Test array buffer support ex uses for downloading binary data
            arrayBufferSupport: function () {
                const xhr = new XMLHttpRequest();
                xhr.open('GET', '/');
                try {
                    xhr.responseType = 'arraybuffer';
                }
                catch (e) {
                    return false;
                }
                return xhr.responseType === 'arraybuffer';
            },
            // Test data urls ex uses for sprites
            dataUrlSupport: function () {
                const canvas = document.createElement('canvas');
                return canvas.toDataURL('image/png').indexOf('data:image/png') === 0;
            },
            // Test object url support for loading
            objectUrlSupport: function () {
                return 'URL' in window && 'revokeObjectURL' in URL && 'createObjectURL' in URL;
            },
            // RGBA support for colors
            rgbaSupport: function () {
                const style = document.createElement('a').style;
                style.cssText = 'background-color:rgba(150,255,150,.5)';
                return ('' + style.backgroundColor).indexOf('rgba') > -1;
            }
        };
        // warnings excalibur performance will be degraded
        this._warningTest = {
            webAudioSupport: function () {
                return !!(window.AudioContext ||
                    window.webkitAudioContext ||
                    window.mozAudioContext ||
                    window.msAudioContext ||
                    window.oAudioContext);
            },
            webglSupport: function () {
                const elem = document.createElement('canvas');
                return !!(elem.getContext && elem.getContext('webgl'));
            }
        };
        this._features = this._loadBrowserFeatures();
    }
    /**
     * Returns a map of currently supported browser features. This method
     * treats the features as a singleton and will only calculate feature
     * support if it has not previously been done.
     */
    getBrowserFeatures() {
        if (this._features === null) {
            this._features = this._loadBrowserFeatures();
        }
        return this._features;
    }
    /**
     * Report on non-critical browser support for debugging purposes.
     * Use native browser console colors for visibility.
     */
    logBrowserFeatures() {
        let msg = '%cSUPPORTED BROWSER FEATURES\n==========================%c\n';
        const args = ['font-weight: bold; color: navy', 'font-weight: normal; color: inherit'];
        const supported = this.getBrowserFeatures();
        for (const feature of Object.keys(REPORTED_FEATURES)) {
            if (supported[feature]) {
                msg += '(%c\u2713%c)'; // (â)
                args.push('font-weight: bold; color: green');
                args.push('font-weight: normal; color: inherit');
            }
            else {
                msg += '(%c\u2717%c)'; // (â)
                args.push('font-weight: bold; color: red');
                args.push('font-weight: normal; color: inherit');
            }
            msg += ' ' + REPORTED_FEATURES[feature] + '\n';
        }
        args.unshift(msg);
        // eslint-disable-next-line no-console
        console.log.apply(console, args);
    }
    /**
     * Executes several IIFE's to get a constant reference to supported
     * features within the current execution context.
     */
    _loadBrowserFeatures() {
        return {
            // IIFE to check canvas support
            canvas: (() => {
                return this._criticalTests.canvasSupport();
            })(),
            // IIFE to check arraybuffer support
            arraybuffer: (() => {
                return this._criticalTests.arrayBufferSupport();
            })(),
            // IIFE to check dataurl support
            dataurl: (() => {
                return this._criticalTests.dataUrlSupport();
            })(),
            // IIFE to check objecturl support
            objecturl: (() => {
                return this._criticalTests.objectUrlSupport();
            })(),
            // IIFE to check rgba support
            rgba: (() => {
                return this._criticalTests.rgbaSupport();
            })(),
            // IIFE to check webaudio support
            webaudio: (() => {
                return this._warningTest.webAudioSupport();
            })(),
            // IIFE to check webgl support
            webgl: (() => {
                return this._warningTest.webglSupport();
            })(),
            // IIFE to check gamepadapi support
            gamepadapi: (() => {
                return !!navigator.getGamepads;
            })()
        };
    }
    test() {
        // Critical test will for ex not to run
        let failedCritical = false;
        for (const test in this._criticalTests) {
            if (!this._criticalTests[test].call(this)) {
                this.failedTests.push(test);
                Logger.getInstance().error('Critical browser feature missing, Excalibur requires:', test);
                failedCritical = true;
            }
        }
        if (failedCritical) {
            return false;
        }
        // Warning tests do not for ex to return false to compatibility
        for (const warning in this._warningTest) {
            if (!this._warningTest[warning]()) {
                Logger.getInstance().warn('Warning browser feature missing, Excalibur will have reduced performance:', warning);
            }
        }
        return true;
    }
}

;// CONCATENATED MODULE: ./Collision/CollisionType.ts
/**
 * An enum that describes the types of collisions bodies can participate in
 */
var CollisionType;
(function (CollisionType) {
    /**
     * Bodies with the `PreventCollision` setting do not participate in any
     * collisions and do not raise collision events.
     */
    CollisionType["PreventCollision"] = "PreventCollision";
    /**
     * Bodies with the `Passive` setting only raise collision events, but are not
     * influenced or moved by other bodies and do not influence or move other bodies.
     * This is useful for use in trigger type behavior.
     */
    CollisionType["Passive"] = "Passive";
    /**
     * Bodies with the `Active` setting raise collision events and participate
     * in collisions with other bodies and will be push or moved by bodies sharing
     * the `Active` or `Fixed` setting.
     */
    CollisionType["Active"] = "Active";
    /**
     * Bodies with the `Fixed` setting raise collision events and participate in
     * collisions with other bodies. Actors with the `Fixed` setting will not be
     * pushed or moved by other bodies sharing the `Fixed`. Think of Fixed
     * bodies as "immovable/unstoppable" objects. If two `Fixed` bodies meet they will
     * not be pushed or moved by each other, they will not interact except to throw
     * collision events.
     */
    CollisionType["Fixed"] = "Fixed";
})(CollisionType || (CollisionType = {}));

;// CONCATENATED MODULE: ./Collision/Physics.ts
var Physics_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


/**
 * Possible collision resolution strategies
 *
 * The default is [[CollisionResolutionStrategy.Arcade]] which performs simple axis aligned arcade style physics. This is useful for things
 * like platformers or top down games.
 *
 * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.Realistic]] which allows for complicated
 * simulated physical interactions.
 */
var CollisionResolutionStrategy;
(function (CollisionResolutionStrategy) {
    CollisionResolutionStrategy["Arcade"] = "arcade";
    CollisionResolutionStrategy["Realistic"] = "realistic";
})(CollisionResolutionStrategy || (CollisionResolutionStrategy = {}));
/**
 * Possible broadphase collision pair identification strategies
 *
 * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify
 * potential collision pairs which is O(nlog(n)) faster.
 */
var BroadphaseStrategy;
(function (BroadphaseStrategy) {
    BroadphaseStrategy[BroadphaseStrategy["DynamicAABBTree"] = 0] = "DynamicAABBTree";
})(BroadphaseStrategy || (BroadphaseStrategy = {}));
/**
 * Possible numerical integrators for position and velocity
 */
var Integrator;
(function (Integrator) {
    Integrator[Integrator["Euler"] = 0] = "Euler";
})(Integrator || (Integrator = {}));
/**
 * The [[Physics]] object is the global configuration object for all Excalibur physics.
 */
/* istanbul ignore next */
class Physics {
    static get gravity() {
        return Physics.acc;
    }
    static set gravity(v) {
        Physics.acc = v;
    }
    /**
     * Configures Excalibur to use "arcade" physics. Arcade physics which performs simple axis aligned arcade style physics.
     */
    static useArcadePhysics() {
        Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Arcade;
    }
    /**
     * Configures Excalibur to use rigid body physics. Rigid body physics allows for complicated
     * simulated physical interactions.
     */
    static useRealisticPhysics() {
        Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Realistic;
    }
    static get dynamicTreeVelocityMultiplyer() {
        return Physics.dynamicTreeVelocityMultiplier;
    }
    static set dynamicTreeVelocityMultiplyer(value) {
        Physics.dynamicTreeVelocityMultiplier = value;
    }
}
/**
 * Global acceleration that is applied to all vanilla actors that have a [[CollisionType.Active|active]] collision type.
 * Global acceleration won't effect [[Label|labels]], [[ScreenElement|ui actors]], or [[Trigger|triggers]] in Excalibur.
 *
 * This is a great way to globally simulate effects like gravity.
 */
Physics.acc = new Vector(0, 0);
/**
 * Globally switches all Excalibur physics behavior on or off.
 */
Physics.enabled = true;
/**
 * Gets or sets the broadphase pair identification strategy.
 *
 * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify
 * potential collision pairs which is O(nlog(n)) faster.
 */
Physics.broadphaseStrategy = BroadphaseStrategy.DynamicAABBTree;
/**
 * Gets or sets the global collision resolution strategy (narrowphase).
 *
 * The default is [[CollisionResolutionStrategy.Arcade]] which performs simple axis aligned arcade style physics.
 *
 * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.Realistic]] which allows for complicated
 * simulated physical interactions.
 */
Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Arcade;
/**
 * The default mass to use if none is specified
 */
Physics.defaultMass = 10;
/**
 * Gets or sets the position and velocity positional integrator, currently only Euler is supported.
 */
Physics.integrator = Integrator.Euler;
/**
 * Factor to add to the RigidBody BoundingBox, bounding box (dimensions += vel * dynamicTreeVelocityMultiplier);
 */
Physics.dynamicTreeVelocityMultiplier = 2;
/**
 * Pad RigidBody BoundingBox by a constant amount
 */
Physics.boundsPadding = 5;
/**
 * Number of position iterations (overlap) to run in the solver
 */
Physics.positionIterations = 3;
/**
 * Number of velocity iteration (response) to run in the solver
 */
Physics.velocityIterations = 8;
/**
 * Amount of overlap to tolerate in pixels
 */
Physics.slop = 1;
/**
 * Amount of positional overlap correction to apply each position iteration of the solver
 * O - meaning no correction, 1 - meaning correct all overlap
 */
Physics.steeringFactor = 0.2;
/**
 * Warm start set to true re-uses impulses from previous frames back in the solver
 */
Physics.warmStart = true;
/**
 * By default bodies do not sleep
 */
Physics.bodiesCanSleepByDefault = false;
/**
 * Surface epsilon is used to help deal with surface penetration
 */
Physics.surfaceEpsilon = 0.1;
Physics.sleepEpsilon = 0.07;
Physics.wakeThreshold = Physics.sleepEpsilon * 3;
Physics.sleepBias = 0.9;
/**
 * Enable fast moving body checking, this enables checking for collision pairs via raycast for fast moving objects to prevent
 * bodies from tunneling through one another.
 */
Physics.checkForFastBodies = true;
/**
 * Disable minimum fast moving body raycast, by default if ex.Physics.checkForFastBodies = true Excalibur will only check if the
 * body is moving at least half of its minimum dimension in an update. If ex.Physics.disableMinimumSpeedForFastBody is set to true,
 * Excalibur will always perform the fast body raycast regardless of speed.
 */
Physics.disableMinimumSpeedForFastBody = false;
Physics_decorate([
    obsolete({
        message: 'Alias for incorrect spelling used in older versions, will be removed in v0.25.0',
        alternateMethod: 'dynamicTreeVelocityMultiplier'
    })
], Physics, "dynamicTreeVelocityMultiplyer", null);

;// CONCATENATED MODULE: ./Math/vector-view.ts

class VectorView extends Vector {
    constructor(options) {
        super(0, 0);
        this._getX = options.getX;
        this._getY = options.getY;
        this._setX = options.setX;
        this._setY = options.setY;
    }
    get x() {
        return (this._x = this._getX());
    }
    set x(val) {
        this._setX(val);
        this._x = val;
    }
    get y() {
        return (this._y = this._getY());
    }
    set y(val) {
        this._setY(val);
        this._y = val;
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/Component.ts
/**
 * Type guard to check if a component implements clone
 * @param x
 */
function hasClone(x) {
    return !!(x === null || x === void 0 ? void 0 : x.clone);
}
/**
 * Components are containers for state in Excalibur, the are meant to convey capabilities that an Entity posesses
 *
 * Implementations of Component must have a zero-arg constructor to support dependecies
 *
 * ```typescript
 * class MyComponent extends ex.Component<'my'> {
 *   public readonly type = 'my';
 *   // zero arg support required if you want to use component dependencies
 *   constructor(public optionalPos?: ex.Vector) {}
 * }
 * ```
 */
class Component {
    constructor() {
        /**
         * Current owning [[Entity]], if any, of this component. Null if not added to any [[Entity]]
         */
        this.owner = null;
    }
    /**
     * Clones any properties on this component, if that property value has a `clone()` method it will be called
     */
    clone() {
        const newComponent = new this.constructor();
        for (const prop in this) {
            if (this.hasOwnProperty(prop)) {
                const val = this[prop];
                if (hasClone(val) && prop !== 'owner' && prop !== 'clone') {
                    newComponent[prop] = val.clone();
                }
                else {
                    newComponent[prop] = val;
                }
            }
        }
        return newComponent;
    }
}
/**
 * Tag components are a way of tagging a component with label and a simple value
 *
 * For example:
 *
 * ```typescript
 * const isOffscreen = new TagComponent('offscreen');
 * entity.addComponent(isOffscreen);
 * entity.tags.includes
 * ```
 */
class TagComponent extends Component {
    constructor(type, value) {
        super();
        this.type = type;
        this.value = value;
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/Components/TransformComponent.ts




const createPosView = (matrix) => {
    const source = matrix;
    return new VectorView({
        setX: (x) => {
            source.data[MatrixLocations.X] = x;
        },
        setY: (y) => {
            source.data[MatrixLocations.Y] = y;
        },
        getX: () => {
            return source.data[MatrixLocations.X];
        },
        getY: () => {
            return source.data[MatrixLocations.Y];
        }
    });
};
const createScaleView = (matrix) => {
    const source = matrix;
    return new VectorView({
        setX: (x) => {
            source.setScaleX(x);
        },
        setY: (y) => {
            source.setScaleY(y);
        },
        getX: () => {
            return source.getScaleX();
        },
        getY: () => {
            return source.getScaleY();
        }
    });
};
/**
 * Enum representing the coordinate plane for the position 2D vector in the [[TransformComponent]]
 */
var CoordPlane;
(function (CoordPlane) {
    /**
     * The world coordinate plane (default) represents world space, any entities drawn with world
     * space move when the camera moves.
     */
    CoordPlane["World"] = "world";
    /**
     * The screen coordinate plane represents screen space, entities drawn in screen space are pinned
     * to screen coordinates ignoring the camera.
     */
    CoordPlane["Screen"] = "screen";
})(CoordPlane || (CoordPlane = {}));
class TransformComponent extends Component {
    constructor() {
        super(...arguments);
        this.type = 'ex.transform';
        this._dirty = false;
        this.matrix = Matrix.identity().translate(0, 0).rotate(0).scale(1, 1);
        this._position = createPosView(this.matrix);
        this._rotation = 0;
        this._scale = createScaleView(this.matrix);
        /**
         * The [[CoordPlane|coordinate plane|]] for this transform for the entity.
         */
        this.coordPlane = CoordPlane.World;
        /**
         * The z-index ordering of the entity, a higher values are drawn on top of lower values.
         * For example z=99 would be drawn on top of z=0.
         */
        this.z = 0;
    }
    _recalculate() {
        this._rotation = this.matrix.getRotation();
        this._dirty = false;
    }
    getGlobalMatrix() {
        if (!this.parent) {
            return this.matrix;
        }
        else {
            return this.parent.getGlobalMatrix().multm(this.matrix);
        }
    }
    getGlobalTransform() {
        return {
            pos: this.globalPos,
            scale: this.globalScale,
            rotation: this.globalRotation,
            z: this.z,
            coordPlane: this.coordPlane
        };
    }
    get parent() {
        var _a, _b;
        return (_b = (_a = this === null || this === void 0 ? void 0 : this.owner) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.get(TransformComponent);
    }
    /**
     * The current position of the entity in world space or in screen space depending on the the [[CoordPlane|coordinate plane]].
     *
     * If a parent entity exists coordinates are local to the parent.
     */
    get pos() {
        if (this._dirty) {
            this._recalculate();
        }
        return this._position;
    }
    set pos(val) {
        this.matrix.setPosition(val.x, val.y);
        this._dirty = true;
    }
    // Dirty flag check up the chain
    get dirty() {
        var _a;
        if ((_a = this === null || this === void 0 ? void 0 : this.owner) === null || _a === void 0 ? void 0 : _a.parent) {
            const parent = this.parent;
            return parent.dirty || this._dirty;
        }
        return this._dirty;
    }
    /**
     * The current world position calculated
     */
    get globalPos() {
        const source = this.getGlobalMatrix();
        return new VectorView({
            getX: () => source.data[MatrixLocations.X],
            getY: () => source.data[MatrixLocations.Y],
            setX: (x) => {
                var _a;
                if (this.parent) {
                    const [newX] = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.getGlobalMatrix().getAffineInverse().multv([x, source.data[MatrixLocations.Y]]);
                    this.matrix.data[MatrixLocations.X] = newX;
                }
                else {
                    this.matrix.data[MatrixLocations.X] = x;
                }
            },
            setY: (y) => {
                var _a;
                if (this.parent) {
                    const [, newY] = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.getGlobalMatrix().getAffineInverse().multv([source.data[MatrixLocations.X], y]);
                    this.matrix.data[MatrixLocations.Y] = newY;
                }
                else {
                    this.matrix.data[MatrixLocations.Y] = y;
                }
            }
        });
    }
    set globalPos(val) {
        const parentTransform = this.parent;
        if (!parentTransform) {
            this.pos = val;
        }
        else {
            this.pos = parentTransform.getGlobalMatrix().getAffineInverse().multv(val);
        }
    }
    /**
     * The rotation of the entity in radians. For example `Math.PI` radians is the same as 180 degrees.
     */
    get rotation() {
        if (this._dirty) {
            this._recalculate();
        }
        return this._rotation;
    }
    set rotation(val) {
        this.matrix.setRotation(val);
        this._dirty = true;
    }
    get globalRotation() {
        return this.getGlobalMatrix().getRotation();
    }
    set globalRotation(val) {
        const parentTransform = this.parent;
        if (!parentTransform) {
            this.rotation = val;
        }
        else {
            this.rotation = val - parentTransform.globalRotation;
        }
    }
    /**
     * The scale of the entity.
     */
    get scale() {
        if (this._dirty) {
            this._recalculate();
        }
        return this._scale;
    }
    set scale(val) {
        this.matrix.setScale(val);
        this._dirty = true;
    }
    get globalScale() {
        const source = this.getGlobalMatrix();
        return new VectorView({
            getX: () => source.getScaleX(),
            getY: () => source.getScaleY(),
            setX: (x) => {
                if (this.parent) {
                    const globalScaleX = this.parent.globalScale.x;
                    this.matrix.setScaleX(x / globalScaleX);
                }
                else {
                    this.matrix.setScaleX(x);
                }
            },
            setY: (y) => {
                if (this.parent) {
                    const globalScaleY = this.parent.globalScale.y;
                    this.matrix.setScaleY(y / globalScaleY);
                }
                else {
                    this.matrix.setScaleY(y);
                }
            }
        });
    }
    set globalScale(val) {
        const parentTransform = this.parent;
        if (!parentTransform) {
            this.scale = val;
        }
        else {
            this.scale = vec(val.x / parentTransform.globalScale.x, val.y / parentTransform.globalScale.y);
        }
    }
    /**
     * Apply the transform to a point
     * @param point
     */
    apply(point) {
        return this.matrix.multv(point);
    }
    /**
     * Apply the inverse transform to a point
     * @param point
     */
    applyInverse(point) {
        return this.matrix.getAffineInverse().multv(point);
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/Components/MotionComponent.ts


class MotionComponent extends Component {
    constructor() {
        super(...arguments);
        this.type = 'ex.motion';
        /**
         * The velocity of an entity in pixels per second
         */
        this.vel = Vector.Zero;
        /**
         * The acceleration of entity in pixels per second^2
         */
        this.acc = Vector.Zero;
        /**
         * The scale rate of change in scale units per second
         */
        this.scaleFactor = Vector.Zero;
        /**
         * The angular velocity which is how quickly the entity is rotating in radians per second
         */
        this.angularVelocity = 0;
        /**
         * The amount of torque applied to the entity, angular acceleration is torque * inertia
         */
        this.torque = 0;
        /**
         * Inerita can be thought of as the resistance to motion
         */
        this.inertia = 1;
    }
}

;// CONCATENATED MODULE: ./Collision/Group/CollisionGroup.ts
/**
 * CollisionGroups indicate like members that do not collide with each other. Use [[CollisionGroupManager]] to create [[CollisionGroup]]s
 *
 * For example:
 *
 * Players have collision group "player"
 *
 * ![Player Collision Group](/assets/images/docs/CollisionGroupsPlayer.png)
 *
 * Enemies have collision group "enemy"
 *
 * ![Enemy Collision Group](/assets/images/docs/CollisionGroupsEnemy.png)
 *
 * Blocks have collision group "ground"
 *
 * ![Ground collision group](/assets/images/docs/CollisionGroupsGround.png)
 *
 * Players don't collide with each other, but enemies and blocks. Likewise, enemies don't collide with each other but collide
 * with players and blocks.
 *
 * This is done with bitmasking, see the following pseudo-code
 *
 * PlayerGroup = `0b001`
 * PlayerGroupMask = `0b110`
 *
 * EnemyGroup = `0b010`
 * EnemyGroupMask = `0b101`
 *
 * BlockGroup = `0b100`
 * BlockGroupMask = `0b011`
 *
 * Should Players collide? No because the bitwise mask evaluates to 0
 * `(player1.group & player2.mask) === 0`
 * `(0b001 & 0b110) === 0`
 *
 * Should Players and Enemies collide? Yes because the bitwise mask is non-zero
 * `(player1.group & enemy1.mask) === 1`
 * `(0b001 & 0b101) === 1`
 *
 * Should Players and Blocks collide? Yes because the bitwise mask is non-zero
 * `(player1.group & blocks1.mask) === 1`
 * `(0b001 & 0b011) === 1`
 */
class CollisionGroup {
    /**
     * STOP!!** It is preferred that [[CollisionGroupManager.create]] is used to create collision groups
     *  unless you know how to construct the proper bitmasks. See https://github.com/excaliburjs/Excalibur/issues/1091 for more info.
     * @param name Name of the collision group
     * @param category 32 bit category for the group, should be a unique power of 2. For example `0b001` or `0b010`
     * @param mask 32 bit mask of category, or `~category` generally. For a category of `0b001`, the mask would be `0b110`
     */
    constructor(name, category, mask) {
        this._name = name;
        this._category = category;
        this._mask = mask;
    }
    /**
     * Get the name of the collision group
     */
    get name() {
        return this._name;
    }
    /**
     * Get the category of the collision group, a 32 bit number which should be a unique power of 2
     */
    get category() {
        return this._category;
    }
    /**
     * Get the mask for this collision group
     */
    get mask() {
        return this._mask;
    }
    /**
     * Evaluates whether 2 collision groups can collide
     * @param other  CollisionGroup
     */
    canCollide(other) {
        return (this.category & other.mask) !== 0 && (other.category & this.mask) !== 0;
    }
    /**
     * Inverts the collision group. For example, if before the group specified "players",
     * inverting would specify all groups except players
     * @returns CollisionGroup
     */
    invert() {
        return new CollisionGroup('~(' + this.name + ')', ~this.category, ~this.mask);
    }
    /**
     * Combine collision groups with each other. The new group includes all of the previous groups.
     *
     * @param collisionGroups
     * @returns
     */
    static combine(collisionGroups) {
        const combinedName = collisionGroups.map((c) => c.name).join('+');
        const combinedCategory = collisionGroups.reduce((current, g) => g.category | current, 0b0);
        const combinedMask = ~combinedCategory;
        return new CollisionGroup(combinedName, combinedCategory, combinedMask);
    }
    /**
     * Creates a collision group that collides with the listed groups
     * @param collisionGroups
     */
    static collidesWith(collisionGroups) {
        return CollisionGroup.combine(collisionGroups).invert();
    }
}
/**
 * The `All` [[CollisionGroup]] is a special group that collides with all other groups including itself,
 * it is the default collision group on colliders.
 */
CollisionGroup.All = new CollisionGroup('Collide with all groups', -1, -1);

;// CONCATENATED MODULE: ./Util/Observable.ts
/**
 * Simple Observable implemenation
 * @template T is the typescript Type that defines the data being observed
 */
class Observable {
    constructor() {
        this.observers = [];
        this.subscriptions = [];
    }
    /**
     * Register an observer to listen to this observable
     * @param observer
     */
    register(observer) {
        this.observers.push(observer);
    }
    /**
     * Register a callback to listen to this observable
     * @param func
     */
    subscribe(func) {
        this.subscriptions.push(func);
    }
    /**
     * Remove an observer from the observable
     * @param observer
     */
    unregister(observer) {
        const i = this.observers.indexOf(observer);
        if (i !== -1) {
            this.observers.splice(i, 1);
        }
    }
    /**
     * Remove a callback that is listening to this observable
     * @param func
     */
    unsubscribe(func) {
        const i = this.subscriptions.indexOf(func);
        if (i !== -1) {
            this.subscriptions.splice(i, 1);
        }
    }
    /**
     * Broadcasts a message to all observers and callbacks
     * @param message
     */
    notifyAll(message) {
        this.observers.forEach((o) => o.notify(message));
        this.subscriptions.forEach(cb => cb(message));
    }
    /**
     * Removes all observers and callbacks
     */
    clear() {
        this.observers.length = 0;
        this.subscriptions.length = 0;
    }
}

;// CONCATENATED MODULE: ./Collision/Detection/Pair.ts


/**
 * Models a potential collision between 2 colliders
 */
class Pair {
    constructor(colliderA, colliderB) {
        this.colliderA = colliderA;
        this.colliderB = colliderB;
        this.id = null;
        this.id = Pair.calculatePairHash(colliderA.id, colliderB.id);
    }
    static canCollide(colliderA, colliderB) {
        var _a, _b;
        const bodyA = (_a = colliderA === null || colliderA === void 0 ? void 0 : colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
        const bodyB = (_b = colliderB === null || colliderB === void 0 ? void 0 : colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
        // Body's needed for collision in the current state
        // TODO can we collide without a body?
        if (!bodyA || !bodyB) {
            return false;
        }
        // If both are in the same collision group short circuit
        if (!bodyA.group.canCollide(bodyB.group)) {
            return false;
        }
        // if both are fixed short circuit
        if (bodyA.collisionType === CollisionType.Fixed && bodyB.collisionType === CollisionType.Fixed) {
            return false;
        }
        // if the either is prevent collision short circuit
        if (bodyB.collisionType === CollisionType.PreventCollision || bodyA.collisionType === CollisionType.PreventCollision) {
            return false;
        }
        // if either is dead short circuit
        if (!bodyA.active || !bodyB.active) {
            return false;
        }
        return true;
    }
    /**
     * Returns whether or not it is possible for the pairs to collide
     */
    get canCollide() {
        const colliderA = this.colliderA;
        const colliderB = this.colliderB;
        return Pair.canCollide(colliderA, colliderB);
    }
    /**
     * Runs the collision intersection logic on the members of this pair
     */
    collide() {
        return this.colliderA.collide(this.colliderB);
    }
    /**
     * Check if the collider is part of the pair
     * @param collider
     * @returns
     */
    hasCollider(collider) {
        return collider === this.colliderA || collider === this.colliderB;
    }
    /**
     * Calculates the unique pair hash id for this collision pair (owning id)
     */
    static calculatePairHash(idA, idB) {
        if (idA.value < idB.value) {
            return `#${idA.value}+${idB.value}`;
        }
        else {
            return `#${idB.value}+${idA.value}`;
        }
    }
}

;// CONCATENATED MODULE: ./Math/projection.ts
/**
 * A 1 dimensional projection on an axis, used to test overlaps
 */
class Projection {
    constructor(min, max) {
        this.min = min;
        this.max = max;
    }
    overlaps(projection) {
        return this.max > projection.min && projection.max > this.min;
    }
    getOverlap(projection) {
        if (this.overlaps(projection)) {
            if (this.max > projection.max) {
                return projection.max - this.min;
            }
            else {
                return this.max - projection.min;
            }
        }
        return 0;
    }
}

;// CONCATENATED MODULE: ./Collision/Detection/DynamicTree.ts





/**
 * Dynamic Tree Node used for tracking bounds within the tree
 */
class TreeNode {
    constructor(parent) {
        this.parent = parent;
        this.parent = parent || null;
        this.data = null;
        this.bounds = new BoundingBox();
        this.left = null;
        this.right = null;
        this.height = 0;
    }
    isLeaf() {
        return !this.left && !this.right;
    }
}
/**
 * The DynamicTrees provides a spatial partitioning data structure for quickly querying for overlapping bounding boxes for
 * all tracked bodies. The worst case performance of this is O(n*log(n)) where n is the number of bodies in the tree.
 *
 * Internally the bounding boxes are organized as a balanced binary tree of bounding boxes, where the leaf nodes are tracked bodies.
 * Every non-leaf node is a bounding box that contains child bounding boxes.
 */
class DynamicTree {
    constructor(worldBounds = new BoundingBox(-Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)) {
        this.worldBounds = worldBounds;
        this.root = null;
        this.nodes = {};
    }
    /**
     * Inserts a node into the dynamic tree
     */
    _insert(leaf) {
        // If there are no nodes in the tree, make this the root leaf
        if (this.root === null) {
            this.root = leaf;
            this.root.parent = null;
            return;
        }
        // Search the tree for a node that is not a leaf and find the best place to insert
        const leafAABB = leaf.bounds;
        let currentRoot = this.root;
        while (!currentRoot.isLeaf()) {
            const left = currentRoot.left;
            const right = currentRoot.right;
            const area = currentRoot.bounds.getPerimeter();
            const combinedAABB = currentRoot.bounds.combine(leafAABB);
            const combinedArea = combinedAABB.getPerimeter();
            // Calculate cost heuristic for creating a new parent and leaf
            const cost = 2 * combinedArea;
            // Minimum cost of pushing the leaf down the tree
            const inheritanceCost = 2 * (combinedArea - area);
            // Cost of descending
            let leftCost = 0;
            const leftCombined = leafAABB.combine(left.bounds);
            let newArea;
            let oldArea;
            if (left.isLeaf()) {
                leftCost = leftCombined.getPerimeter() + inheritanceCost;
            }
            else {
                oldArea = left.bounds.getPerimeter();
                newArea = leftCombined.getPerimeter();
                leftCost = newArea - oldArea + inheritanceCost;
            }
            let rightCost = 0;
            const rightCombined = leafAABB.combine(right.bounds);
            if (right.isLeaf()) {
                rightCost = rightCombined.getPerimeter() + inheritanceCost;
            }
            else {
                oldArea = right.bounds.getPerimeter();
                newArea = rightCombined.getPerimeter();
                rightCost = newArea - oldArea + inheritanceCost;
            }
            // cost is acceptable
            if (cost < leftCost && cost < rightCost) {
                break;
            }
            // Descend to the depths
            if (leftCost < rightCost) {
                currentRoot = left;
            }
            else {
                currentRoot = right;
            }
        }
        // Create the new parent node and insert into the tree
        const oldParent = currentRoot.parent;
        const newParent = new TreeNode(oldParent);
        newParent.bounds = leafAABB.combine(currentRoot.bounds);
        newParent.height = currentRoot.height + 1;
        if (oldParent !== null) {
            // The sibling node was not the root
            if (oldParent.left === currentRoot) {
                oldParent.left = newParent;
            }
            else {
                oldParent.right = newParent;
            }
            newParent.left = currentRoot;
            newParent.right = leaf;
            currentRoot.parent = newParent;
            leaf.parent = newParent;
        }
        else {
            // The sibling node was the root
            newParent.left = currentRoot;
            newParent.right = leaf;
            currentRoot.parent = newParent;
            leaf.parent = newParent;
            this.root = newParent;
        }
        // Walk up the tree fixing heights and AABBs
        let currentNode = leaf.parent;
        while (currentNode) {
            currentNode = this._balance(currentNode);
            if (!currentNode.left) {
                throw new Error('Parent of current leaf cannot have a null left child' + currentNode);
            }
            if (!currentNode.right) {
                throw new Error('Parent of current leaf cannot have a null right child' + currentNode);
            }
            currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
            currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
            currentNode = currentNode.parent;
        }
    }
    /**
     * Removes a node from the dynamic tree
     */
    _remove(leaf) {
        if (leaf === this.root) {
            this.root = null;
            return;
        }
        const parent = leaf.parent;
        const grandParent = parent.parent;
        let sibling;
        if (parent.left === leaf) {
            sibling = parent.right;
        }
        else {
            sibling = parent.left;
        }
        if (grandParent) {
            if (grandParent.left === parent) {
                grandParent.left = sibling;
            }
            else {
                grandParent.right = sibling;
            }
            sibling.parent = grandParent;
            let currentNode = grandParent;
            while (currentNode) {
                currentNode = this._balance(currentNode);
                currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
                currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
                currentNode = currentNode.parent;
            }
        }
        else {
            this.root = sibling;
            sibling.parent = null;
        }
    }
    /**
     * Tracks a body in the dynamic tree
     */
    trackCollider(collider) {
        const node = new TreeNode();
        node.data = collider;
        node.bounds = collider.bounds;
        node.bounds.left -= 2;
        node.bounds.top -= 2;
        node.bounds.right += 2;
        node.bounds.bottom += 2;
        this.nodes[collider.id.value] = node;
        this._insert(node);
    }
    /**
     * Updates the dynamic tree given the current bounds of each body being tracked
     */
    updateCollider(collider) {
        var _a;
        const node = this.nodes[collider.id.value];
        if (!node) {
            return false;
        }
        const b = collider.bounds;
        // if the body is outside the world no longer update it
        if (!this.worldBounds.contains(b)) {
            Logger.getInstance().warn('Collider with id ' + collider.id.value + ' is outside the world bounds and will no longer be tracked for physics');
            this.untrackCollider(collider);
            return false;
        }
        if (node.bounds.contains(b)) {
            return false;
        }
        this._remove(node);
        b.left -= Physics.boundsPadding;
        b.top -= Physics.boundsPadding;
        b.right += Physics.boundsPadding;
        b.bottom += Physics.boundsPadding;
        // THIS IS CAUSING UNECESSARY CHECKS
        if (collider.owner) {
            const body = (_a = collider.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
            if (body) {
                const multdx = ((body.vel.x * 32) / 1000) * Physics.dynamicTreeVelocityMultiplier;
                const multdy = ((body.vel.y * 32) / 1000) * Physics.dynamicTreeVelocityMultiplier;
                if (multdx < 0) {
                    b.left += multdx;
                }
                else {
                    b.right += multdx;
                }
                if (multdy < 0) {
                    b.top += multdy;
                }
                else {
                    b.bottom += multdy;
                }
            }
        }
        node.bounds = b;
        this._insert(node);
        return true;
    }
    /**
     * Untracks a body from the dynamic tree
     */
    untrackCollider(collider) {
        const node = this.nodes[collider.id.value];
        if (!node) {
            return;
        }
        this._remove(node);
        this.nodes[collider.id.value] = null;
        delete this.nodes[collider.id.value];
    }
    /**
     * Balances the tree about a node
     */
    _balance(node) {
        if (node === null) {
            throw new Error('Cannot balance at null node');
        }
        if (node.isLeaf() || node.height < 2) {
            return node;
        }
        const left = node.left;
        const right = node.right;
        const a = node;
        const b = left;
        const c = right;
        const d = left.left;
        const e = left.right;
        const f = right.left;
        const g = right.right;
        const balance = c.height - b.height;
        // Rotate c node up
        if (balance > 1) {
            // Swap the right node with it's parent
            c.left = a;
            c.parent = a.parent;
            a.parent = c;
            // The original node's old parent should point to the right node
            // this is mega confusing
            if (c.parent) {
                if (c.parent.left === a) {
                    c.parent.left = c;
                }
                else {
                    c.parent.right = c;
                }
            }
            else {
                this.root = c;
            }
            // Rotate
            if (f.height > g.height) {
                c.right = f;
                a.right = g;
                g.parent = a;
                a.bounds = b.bounds.combine(g.bounds);
                c.bounds = a.bounds.combine(f.bounds);
                a.height = 1 + Math.max(b.height, g.height);
                c.height = 1 + Math.max(a.height, f.height);
            }
            else {
                c.right = g;
                a.right = f;
                f.parent = a;
                a.bounds = b.bounds.combine(f.bounds);
                c.bounds = a.bounds.combine(g.bounds);
                a.height = 1 + Math.max(b.height, f.height);
                c.height = 1 + Math.max(a.height, g.height);
            }
            return c;
        }
        // Rotate left node up
        if (balance < -1) {
            // swap
            b.left = a;
            b.parent = a.parent;
            a.parent = b;
            // node's old parent should point to b
            if (b.parent) {
                if (b.parent.left === a) {
                    b.parent.left = b;
                }
                else {
                    if (b.parent.right !== a) {
                        throw 'Error rotating Dynamic Tree';
                    }
                    b.parent.right = b;
                }
            }
            else {
                this.root = b;
            }
            // rotate
            if (d.height > e.height) {
                b.right = d;
                a.left = e;
                e.parent = a;
                a.bounds = c.bounds.combine(e.bounds);
                b.bounds = a.bounds.combine(d.bounds);
                a.height = 1 + Math.max(c.height, e.height);
                b.height = 1 + Math.max(a.height, d.height);
            }
            else {
                b.right = e;
                a.left = d;
                d.parent = a;
                a.bounds = c.bounds.combine(d.bounds);
                b.bounds = a.bounds.combine(e.bounds);
                a.height = 1 + Math.max(c.height, d.height);
                b.height = 1 + Math.max(a.height, e.height);
            }
            return b;
        }
        return node;
    }
    /**
     * Returns the internal height of the tree, shorter trees are better. Performance drops as the tree grows
     */
    getHeight() {
        if (this.root === null) {
            return 0;
        }
        return this.root.height;
    }
    /**
     * Queries the Dynamic Axis Aligned Tree for bodies that could be colliding with the provided body.
     *
     * In the query callback, it will be passed a potential collider. Returning true from this callback indicates
     * that you are complete with your query and you do not want to continue. Returning false will continue searching
     * the tree until all possible colliders have been returned.
     */
    query(collider, callback) {
        const bounds = collider.bounds;
        const helper = (currentNode) => {
            if (currentNode && currentNode.bounds.intersect(bounds)) {
                if (currentNode.isLeaf() && currentNode.data !== collider) {
                    if (callback.call(collider, currentNode.data)) {
                        return true;
                    }
                }
                else {
                    return helper(currentNode.left) || helper(currentNode.right);
                }
            }
            return false;
        };
        helper(this.root);
    }
    /**
     * Queries the Dynamic Axis Aligned Tree for bodies that could be intersecting. By default the raycast query uses an infinitely
     * long ray to test the tree specified by `max`.
     *
     * In the query callback, it will be passed a potential body that intersects with the raycast. Returning true from this
     * callback indicates that your are complete with your query and do not want to continue. Return false will continue searching
     * the tree until all possible bodies that would intersect with the ray have been returned.
     */
    rayCastQuery(ray, max = Infinity, callback) {
        const helper = (currentNode) => {
            if (currentNode && currentNode.bounds.rayCast(ray, max)) {
                if (currentNode.isLeaf()) {
                    if (callback.call(ray, currentNode.data)) {
                        // ray hit a leaf! return the body
                        return true;
                    }
                }
                else {
                    // ray hit but not at a leaf, recurse deeper
                    return helper(currentNode.left) || helper(currentNode.right);
                }
            }
            return false; // ray missed
        };
        helper(this.root);
    }
    getNodes() {
        const helper = (currentNode) => {
            if (currentNode) {
                return [currentNode].concat(helper(currentNode.left), helper(currentNode.right));
            }
            else {
                return [];
            }
        };
        return helper(this.root);
    }
    debug(ex) {
        // draw all the nodes in the Dynamic Tree
        const helper = (currentNode) => {
            if (currentNode) {
                if (currentNode.isLeaf()) {
                    currentNode.bounds.draw(ex, Color.Green);
                }
                else {
                    currentNode.bounds.draw(ex, Color.White);
                }
                if (currentNode.left) {
                    helper(currentNode.left);
                }
                if (currentNode.right) {
                    helper(currentNode.right);
                }
            }
        };
        helper(this.root);
    }
}

;// CONCATENATED MODULE: ./Math/ray.ts
/**
 * A 2D ray that can be cast into the scene to do collision detection
 */
class Ray {
    /**
     * @param pos The starting position for the ray
     * @param dir The vector indicating the direction of the ray
     */
    constructor(pos, dir) {
        this.pos = pos;
        this.dir = dir.normalize();
    }
    /**
     * Tests a whether this ray intersects with a line segment. Returns a number greater than or equal to 0 on success.
     * This number indicates the mathematical intersection time.
     * @param line  The line to test
     */
    intersect(line) {
        const numerator = line.begin.sub(this.pos);
        // Test is line and ray are parallel and non intersecting
        if (this.dir.cross(line.getSlope()) === 0 && numerator.cross(this.dir) !== 0) {
            return -1;
        }
        // Lines are parallel
        const divisor = this.dir.cross(line.getSlope());
        if (divisor === 0) {
            return -1;
        }
        const t = numerator.cross(line.getSlope()) / divisor;
        if (t >= 0) {
            const u = numerator.cross(this.dir) / divisor / line.getLength();
            if (u >= 0 && u <= 1) {
                return t;
            }
        }
        return -1;
    }
    intersectPoint(line) {
        const time = this.intersect(line);
        if (time < 0) {
            return null;
        }
        return this.getPoint(time);
    }
    /**
     * Returns the point of intersection given the intersection time
     */
    getPoint(time) {
        return this.pos.add(this.dir.scale(time));
    }
}

;// CONCATENATED MODULE: ./Collision/Detection/DynamicTreeCollisionProcessor.ts









/**
 * Responsible for performing the collision broadphase (locating potential colllisions) and
 * the narrowphase (actual collision contacts)
 */
class DynamicTreeCollisionProcessor {
    constructor() {
        this._dynamicCollisionTree = new DynamicTree();
        this._collisions = new Set();
        this._collisionPairCache = [];
        this._colliders = [];
    }
    getColliders() {
        return this._colliders;
    }
    /**
     * Tracks a physics body for collisions
     */
    track(target) {
        if (!target) {
            Logger.getInstance().warn('Cannot track null collider');
            return;
        }
        if (target instanceof CompositeCollider) {
            const colliders = target.getColliders();
            for (const c of colliders) {
                c.owner = target.owner;
                this._colliders.push(c);
                this._dynamicCollisionTree.trackCollider(c);
            }
        }
        else {
            this._colliders.push(target);
            this._dynamicCollisionTree.trackCollider(target);
        }
    }
    /**
     * Untracks a physics body
     */
    untrack(target) {
        if (!target) {
            Logger.getInstance().warn('Cannot untrack a null collider');
            return;
        }
        if (target instanceof CompositeCollider) {
            const colliders = target.getColliders();
            for (const c of colliders) {
                const index = this._colliders.indexOf(c);
                if (index !== -1) {
                    this._colliders.splice(index, 1);
                }
                this._dynamicCollisionTree.untrackCollider(c);
            }
        }
        else {
            const index = this._colliders.indexOf(target);
            if (index !== -1) {
                this._colliders.splice(index, 1);
            }
            this._dynamicCollisionTree.untrackCollider(target);
        }
    }
    _shouldGenerateCollisionPair(colliderA, colliderB) {
        // if the collision pair must be 2 separate colliders
        // Also separate owners for composite colliders
        if ((colliderA.id !== null &&
            colliderB.id !== null &&
            colliderA.id === colliderB.id) ||
            (colliderA.owner !== null &&
                colliderB.owner !== null &&
                colliderA.owner === colliderB.owner)) {
            return false;
        }
        // if the collision pair has been calculated already short circuit
        const hash = Pair.calculatePairHash(colliderA.id, colliderB.id);
        if (this._collisions.has(hash)) {
            return false; // pair exists easy exit return false
        }
        // if the pair has a member with zero dimension
        if (colliderA.localBounds.hasZeroDimensions() || colliderB.localBounds.hasZeroDimensions()) {
            return false;
        }
        return Pair.canCollide(colliderA, colliderB);
    }
    /**
     * Detects potential collision pairs in a broadphase approach with the dynamic aabb tree strategy
     */
    broadphase(targets, delta, stats) {
        const seconds = delta / 1000;
        // Retrieve the list of potential colliders, exclude killed, prevented, and self
        const potentialColliders = targets.filter((other) => {
            var _a, _b;
            const body = (_a = other.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
            return ((_b = other.owner) === null || _b === void 0 ? void 0 : _b.active) && body.collisionType !== CollisionType.PreventCollision;
        });
        // clear old list of collision pairs
        this._collisionPairCache = [];
        this._collisions.clear();
        // check for normal collision pairs
        let collider;
        for (let j = 0, l = potentialColliders.length; j < l; j++) {
            collider = potentialColliders[j];
            // Query the collision tree for potential colliders
            this._dynamicCollisionTree.query(collider, (other) => {
                if (this._shouldGenerateCollisionPair(collider, other)) {
                    const pair = new Pair(collider, other);
                    this._collisions.add(pair.id);
                    this._collisionPairCache.push(pair);
                }
                // Always return false, to query whole tree. Returning true in the query method stops searching
                return false;
            });
        }
        if (stats) {
            stats.physics.pairs = this._collisionPairCache.length;
        }
        // Check dynamic tree for fast moving objects
        // Fast moving objects are those moving at least there smallest bound per frame
        if (Physics.checkForFastBodies) {
            for (const collider of potentialColliders) {
                const body = collider.owner.get(BodyComponent);
                // Skip non-active objects. Does not make sense on other collision types
                if (body.collisionType !== CollisionType.Active) {
                    continue;
                }
                // Maximum travel distance next frame
                const updateDistance = body.vel.size * seconds + // velocity term
                    body.acc.size * 0.5 * seconds * seconds; // acc term
                // Find the minimum dimension
                const minDimension = Math.min(collider.bounds.height, collider.bounds.width);
                if (Physics.disableMinimumSpeedForFastBody || updateDistance > minDimension / 2) {
                    if (stats) {
                        stats.physics.fastBodies++;
                    }
                    // start with the oldPos because the integration for actors has already happened
                    // objects resting on a surface may be slightly penetrating in the current position
                    const updateVec = body.pos.sub(body.oldPos);
                    const centerPoint = collider.center;
                    const furthestPoint = collider.getFurthestPoint(body.vel);
                    const origin = furthestPoint.sub(updateVec);
                    const ray = new Ray(origin, body.vel);
                    // back the ray up by -2x surfaceEpsilon to account for fast moving objects starting on the surface
                    ray.pos = ray.pos.add(ray.dir.scale(-2 * Physics.surfaceEpsilon));
                    let minCollider;
                    let minTranslate = new Vector(Infinity, Infinity);
                    this._dynamicCollisionTree.rayCastQuery(ray, updateDistance + Physics.surfaceEpsilon * 2, (other) => {
                        if (collider !== other && Pair.canCollide(collider, other)) {
                            const hitPoint = other.rayCast(ray, updateDistance + Physics.surfaceEpsilon * 10);
                            if (hitPoint) {
                                const translate = hitPoint.sub(origin);
                                if (translate.size < minTranslate.size) {
                                    minTranslate = translate;
                                    minCollider = other;
                                }
                            }
                        }
                        return false;
                    });
                    if (minCollider && Vector.isValid(minTranslate)) {
                        const pair = new Pair(collider, minCollider);
                        if (!this._collisions.has(pair.id)) {
                            this._collisions.add(pair.id);
                            this._collisionPairCache.push(pair);
                        }
                        // move the fast moving object to the other body
                        // need to push into the surface by ex.Physics.surfaceEpsilon
                        const shift = centerPoint.sub(furthestPoint);
                        body.pos = origin
                            .add(shift)
                            .add(minTranslate)
                            .add(ray.dir.scale(10 * Physics.surfaceEpsilon)); // needed to push the shape slightly into contact
                        collider.update(body.transform);
                        if (stats) {
                            stats.physics.fastBodyCollisions++;
                        }
                    }
                }
            }
        }
        // return cache
        return this._collisionPairCache;
    }
    /**
     * Applies narrow phase on collision pairs to find actual area intersections
     * Adds actual colliding pairs to stats' Frame data
     */
    narrowphase(pairs, stats) {
        let contacts = [];
        for (let i = 0; i < pairs.length; i++) {
            const newContacts = pairs[i].collide();
            contacts = contacts.concat(newContacts);
            if (stats && newContacts.length > 0) {
                for (const c of newContacts) {
                    stats.physics.contacts.set(c.id, c);
                }
            }
        }
        if (stats) {
            stats.physics.collisions += contacts.length;
        }
        return contacts;
    }
    /**
     * Update the dynamic tree positions
     */
    update(targets) {
        let updated = 0;
        const len = targets.length;
        for (let i = 0; i < len; i++) {
            if (this._dynamicCollisionTree.updateCollider(targets[i])) {
                updated++;
            }
        }
        return updated;
    }
    debug(ex) {
        this._dynamicCollisionTree.debug(ex);
    }
}

;// CONCATENATED MODULE: ./Collision/Colliders/Collider.ts


/**
 * A collision collider specifies the geometry that can detect when other collision colliders intersect
 * for the purposes of colliding 2 objects in excalibur.
 */
class Collider {
    constructor() {
        this.id = createId('collider', Collider._ID++);
        this.events = new EventDispatcher(this);
    }
    /**
     * Returns a boolean indicating whether this body collided with
     * or was in stationary contact with
     * the body of the other [[Collider]]
     */
    touching(other) {
        const contact = this.collide(other);
        if (contact) {
            return true;
        }
        return false;
    }
}
Collider._ID = 0;

;// CONCATENATED MODULE: ./Collision/Colliders/CompositeCollider.ts








class CompositeCollider extends Collider {
    constructor(colliders) {
        super();
        this._collisionProcessor = new DynamicTreeCollisionProcessor();
        this._dynamicAABBTree = new DynamicTree();
        this._colliders = [];
        for (const c of colliders) {
            this.addCollider(c);
        }
    }
    clearColliders() {
        this._colliders = [];
    }
    addCollider(collider) {
        this.events.wire(collider.events);
        this._colliders.push(collider);
        this._collisionProcessor.track(collider);
        this._dynamicAABBTree.trackCollider(collider);
    }
    removeCollider(collider) {
        this.events.unwire(collider.events);
        removeItemFromArray(collider, this._colliders);
        this._collisionProcessor.untrack(collider);
        this._dynamicAABBTree.untrackCollider(collider);
    }
    getColliders() {
        return this._colliders;
    }
    get worldPos() {
        var _a, _b;
        // TODO transform component world pos
        return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : Vector.Zero;
    }
    get center() {
        var _a, _b;
        return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : Vector.Zero;
    }
    get bounds() {
        var _a, _b;
        // TODO cache this
        const colliders = this.getColliders();
        const results = colliders.reduce((acc, collider) => acc.combine(collider.bounds), (_b = (_a = colliders[0]) === null || _a === void 0 ? void 0 : _a.bounds) !== null && _b !== void 0 ? _b : new BoundingBox().translate(this.worldPos));
        return results;
    }
    get localBounds() {
        var _a, _b;
        // TODO cache this
        const colliders = this.getColliders();
        const results = colliders.reduce((acc, collider) => acc.combine(collider.localBounds), (_b = (_a = colliders[0]) === null || _a === void 0 ? void 0 : _a.localBounds) !== null && _b !== void 0 ? _b : new BoundingBox());
        return results;
    }
    get axes() {
        // TODO cache this
        const colliders = this.getColliders();
        let axes = [];
        for (const collider of colliders) {
            axes = axes.concat(collider.axes);
        }
        return axes;
    }
    getFurthestPoint(direction) {
        const colliders = this.getColliders();
        const furthestPoints = [];
        for (const collider of colliders) {
            furthestPoints.push(collider.getFurthestPoint(direction));
        }
        // Pick best point from all colliders
        let bestPoint = furthestPoints[0];
        let maxDistance = -Number.MAX_VALUE;
        for (const point of furthestPoints) {
            const distance = point.dot(direction);
            if (distance > maxDistance) {
                bestPoint = point;
                maxDistance = distance;
            }
        }
        return bestPoint;
    }
    getInertia(mass) {
        const colliders = this.getColliders();
        let totalInertia = 0;
        for (const collider of colliders) {
            totalInertia += collider.getInertia(mass);
        }
        return totalInertia;
    }
    collide(other) {
        let otherColliders = [other];
        if (other instanceof CompositeCollider) {
            otherColliders = other.getColliders();
        }
        const pairs = [];
        for (const c of otherColliders) {
            this._dynamicAABBTree.query(c, (potentialCollider) => {
                pairs.push(new Pair(c, potentialCollider));
                return false;
            });
        }
        let contacts = [];
        for (const p of pairs) {
            contacts = contacts.concat(p.collide());
        }
        return contacts;
    }
    getClosestLineBetween(other) {
        const colliders = this.getColliders();
        const lines = [];
        if (other instanceof CompositeCollider) {
            const otherColliders = other.getColliders();
            for (const colliderA of colliders) {
                for (const colliderB of otherColliders) {
                    const maybeLine = colliderA.getClosestLineBetween(colliderB);
                    if (maybeLine) {
                        lines.push(maybeLine);
                    }
                }
            }
        }
        else {
            for (const collider of colliders) {
                const maybeLine = other.getClosestLineBetween(collider);
                if (maybeLine) {
                    lines.push(maybeLine);
                }
            }
        }
        if (lines.length) {
            let minLength = lines[0].getLength();
            let minLine = lines[0];
            for (const line of lines) {
                const length = line.getLength();
                if (length < minLength) {
                    minLength = length;
                    minLine = line;
                }
            }
            return minLine;
        }
        return null;
    }
    contains(point) {
        const colliders = this.getColliders();
        for (const collider of colliders) {
            if (collider.contains(point)) {
                return true;
            }
        }
        return false;
    }
    rayCast(ray, max) {
        const colliders = this.getColliders();
        const points = [];
        for (const collider of colliders) {
            const vec = collider.rayCast(ray, max);
            if (vec) {
                points.push(vec);
            }
        }
        if (points.length) {
            let minPoint = points[0];
            let minDistance = minPoint.dot(ray.dir);
            for (const point of points) {
                const distance = ray.dir.dot(point);
                if (distance < minDistance) {
                    minPoint = point;
                    minDistance = distance;
                }
            }
            return minPoint;
        }
        return null;
    }
    project(axis) {
        const colliders = this.getColliders();
        const projs = [];
        for (const collider of colliders) {
            const proj = collider.project(axis);
            if (proj) {
                projs.push(proj);
            }
        }
        // Merge all proj's on the same axis
        if (projs.length) {
            const newProjection = new Projection(projs[0].min, projs[0].max);
            for (const proj of projs) {
                newProjection.min = Math.min(proj.min, newProjection.min);
                newProjection.max = Math.max(proj.max, newProjection.max);
            }
            return newProjection;
        }
        return null;
    }
    update(transform) {
        if (transform) {
            const colliders = this.getColliders();
            for (const collider of colliders) {
                collider.owner = this.owner;
                collider.update(transform);
            }
        }
    }
    draw(ctx, color, pos) {
        const colliders = this.getColliders();
        for (const collider of colliders) {
            collider.draw(ctx, color, pos);
        }
    }
    debug(ex, color) {
        const colliders = this.getColliders();
        for (const collider of colliders) {
            collider.debug(ex, color);
        }
    }
    debugDraw(ctx, color) {
        const colliders = this.getColliders();
        for (const collider of colliders) {
            collider.draw(ctx, color);
        }
    }
    clone() {
        return new CompositeCollider(this._colliders.map((c) => c.clone()));
    }
}

;// CONCATENATED MODULE: ./Math/line.ts

/**
 * A 2D line segment
 */
class Line {
    /**
     * @param begin  The starting point of the line segment
     * @param end  The ending point of the line segment
     */
    constructor(begin, end) {
        this.begin = begin;
        this.end = end;
    }
    /**
     * Gets the raw slope (m) of the line. Will return (+/-)Infinity for vertical lines.
     */
    get slope() {
        return (this.end.y - this.begin.y) / (this.end.x - this.begin.x);
    }
    /**
     * Gets the Y-intercept (b) of the line. Will return (+/-)Infinity if there is no intercept.
     */
    get intercept() {
        return this.begin.y - this.slope * this.begin.x;
    }
    /**
     * Gets the normal of the line
     */
    normal() {
        return this.end.sub(this.begin).normal();
    }
    dir() {
        return this.end.sub(this.begin);
    }
    getPoints() {
        return [this.begin, this.end];
    }
    /**
     * Returns the slope of the line in the form of a vector of length 1
     */
    getSlope() {
        const begin = this.begin;
        const end = this.end;
        const distance = begin.distance(end);
        return end.sub(begin).scale(1 / distance);
    }
    /**
     * Returns the edge of the line as vector, the length of the vector is the length of the edge
     */
    getEdge() {
        const begin = this.begin;
        const end = this.end;
        return end.sub(begin);
    }
    /**
     * Returns the length of the line segment in pixels
     */
    getLength() {
        const begin = this.begin;
        const end = this.end;
        const distance = begin.distance(end);
        return distance;
    }
    /**
     * Returns the midpoint of the edge
     */
    get midpoint() {
        return this.begin.add(this.end).scale(0.5);
    }
    /**
     * Flips the direction of the line segment
     */
    flip() {
        return new Line(this.end, this.begin);
    }
    /**
     * Tests if a given point is below the line, points in the normal direction above the line are considered above.
     * @param point
     */
    below(point) {
        const above2 = (this.end.x - this.begin.x) * (point.y - this.begin.y) - (this.end.y - this.begin.y) * (point.x - this.begin.x);
        return above2 >= 0;
    }
    /**
     * Returns the clip point
     * @param sideVector Vector that traces the line
     * @param length Length to clip along side
     */
    clip(sideVector, length) {
        let dir = sideVector;
        dir = dir.normalize();
        const near = dir.dot(this.begin) - length;
        const far = dir.dot(this.end) - length;
        const results = [];
        if (near <= 0) {
            results.push(this.begin);
        }
        if (far <= 0) {
            results.push(this.end);
        }
        if (near * far < 0) {
            const clipTime = near / (near - far);
            results.push(this.begin.add(this.end.sub(this.begin).scale(clipTime)));
        }
        if (results.length !== 2) {
            return null;
        }
        return new Line(results[0], results[1]);
    }
    /**
     * Find the perpendicular distance from the line to a point
     * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
     * @param point
     */
    distanceToPoint(point, signed = false) {
        const x0 = point.x;
        const y0 = point.y;
        const l = this.getLength();
        const dy = this.end.y - this.begin.y;
        const dx = this.end.x - this.begin.x;
        const distance = (dy * x0 - dx * y0 + this.end.x * this.begin.y - this.end.y * this.begin.x) / l;
        return signed ? distance : Math.abs(distance);
    }
    /**
     * Find the perpendicular line from the line to a point
     * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
     * (a - p) - ((a - p) * n)n
     * a is a point on the line
     * p is the arbitrary point above the line
     * n is a unit vector in direction of the line
     * @param point
     */
    findVectorToPoint(point) {
        const aMinusP = this.begin.sub(point);
        const n = this.getSlope();
        return aMinusP.sub(n.scale(aMinusP.dot(n)));
    }
    /**
     * Finds a point on the line given only an X or a Y value. Given an X value, the function returns
     * a new point with the calculated Y value and vice-versa.
     *
     * @param x The known X value of the target point
     * @param y The known Y value of the target point
     * @returns A new point with the other calculated axis value
     */
    findPoint(x = null, y = null) {
        const m = this.slope;
        const b = this.intercept;
        if (x !== null) {
            return new Vector(x, m * x + b);
        }
        else if (y !== null) {
            return new Vector((y - b) / m, y);
        }
        else {
            throw new Error('You must provide an X or a Y value');
        }
    }
    /**
     * @see http://stackoverflow.com/a/11908158/109458
     */
    hasPoint() {
        let currPoint;
        let threshold = 0;
        if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
            currPoint = new Vector(arguments[0], arguments[1]);
            threshold = arguments[2] || 0;
        }
        else if (arguments[0] instanceof Vector) {
            currPoint = arguments[0];
            threshold = arguments[1] || 0;
        }
        else {
            throw 'Could not determine the arguments for Vector.hasPoint';
        }
        const dxc = currPoint.x - this.begin.x;
        const dyc = currPoint.y - this.begin.y;
        const dx1 = this.end.x - this.begin.x;
        const dy1 = this.end.y - this.begin.y;
        const cross = dxc * dy1 - dyc * dx1;
        // check whether point lines on the line
        if (Math.abs(cross) > threshold) {
            return false;
        }
        // check whether point lies in-between start and end
        if (Math.abs(dx1) >= Math.abs(dy1)) {
            return dx1 > 0 ? this.begin.x <= currPoint.x && currPoint.x <= this.end.x : this.end.x <= currPoint.x && currPoint.x <= this.begin.x;
        }
        else {
            return dy1 > 0 ? this.begin.y <= currPoint.y && currPoint.y <= this.end.y : this.end.y <= currPoint.y && currPoint.y <= this.begin.y;
        }
    }
}

;// CONCATENATED MODULE: ./Collision/Colliders/ClosestLineJumpTable.ts



/**
 * Finds the closes line between 2 line segments, were the magnitude of u, v are the lengths of each segment
 * L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
 * L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line
 * @param p0 Point where L1 begins
 * @param u Direction and length of L1
 * @param q0 Point were L2 begins
 * @param v Direction and length of L2
 */
function ClosestLine(p0, u, q0, v) {
    // Distance between 2 lines http://geomalgorithms.com/a07-_distance.html
    // w(s, t) = P(s) - Q(t)
    // The w(s, t) that has the minimum distance we will say is w(sClosest, tClosest) = wClosest
    //
    // wClosest is the vector that is uniquely perpendicular to the 2 line directions u & v.
    // wClosest = w0 + sClosest * u - tClosest * v, where w0 is p0 - q0
    //
    // The closest point between 2 lines then satisfies this pair of equations
    // 1: u * wClosest = 0
    // 2: v * wClosest = 0
    //
    // Substituting wClosest into the equations we get
    //
    // 1: (u * u) * sClosest - (u * v) tClosest = -u * w0
    // 2: (v * u) * sClosest - (v * v) tClosest = -v * w0
    // simplify w0
    const w0 = p0.sub(q0);
    // simplify (u * u);
    const a = u.dot(u);
    // simplify (u * v);
    const b = u.dot(v);
    // simplify (v * v)
    const c = v.dot(v);
    // simplify (u * w0)
    const d = u.dot(w0);
    // simplify (v * w0)
    const e = v.dot(w0);
    // denominator ac - b^2
    const denom = a * c - b * b;
    let sDenom = denom;
    let tDenom = denom;
    // if denom is 0 they are parallel, use any point from either as the start in this case p0
    if (denom === 0 || denom <= 0.01) {
        const tClosestParallel = d / b;
        return new Line(p0, q0.add(v.scale(tClosestParallel)));
    }
    // Solve for sClosest for infinite line
    let sClosest = b * e - c * d; // / denom;
    // Solve for tClosest for infinite line
    let tClosest = a * e - b * d; // / denom;
    // Solve for segments candidate edges, if sClosest and tClosest are outside their segments
    if (sClosest < 0) {
        sClosest = 0;
        tClosest = e;
        tDenom = c;
    }
    else if (sClosest > sDenom) {
        sClosest = sDenom;
        tClosest = e + b;
        tDenom = c;
    }
    if (tClosest < 0) {
        tClosest = 0;
        if (-d < 0) {
            sClosest = 0;
        }
        else if (-d > a) {
            sClosest = sDenom;
        }
        else {
            sClosest = -d;
            sDenom = a;
        }
    }
    else if (tClosest > tDenom) {
        tClosest = tDenom;
        if (-d + b < 0) {
            sClosest = 0;
        }
        else if (-d + b > a) {
            sClosest = sDenom;
        }
        else {
            sClosest = -d + b;
            sDenom = a;
        }
    }
    sClosest = Math.abs(sClosest) < 0.001 ? 0 : sClosest / sDenom;
    tClosest = Math.abs(tClosest) < 0.001 ? 0 : tClosest / tDenom;
    return new Line(p0.add(u.scale(sClosest)), q0.add(v.scale(tClosest)));
}
const ClosestLineJumpTable = {
    PolygonPolygonClosestLine(polygonA, polygonB) {
        // Find the 2 closest faces on each polygon
        const otherWorldPos = polygonB.worldPos;
        const otherDirection = otherWorldPos.sub(polygonA.worldPos);
        const thisDirection = otherDirection.negate();
        const rayTowardsOther = new Ray(polygonA.worldPos, otherDirection);
        const rayTowardsThis = new Ray(otherWorldPos, thisDirection);
        const thisPoint = polygonA.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));
        const otherPoint = polygonB.rayCast(rayTowardsThis).add(rayTowardsThis.dir.scale(0.1));
        const thisFace = polygonA.getClosestFace(thisPoint);
        const otherFace = polygonB.getClosestFace(otherPoint);
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const p0 = thisFace.face.begin;
        const u = thisFace.face.getEdge();
        // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line
        const q0 = otherFace.face.begin;
        const v = otherFace.face.getEdge();
        return ClosestLine(p0, u, q0, v);
    },
    PolygonEdgeClosestLine(polygon, edge) {
        // Find the 2 closest faces on each polygon
        const otherWorldPos = edge.worldPos;
        const otherDirection = otherWorldPos.sub(polygon.worldPos);
        const rayTowardsOther = new Ray(polygon.worldPos, otherDirection);
        const thisPoint = polygon.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));
        const thisFace = polygon.getClosestFace(thisPoint);
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const p0 = thisFace.face.begin;
        const u = thisFace.face.getEdge();
        // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line
        const edgeLine = edge.asLine();
        const edgeStart = edgeLine.begin;
        const edgeVector = edgeLine.getEdge();
        const q0 = edgeStart;
        const v = edgeVector;
        return ClosestLine(p0, u, q0, v);
    },
    PolygonCircleClosestLine(polygon, circle) {
        // https://math.stackexchange.com/questions/1919177/how-to-find-point-on-line-closest-to-sphere
        // Find the 2 closest faces on each polygon
        const otherWorldPos = circle.worldPos;
        const otherDirection = otherWorldPos.sub(polygon.worldPos);
        const rayTowardsOther = new Ray(polygon.worldPos, otherDirection.normalize());
        const thisPoint = polygon.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));
        const thisFace = polygon.getClosestFace(thisPoint);
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const p0 = thisFace.face.begin;
        const u = thisFace.face.getEdge();
        // Time of minimum distance
        let t = (u.x * (otherWorldPos.x - p0.x) + u.y * (otherWorldPos.y - p0.y)) / (u.x * u.x + u.y * u.y);
        // If time of minimum is past the edge clamp
        if (t > 1) {
            t = 1;
        }
        else if (t < 0) {
            t = 0;
        }
        // Minimum distance
        const d = Math.sqrt(Math.pow(p0.x + u.x * t - otherWorldPos.x, 2) + Math.pow(p0.y + u.y * t - otherWorldPos.y, 2)) - circle.radius;
        const circlex = ((p0.x + u.x * t - otherWorldPos.x) * circle.radius) / (circle.radius + d);
        const circley = ((p0.y + u.y * t - otherWorldPos.y) * circle.radius) / (circle.radius + d);
        return new Line(u.scale(t).add(p0), new Vector(otherWorldPos.x + circlex, otherWorldPos.y + circley));
    },
    CircleCircleClosestLine(circleA, circleB) {
        // Find the 2 closest faces on each polygon
        const otherWorldPos = circleB.worldPos;
        const otherDirection = otherWorldPos.sub(circleA.worldPos);
        const thisWorldPos = circleA.worldPos;
        const thisDirection = thisWorldPos.sub(circleB.worldPos);
        const rayTowardsOther = new Ray(circleA.worldPos, otherDirection);
        const rayTowardsThis = new Ray(circleB.worldPos, thisDirection);
        const thisPoint = circleA.rayCast(rayTowardsOther);
        const otherPoint = circleB.rayCast(rayTowardsThis);
        return new Line(thisPoint, otherPoint);
    },
    CircleEdgeClosestLine(circle, edge) {
        // https://math.stackexchange.com/questions/1919177/how-to-find-point-on-line-closest-to-sphere
        const circleWorlPos = circle.worldPos;
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const edgeLine = edge.asLine();
        const edgeStart = edgeLine.begin;
        const edgeVector = edgeLine.getEdge();
        const p0 = edgeStart;
        const u = edgeVector;
        // Time of minimum distance
        let t = (u.x * (circleWorlPos.x - p0.x) + u.y * (circleWorlPos.y - p0.y)) / (u.x * u.x + u.y * u.y);
        // If time of minimum is past the edge clamp to edge
        if (t > 1) {
            t = 1;
        }
        else if (t < 0) {
            t = 0;
        }
        // Minimum distance
        const d = Math.sqrt(Math.pow(p0.x + u.x * t - circleWorlPos.x, 2) + Math.pow(p0.y + u.y * t - circleWorlPos.y, 2)) - circle.radius;
        const circlex = ((p0.x + u.x * t - circleWorlPos.x) * circle.radius) / (circle.radius + d);
        const circley = ((p0.y + u.y * t - circleWorlPos.y) * circle.radius) / (circle.radius + d);
        return new Line(u.scale(t).add(p0), new Vector(circleWorlPos.x + circlex, circleWorlPos.y + circley));
    },
    EdgeEdgeClosestLine(edgeA, edgeB) {
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const edgeLineA = edgeA.asLine();
        const edgeStartA = edgeLineA.begin;
        const edgeVectorA = edgeLineA.getEdge();
        const p0 = edgeStartA;
        const u = edgeVectorA;
        // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line
        const edgeLineB = edgeB.asLine();
        const edgeStartB = edgeLineB.begin;
        const edgeVectorB = edgeLineB.getEdge();
        const q0 = edgeStartB;
        const v = edgeVectorB;
        return ClosestLine(p0, u, q0, v);
    }
};

;// CONCATENATED MODULE: ./Collision/Colliders/CircleCollider.ts









/**
 * This is a circle collider for the excalibur rigid body physics simulation
 */
class CircleCollider extends Collider {
    constructor(options) {
        super();
        /**
         * Position of the circle relative to the collider, by default (0, 0).
         */
        this.offset = Vector.Zero;
        this.offset = options.offset || Vector.Zero;
        this.radius = options.radius || 0;
    }
    get worldPos() {
        var _a, _b;
        return this.offset.add((_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : Vector.Zero);
    }
    /**
     * Returns a clone of this shape, not associated with any collider
     */
    clone() {
        return new CircleCollider({
            offset: this.offset.clone(),
            radius: this.radius
        });
    }
    /**
     * Get the center of the collider in world coordinates
     */
    get center() {
        var _a, _b;
        return this.offset.add((_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : Vector.Zero);
    }
    /**
     * Tests if a point is contained in this collider
     */
    contains(point) {
        var _a, _b;
        const pos = (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : this.offset;
        const distance = pos.distance(point);
        if (distance <= this.radius) {
            return true;
        }
        return false;
    }
    /**
     * Casts a ray at the Circle collider and returns the nearest point of collision
     * @param ray
     */
    rayCast(ray, max = Infinity) {
        //https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection
        const c = this.center;
        const dir = ray.dir;
        const orig = ray.pos;
        const discriminant = Math.sqrt(Math.pow(dir.dot(orig.sub(c)), 2) - Math.pow(orig.sub(c).distance(), 2) + Math.pow(this.radius, 2));
        if (discriminant < 0) {
            // no intersection
            return null;
        }
        else {
            let toi = 0;
            if (discriminant === 0) {
                toi = -dir.dot(orig.sub(c));
                if (toi > 0 && toi < max) {
                    return ray.getPoint(toi);
                }
                return null;
            }
            else {
                const toi1 = -dir.dot(orig.sub(c)) + discriminant;
                const toi2 = -dir.dot(orig.sub(c)) - discriminant;
                const positiveToi = [];
                if (toi1 >= 0) {
                    positiveToi.push(toi1);
                }
                if (toi2 >= 0) {
                    positiveToi.push(toi2);
                }
                const mintoi = Math.min(...positiveToi);
                if (mintoi <= max) {
                    return ray.getPoint(mintoi);
                }
                return null;
            }
        }
    }
    getClosestLineBetween(shape) {
        if (shape instanceof CircleCollider) {
            return ClosestLineJumpTable.CircleCircleClosestLine(this, shape);
        }
        else if (shape instanceof PolygonCollider) {
            return ClosestLineJumpTable.PolygonCircleClosestLine(shape, this).flip();
        }
        else if (shape instanceof EdgeCollider) {
            return ClosestLineJumpTable.CircleEdgeClosestLine(this, shape).flip();
        }
        else {
            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);
        }
    }
    /**
     * @inheritdoc
     */
    collide(collider) {
        if (collider instanceof CircleCollider) {
            return CollisionJumpTable.CollideCircleCircle(this, collider);
        }
        else if (collider instanceof PolygonCollider) {
            return CollisionJumpTable.CollideCirclePolygon(this, collider);
        }
        else if (collider instanceof EdgeCollider) {
            return CollisionJumpTable.CollideCircleEdge(this, collider);
        }
        else {
            throw new Error(`Circle could not collide with unknown CollisionShape ${typeof collider}`);
        }
    }
    /**
     * Find the point on the collider furthest in the direction specified
     */
    getFurthestPoint(direction) {
        return this.center.add(direction.normalize().scale(this.radius));
    }
    /**
     * Find the local point on the shape in the direction specified
     * @param direction
     */
    getFurthestLocalPoint(direction) {
        const dir = direction.normalize();
        return dir.scale(this.radius);
    }
    /**
     * Get the axis aligned bounding box for the circle collider in world coordinates
     */
    get bounds() {
        var _a;
        const tx = this._transform;
        const bodyPos = (_a = tx === null || tx === void 0 ? void 0 : tx.globalPos) !== null && _a !== void 0 ? _a : Vector.Zero;
        return new BoundingBox(this.offset.x + bodyPos.x - this.radius, this.offset.y + bodyPos.y - this.radius, this.offset.x + bodyPos.x + this.radius, this.offset.y + bodyPos.y + this.radius);
    }
    /**
     * Get the axis aligned bounding box for the circle collider in local coordinates
     */
    get localBounds() {
        return new BoundingBox(this.offset.x - this.radius, this.offset.y - this.radius, this.offset.x + this.radius, this.offset.y + this.radius);
    }
    /**
     * Get axis not implemented on circles, since there are infinite axis in a circle
     */
    get axes() {
        return [];
    }
    /**
     * Returns the moment of inertia of a circle given it's mass
     * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
     */
    getInertia(mass) {
        return (mass * this.radius * this.radius) / 2;
    }
    /* istanbul ignore next */
    update(transform) {
        this._transform = transform;
    }
    /**
     * Project the circle along a specified axis
     */
    project(axis) {
        const scalars = [];
        const point = this.center;
        const dotProduct = point.dot(axis);
        scalars.push(dotProduct);
        scalars.push(dotProduct + this.radius);
        scalars.push(dotProduct - this.radius);
        return new Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
    }
    draw(ctx, color = Color.Green, pos = Vector.Zero) {
        const newPos = pos.add(this.offset);
        ctx.beginPath();
        ctx.fillStyle = color.toString();
        ctx.arc(newPos.x, newPos.y, this.radius, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();
    }
    debug(ex, color) {
        const tx = this._transform;
        const pos = (tx === null || tx === void 0 ? void 0 : tx.globalPos) ? tx === null || tx === void 0 ? void 0 : tx.globalPos.add(this.offset) : this.offset;
        ex.drawCircle(pos, this.radius, color);
    }
    /* istanbul ignore next */
    debugDraw(ctx, color = Color.Green) {
        const transform = this._transform;
        const pos = transform ? transform.pos.add(this.offset) : this.offset;
        const rotation = transform ? transform.rotation : 0;
        ctx.beginPath();
        ctx.strokeStyle = color.toString();
        ctx.arc(pos.x, pos.y, this.radius, 0, Math.PI * 2);
        ctx.closePath();
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y);
        ctx.lineTo(Math.cos(rotation) * this.radius + pos.x, Math.sin(rotation) * this.radius + pos.y);
        ctx.closePath();
        ctx.stroke();
    }
}

;// CONCATENATED MODULE: ./Collision/Detection/CollisionContact.ts




/**
 * Collision contacts are used internally by Excalibur to resolve collision between colliders. This
 * Pair prevents collisions from being evaluated more than one time
 */
class CollisionContact {
    constructor(colliderA, colliderB, mtv, normal, tangent, points, localPoints, info) {
        this._canceled = false;
        this.colliderA = colliderA;
        this.colliderB = colliderB;
        this.mtv = mtv;
        this.normal = normal;
        this.tangent = tangent;
        this.points = points;
        this.localPoints = localPoints;
        this.info = info;
        this.id = Pair.calculatePairHash(colliderA.id, colliderB.id);
    }
    /**
     * Match contact awake state, except if body's are Fixed
     */
    matchAwake() {
        const bodyA = this.colliderA.owner.get(BodyComponent);
        const bodyB = this.colliderB.owner.get(BodyComponent);
        if (bodyA && bodyB) {
            if (bodyA.sleeping !== bodyB.sleeping) {
                if (bodyA.sleeping && bodyA.collisionType !== CollisionType.Fixed && bodyB.sleepMotion >= Physics.wakeThreshold) {
                    bodyA.setSleeping(false);
                }
                if (bodyB.sleeping && bodyB.collisionType !== CollisionType.Fixed && bodyA.sleepMotion >= Physics.wakeThreshold) {
                    bodyB.setSleeping(false);
                }
            }
        }
    }
    isCanceled() {
        return this._canceled;
    }
    cancel() {
        this._canceled = true;
    }
}

;// CONCATENATED MODULE: ./Collision/Colliders/SeparatingAxis.ts
class SeparatingAxis {
    static findPolygonPolygonSeparation(polyA, polyB) {
        let bestSeparation = -Number.MAX_VALUE;
        let bestSide = null;
        let bestAxis = null;
        let bestSideIndex = -1;
        let bestOtherPoint = null;
        const sides = polyA.getSides();
        const localSides = polyA.getLocalSides();
        for (let i = 0; i < sides.length; i++) {
            const side = sides[i];
            const axis = side.normal();
            const vertB = polyB.getFurthestPoint(axis.negate());
            // Separation on side i's axis
            // We are looking for the largest separation between poly A's sides
            const vertSeparation = side.distanceToPoint(vertB, true);
            if (vertSeparation > bestSeparation) {
                bestSeparation = vertSeparation;
                bestSide = side;
                bestAxis = axis;
                bestSideIndex = i;
                bestOtherPoint = vertB;
            }
        }
        return {
            collider: polyA,
            separation: bestAxis ? bestSeparation : 99,
            axis: bestAxis,
            side: bestSide,
            localSide: localSides[bestSideIndex],
            sideId: bestSideIndex,
            point: bestOtherPoint,
            localPoint: bestAxis ? polyB.getFurthestLocalPoint(bestAxis.negate()) : null
        };
    }
    static findCirclePolygonSeparation(circle, polygon) {
        const axes = polygon.axes;
        const pc = polygon.center;
        // Special SAT with circles
        const polyDir = pc.sub(circle.worldPos);
        const closestPointOnPoly = polygon.getFurthestPoint(polyDir.negate());
        axes.push(closestPointOnPoly.sub(circle.worldPos).normalize());
        let minOverlap = Number.MAX_VALUE;
        let minAxis = null;
        let minIndex = -1;
        for (let i = 0; i < axes.length; i++) {
            const proj1 = polygon.project(axes[i]);
            const proj2 = circle.project(axes[i]);
            const overlap = proj1.getOverlap(proj2);
            if (overlap <= 0) {
                return null;
            }
            else {
                if (overlap < minOverlap) {
                    minOverlap = overlap;
                    minAxis = axes[i];
                    minIndex = i;
                }
            }
        }
        if (minIndex < 0) {
            return null;
        }
        return minAxis.normalize().scale(minOverlap);
    }
}

;// CONCATENATED MODULE: ./Collision/Colliders/CollisionJumpTable.ts








const CollisionJumpTable = {
    CollideCircleCircle(circleA, circleB) {
        const circleAPos = circleA.worldPos;
        const circleBPos = circleB.worldPos;
        const combinedRadius = circleA.radius + circleB.radius;
        const distance = circleAPos.distance(circleBPos);
        if (distance > combinedRadius) {
            return [];
        }
        // negative means overlap
        const separation = combinedRadius - distance;
        // Normal points from A -> B
        const normal = circleBPos.sub(circleAPos).normalize();
        const tangent = normal.perpendicular();
        const mvt = normal.scale(separation);
        const point = circleA.getFurthestPoint(normal);
        const local = circleA.getFurthestLocalPoint(normal);
        const info = {
            collider: circleA,
            separation,
            axis: normal,
            point: point
        };
        return [new CollisionContact(circleA, circleB, mvt, normal, tangent, [point], [local], info)];
    },
    CollideCirclePolygon(circle, polygon) {
        var _a, _b;
        let minAxis = SeparatingAxis.findCirclePolygonSeparation(circle, polygon);
        if (!minAxis) {
            return [];
        }
        // make sure that the minAxis is pointing away from circle
        const samedir = minAxis.dot(polygon.center.sub(circle.center));
        minAxis = samedir < 0 ? minAxis.negate() : minAxis;
        const point = circle.getFurthestPoint(minAxis);
        const xf = (_b = (_a = circle.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent)) !== null && _b !== void 0 ? _b : new TransformComponent();
        const local = xf.applyInverse(point);
        const normal = minAxis.normalize();
        const info = {
            collider: circle,
            separation: -minAxis.size,
            axis: normal,
            point: point,
            localPoint: local,
            side: polygon.findSide(normal.negate()),
            localSide: polygon.findLocalSide(normal.negate())
        };
        return [new CollisionContact(circle, polygon, minAxis, normal, normal.perpendicular(), [point], [local], info)];
    },
    CollideCircleEdge(circle, edge) {
        // TODO not sure this actually abides by local/world collisions
        // Are edge.begin and edge.end local space or world space? I think they should be local
        // center of the circle in world pos
        const cc = circle.center;
        // vector in the direction of the edge
        const edgeWorld = edge.asLine();
        const e = edgeWorld.end.sub(edgeWorld.begin);
        // amount of overlap with the circle's center along the edge direction
        const u = e.dot(edgeWorld.end.sub(cc));
        const v = e.dot(cc.sub(edgeWorld.begin));
        const side = edge.asLine();
        const localSide = edge.asLocalLine();
        // Potential region A collision (circle is on the left side of the edge, before the beginning)
        if (v <= 0) {
            const da = edgeWorld.begin.sub(cc);
            const dda = da.dot(da); // quick and dirty way of calc'n distance in r^2 terms saves some sqrts
            // save some sqrts
            if (dda > circle.radius * circle.radius) {
                return []; // no collision
            }
            const normal = da.normalize();
            const separation = circle.radius - Math.sqrt(dda);
            const info = {
                collider: circle,
                separation: separation,
                axis: normal,
                point: side.begin,
                side: side,
                localSide: localSide
            };
            return [
                new CollisionContact(circle, edge, normal.scale(separation), normal, normal.perpendicular(), [side.begin], [localSide.begin], info)
            ];
        }
        // Potential region B collision (circle is on the right side of the edge, after the end)
        if (u <= 0) {
            const db = edgeWorld.end.sub(cc);
            const ddb = db.dot(db);
            if (ddb > circle.radius * circle.radius) {
                return [];
            }
            const normal = db.normalize();
            const separation = circle.radius - Math.sqrt(ddb);
            const info = {
                collider: circle,
                separation: separation,
                axis: normal,
                point: side.end,
                side: side,
                localSide: localSide
            };
            return [
                new CollisionContact(circle, edge, normal.scale(separation), normal, normal.perpendicular(), [side.end], [localSide.end], info)
            ];
        }
        // Otherwise potential region AB collision (circle is in the middle of the edge between the beginning and end)
        const den = e.dot(e);
        const pointOnEdge = edgeWorld.begin
            .scale(u)
            .add(edgeWorld.end.scale(v))
            .scale(1 / den);
        const d = cc.sub(pointOnEdge);
        const dd = d.dot(d);
        if (dd > circle.radius * circle.radius) {
            return []; // no collision
        }
        let normal = e.perpendicular();
        // flip correct direction
        if (normal.dot(cc.sub(edgeWorld.begin)) < 0) {
            normal.x = -normal.x;
            normal.y = -normal.y;
        }
        normal = normal.normalize();
        const separation = circle.radius - Math.sqrt(dd);
        const mvt = normal.scale(separation);
        const info = {
            collider: circle,
            separation: separation,
            axis: normal,
            point: pointOnEdge,
            side: side,
            localSide: localSide
        };
        return [
            new CollisionContact(circle, edge, mvt, normal.negate(), normal.negate().perpendicular(), [pointOnEdge], [pointOnEdge.sub(edge.worldPos)], info)
        ];
    },
    CollideEdgeEdge() {
        // Edge-edge collision doesn't make sense
        return [];
    },
    CollidePolygonEdge(polygon, edge) {
        var _a;
        const pc = polygon.center;
        const ec = edge.center;
        const dir = ec.sub(pc).normalize();
        // build a temporary polygon from the edge to use SAT
        const linePoly = new PolygonCollider({
            points: [edge.begin, edge.end, edge.end.add(dir.scale(100)), edge.begin.add(dir.scale(100))],
            offset: edge.offset
        });
        linePoly.owner = edge.owner;
        const tx = (_a = edge.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent);
        if (tx) {
            linePoly.update(edge.owner.get(TransformComponent));
        }
        // Gross hack but poly-poly works well
        const contact = this.CollidePolygonPolygon(polygon, linePoly);
        if (contact.length) {
            // Fudge the contact back to edge
            contact[0].colliderB = edge;
            contact[0].id = Pair.calculatePairHash(polygon.id, edge.id);
            // contact[0].info.collider
        }
        return contact;
    },
    CollidePolygonPolygon(polyA, polyB) {
        var _a, _b, _c, _d;
        // Multi contact from SAT
        // https://gamedev.stackexchange.com/questions/111390/multiple-contacts-for-sat-collision-detection
        // do a SAT test to find a min axis if it exists
        const separationA = SeparatingAxis.findPolygonPolygonSeparation(polyA, polyB);
        // If there is no overlap from boxA's perspective we can end early
        if (separationA.separation > 0) {
            return [];
        }
        const separationB = SeparatingAxis.findPolygonPolygonSeparation(polyB, polyA);
        // If there is no overlap from boxB's perspective exit now
        if (separationB.separation > 0) {
            return [];
        }
        // Separations are both negative, we want to pick the least negative (minimal movement)
        const separation = separationA.separation > separationB.separation ? separationA : separationB;
        // The incident side is the most opposite from the axes of collision on the other collider
        const other = separation.collider === polyA ? polyB : polyA;
        const incident = other.findSide(separation.axis.negate());
        // Clip incident side by the perpendicular lines at each end of the reference side
        // https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm
        const reference = separation.side;
        const refDir = reference.dir().normalize();
        // Find our contact points by clipping the incident by the collision side
        const clipRight = incident.clip(refDir.negate(), -refDir.dot(reference.begin));
        let clipLeft = null;
        if (clipRight) {
            clipLeft = clipRight.clip(refDir, refDir.dot(reference.end));
        }
        // If there is no left there is no collision
        if (clipLeft) {
            // We only want clip points below the reference edge, discard the others
            const points = clipLeft.getPoints().filter((p) => {
                return reference.below(p);
            });
            let normal = separation.axis;
            let tangent = normal.perpendicular();
            // Point Contact A -> B
            if (polyB.worldPos.sub(polyA.worldPos).dot(normal) < 0) {
                normal = normal.negate();
                tangent = normal.perpendicular();
            }
            // Points are clipped from incident which is the other collider
            // Store those as locals
            let localPoints = [];
            if (separation.collider === polyA) {
                const xf = (_b = (_a = polyB.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent)) !== null && _b !== void 0 ? _b : new TransformComponent();
                localPoints = points.map((p) => xf.applyInverse(p));
            }
            else {
                const xf = (_d = (_c = polyA.owner) === null || _c === void 0 ? void 0 : _c.get(TransformComponent)) !== null && _d !== void 0 ? _d : new TransformComponent();
                localPoints = points.map((p) => xf.applyInverse(p));
            }
            return [new CollisionContact(polyA, polyB, normal.scale(-separation.separation), normal, tangent, points, localPoints, separation)];
        }
        return [];
    },
    FindContactSeparation(contact, localPoint) {
        var _a, _b, _c, _d;
        const shapeA = contact.colliderA;
        const txA = (_b = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent)) !== null && _b !== void 0 ? _b : new TransformComponent();
        const shapeB = contact.colliderB;
        const txB = (_d = (_c = contact.colliderB.owner) === null || _c === void 0 ? void 0 : _c.get(TransformComponent)) !== null && _d !== void 0 ? _d : new TransformComponent();
        // both are circles
        if (shapeA instanceof CircleCollider && shapeB instanceof CircleCollider) {
            const combinedRadius = shapeA.radius + shapeB.radius;
            const distance = txA.pos.distance(txB.pos);
            const separation = combinedRadius - distance;
            return -separation;
        }
        // both are polygons
        if (shapeA instanceof PolygonCollider && shapeB instanceof PolygonCollider) {
            if (contact.info.localSide) {
                let side;
                let worldPoint;
                if (contact.info.collider === shapeA) {
                    side = new Line(txA.apply(contact.info.localSide.begin), txA.apply(contact.info.localSide.end));
                    worldPoint = txB.apply(localPoint);
                }
                else {
                    side = new Line(txB.apply(contact.info.localSide.begin), txB.apply(contact.info.localSide.end));
                    worldPoint = txA.apply(localPoint);
                }
                return side.distanceToPoint(worldPoint, true);
            }
        }
        // polygon v circle
        if ((shapeA instanceof PolygonCollider && shapeB instanceof CircleCollider) ||
            (shapeB instanceof PolygonCollider && shapeA instanceof CircleCollider)) {
            const worldPoint = txA.apply(localPoint);
            if (contact.info.side) {
                return contact.info.side.distanceToPoint(worldPoint, true);
            }
        }
        // polygon v edge
        if ((shapeA instanceof EdgeCollider && shapeB instanceof PolygonCollider) ||
            (shapeB instanceof EdgeCollider && shapeA instanceof PolygonCollider)) {
            let worldPoint;
            if (contact.info.collider === shapeA) {
                worldPoint = txB.apply(localPoint);
            }
            else {
                worldPoint = txA.apply(localPoint);
            }
            if (contact.info.side) {
                return contact.info.side.distanceToPoint(worldPoint, true);
            }
        }
        // circle v edge
        if ((shapeA instanceof CircleCollider && shapeB instanceof EdgeCollider) ||
            (shapeB instanceof CircleCollider && shapeA instanceof EdgeCollider)) {
            // Local point is always on the edge which is always shapeB
            const worldPoint = txB.apply(localPoint);
            let circlePoint;
            if (shapeA instanceof CircleCollider) {
                circlePoint = shapeA.getFurthestPoint(contact.normal);
            }
            const dist = worldPoint.distance(circlePoint);
            if (contact.info.side) {
                return dist > 0 ? -dist : 0;
            }
        }
        return 0;
    }
};

;// CONCATENATED MODULE: ./Collision/Colliders/EdgeCollider.ts










/**
 * Edge is a single line collider to create collisions with a single line.
 */
class EdgeCollider extends Collider {
    constructor(options) {
        var _a;
        super();
        this.begin = options.begin || Vector.Zero;
        this.end = options.end || Vector.Zero;
        this.offset = (_a = options.offset) !== null && _a !== void 0 ? _a : Vector.Zero;
    }
    /**
     * Returns a clone of this Edge, not associated with any collider
     */
    clone() {
        return new EdgeCollider({
            begin: this.begin.clone(),
            end: this.end.clone()
        });
    }
    get worldPos() {
        var _a;
        const tx = this._transform;
        return (_a = tx === null || tx === void 0 ? void 0 : tx.globalPos.add(this.offset)) !== null && _a !== void 0 ? _a : this.offset;
    }
    /**
     * Get the center of the collision area in world coordinates
     */
    get center() {
        const pos = this.begin.average(this.end).add(this._getBodyPos());
        return pos;
    }
    _getBodyPos() {
        var _a;
        const tx = this._transform;
        const bodyPos = (_a = tx === null || tx === void 0 ? void 0 : tx.globalPos) !== null && _a !== void 0 ? _a : Vector.Zero;
        return bodyPos;
    }
    _getTransformedBegin() {
        const tx = this._transform;
        const angle = tx ? tx.globalRotation : 0;
        return this.begin.rotate(angle).add(this._getBodyPos());
    }
    _getTransformedEnd() {
        const tx = this._transform;
        const angle = tx ? tx.globalRotation : 0;
        return this.end.rotate(angle).add(this._getBodyPos());
    }
    /**
     * Returns the slope of the line in the form of a vector
     */
    getSlope() {
        const begin = this._getTransformedBegin();
        const end = this._getTransformedEnd();
        const distance = begin.distance(end);
        return end.sub(begin).scale(1 / distance);
    }
    /**
     * Returns the length of the line segment in pixels
     */
    getLength() {
        const begin = this._getTransformedBegin();
        const end = this._getTransformedEnd();
        const distance = begin.distance(end);
        return distance;
    }
    /**
     * Tests if a point is contained in this collision area
     */
    contains() {
        return false;
    }
    /**
     * @inheritdoc
     */
    rayCast(ray, max = Infinity) {
        const numerator = this._getTransformedBegin().sub(ray.pos);
        // Test is line and ray are parallel and non intersecting
        if (ray.dir.cross(this.getSlope()) === 0 && numerator.cross(ray.dir) !== 0) {
            return null;
        }
        // Lines are parallel
        const divisor = ray.dir.cross(this.getSlope());
        if (divisor === 0) {
            return null;
        }
        const t = numerator.cross(this.getSlope()) / divisor;
        if (t >= 0 && t <= max) {
            const u = numerator.cross(ray.dir) / divisor / this.getLength();
            if (u >= 0 && u <= 1) {
                return ray.getPoint(t);
            }
        }
        return null;
    }
    /**
     * Returns the closes line between this and another collider, from this -> collider
     * @param shape
     */
    getClosestLineBetween(shape) {
        if (shape instanceof CircleCollider) {
            return ClosestLineJumpTable.CircleEdgeClosestLine(shape, this);
        }
        else if (shape instanceof PolygonCollider) {
            return ClosestLineJumpTable.PolygonEdgeClosestLine(shape, this).flip();
        }
        else if (shape instanceof EdgeCollider) {
            return ClosestLineJumpTable.EdgeEdgeClosestLine(this, shape);
        }
        else {
            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);
        }
    }
    /**
     * @inheritdoc
     */
    collide(shape) {
        if (shape instanceof CircleCollider) {
            return CollisionJumpTable.CollideCircleEdge(shape, this);
        }
        else if (shape instanceof PolygonCollider) {
            return CollisionJumpTable.CollidePolygonEdge(shape, this);
        }
        else if (shape instanceof EdgeCollider) {
            return CollisionJumpTable.CollideEdgeEdge();
        }
        else {
            throw new Error(`Edge could not collide with unknown CollisionShape ${typeof shape}`);
        }
    }
    /**
     * Find the point on the collider furthest in the direction specified
     */
    getFurthestPoint(direction) {
        const transformedBegin = this._getTransformedBegin();
        const transformedEnd = this._getTransformedEnd();
        if (direction.dot(transformedBegin) > 0) {
            return transformedBegin;
        }
        else {
            return transformedEnd;
        }
    }
    _boundsFromBeginEnd(begin, end, padding = 10) {
        // A perfectly vertical or horizontal edge would have a bounds 0 width or height
        // this causes problems for the collision system so we give them some padding
        return new BoundingBox(Math.min(begin.x, end.x) - padding, Math.min(begin.y, end.y) - padding, Math.max(begin.x, end.x) + padding, Math.max(begin.y, end.y) + padding);
    }
    /**
     * Get the axis aligned bounding box for the edge collider in world space
     */
    get bounds() {
        const transformedBegin = this._getTransformedBegin();
        const transformedEnd = this._getTransformedEnd();
        return this._boundsFromBeginEnd(transformedBegin, transformedEnd);
    }
    /**
     * Get the axis aligned bounding box for the edge collider in local space
     */
    get localBounds() {
        return this._boundsFromBeginEnd(this.begin, this.end);
    }
    /**
     * Returns this edge represented as a line in world coordinates
     */
    asLine() {
        return new Line(this._getTransformedBegin(), this._getTransformedEnd());
    }
    /**
     * Return this edge as a line in local line coordinates (relative to the position)
     */
    asLocalLine() {
        return new Line(this.begin, this.end);
    }
    /**
     * Get the axis associated with the edge
     */
    get axes() {
        const e = this._getTransformedEnd().sub(this._getTransformedBegin());
        const edgeNormal = e.normal();
        const axes = [];
        axes.push(edgeNormal);
        axes.push(edgeNormal.negate());
        axes.push(edgeNormal.normal());
        axes.push(edgeNormal.normal().negate());
        return axes;
    }
    /**
     * Get the moment of inertia for an edge
     * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
     */
    getInertia(mass) {
        const length = this.end.sub(this.begin).distance() / 2;
        return mass * length * length;
    }
    /**
     * @inheritdoc
     */
    update(transform) {
        this._transform = transform;
    }
    /**
     * Project the edge along a specified axis
     */
    project(axis) {
        const scalars = [];
        const points = [this._getTransformedBegin(), this._getTransformedEnd()];
        const len = points.length;
        for (let i = 0; i < len; i++) {
            scalars.push(points[i].dot(axis));
        }
        return new Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
    }
    draw(ctx, color = Color.Green, pos = Vector.Zero) {
        const begin = this.begin.add(pos);
        const end = this.end.add(pos);
        ctx.strokeStyle = color.toString();
        ctx.beginPath();
        ctx.moveTo(begin.x, begin.y);
        ctx.lineTo(end.x, end.y);
        ctx.closePath();
        ctx.stroke();
    }
    debug(ex, color) {
        const begin = this._getTransformedBegin();
        const end = this._getTransformedEnd();
        ex.drawLine(begin, end, color, 2);
        ex.drawCircle(begin, 2, color);
        ex.drawCircle(end, 2, color);
    }
    /* istanbul ignore next */
    debugDraw(ctx, color = Color.Red) {
        const begin = this._getTransformedBegin();
        const end = this._getTransformedEnd();
        ctx.strokeStyle = color.toString();
        ctx.beginPath();
        ctx.moveTo(begin.x, begin.y);
        ctx.lineTo(end.x, end.y);
        ctx.closePath();
        ctx.stroke();
    }
}

;// CONCATENATED MODULE: ./Collision/Colliders/PolygonCollider.ts











/**
 * Polygon collider for detecting collisions
 */
class PolygonCollider extends Collider {
    constructor(options) {
        var _a;
        super();
        this._transformedPoints = [];
        this._axes = [];
        this._sides = [];
        this._localSides = [];
        this.offset = (_a = options.offset) !== null && _a !== void 0 ? _a : Vector.Zero;
        const winding = !!options.clockwiseWinding;
        this.points = (winding ? options.points.reverse() : options.points) || [];
        // calculate initial transformation
        this._calculateTransformation();
    }
    /**
     * Returns a clone of this ConvexPolygon, not associated with any collider
     */
    clone() {
        return new PolygonCollider({
            offset: this.offset.clone(),
            points: this.points.map((p) => p.clone())
        });
    }
    /**
     * Returns the world position of the collider, which is the current body transform plus any defined offset
     */
    get worldPos() {
        if (this._transform) {
            return this._transform.pos.add(this.offset);
        }
        return this.offset;
    }
    /**
     * Get the center of the collider in world coordinates
     */
    get center() {
        return this.bounds.center;
    }
    /**
     * Calculates the underlying transformation from the body relative space to world space
     */
    _calculateTransformation() {
        const transform = this._transform;
        const pos = transform ? transform.globalPos.add(this.offset) : this.offset;
        const angle = transform ? transform.globalRotation : 0;
        const scale = transform ? transform.globalScale : Vector.One;
        const len = this.points.length;
        this._transformedPoints.length = 0; // clear out old transform
        for (let i = 0; i < len; i++) {
            this._transformedPoints[i] = this.points[i].scale(scale).rotate(angle).add(pos);
        }
    }
    /**
     * Gets the points that make up the polygon in world space, from actor relative space (if specified)
     */
    getTransformedPoints() {
        this._calculateTransformation();
        return this._transformedPoints;
    }
    /**
     * Gets the sides of the polygon in world space
     */
    getSides() {
        if (this._sides.length) {
            return this._sides;
        }
        const lines = [];
        const points = this.getTransformedPoints();
        const len = points.length;
        for (let i = 0; i < len; i++) {
            // This winding is important
            lines.push(new Line(points[i], points[(i + 1) % len]));
        }
        this._sides = lines;
        return this._sides;
    }
    /**
     * Returns the local coordinate space sides
     */
    getLocalSides() {
        if (this._localSides.length) {
            return this._localSides;
        }
        const lines = [];
        const points = this.points;
        const len = points.length;
        for (let i = 0; i < len; i++) {
            // This winding is important
            lines.push(new Line(points[i], points[(i + 1) % len]));
        }
        this._localSides = lines;
        return this._localSides;
    }
    /**
     * Given a direction vector find the world space side that is most in that direction
     * @param direction
     */
    findSide(direction) {
        const sides = this.getSides();
        let bestSide = sides[0];
        let maxDistance = -Number.MAX_VALUE;
        for (let side = 0; side < sides.length; side++) {
            const currentSide = sides[side];
            const sideNormal = currentSide.normal();
            const mostDirection = sideNormal.dot(direction);
            if (mostDirection > maxDistance) {
                bestSide = currentSide;
                maxDistance = mostDirection;
            }
        }
        return bestSide;
    }
    /**
     * Given a direction vector find the local space side that is most in that direction
     * @param direction
     */
    findLocalSide(direction) {
        const sides = this.getLocalSides();
        let bestSide = sides[0];
        let maxDistance = -Number.MAX_VALUE;
        for (let side = 0; side < sides.length; side++) {
            const currentSide = sides[side];
            const sideNormal = currentSide.normal();
            const mostDirection = sideNormal.dot(direction);
            if (mostDirection > maxDistance) {
                bestSide = currentSide;
                maxDistance = mostDirection;
            }
        }
        return bestSide;
    }
    /**
     * Get the axis associated with the convex polygon
     */
    get axes() {
        if (this._axes.length) {
            return this._axes;
        }
        const axes = this.getSides().map((s) => s.normal());
        this._axes = axes;
        return this._axes;
    }
    update(transform) {
        this._transform = transform;
        this._sides.length = 0;
        this._localSides.length = 0;
        this._axes.length = 0;
        this._transformedPoints.length = 0;
        this.getTransformedPoints();
        this.getSides();
        this.getLocalSides();
    }
    /**
     * Tests if a point is contained in this collider in world space
     */
    contains(point) {
        // Always cast to the right, as long as we cast in a consistent fixed direction we
        // will be fine
        const testRay = new Ray(point, new Vector(1, 0));
        const intersectCount = this.getSides().reduce(function (accum, side) {
            if (testRay.intersect(side) >= 0) {
                return accum + 1;
            }
            return accum;
        }, 0);
        if (intersectCount % 2 === 0) {
            return false;
        }
        return true;
    }
    getClosestLineBetween(collider) {
        if (collider instanceof CircleCollider) {
            return ClosestLineJumpTable.PolygonCircleClosestLine(this, collider);
        }
        else if (collider instanceof PolygonCollider) {
            return ClosestLineJumpTable.PolygonPolygonClosestLine(this, collider);
        }
        else if (collider instanceof EdgeCollider) {
            return ClosestLineJumpTable.PolygonEdgeClosestLine(this, collider);
        }
        else {
            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof collider}`);
        }
    }
    /**
     * Returns a collision contact if the 2 colliders collide, otherwise collide will
     * return null.
     * @param collider
     */
    collide(collider) {
        if (collider instanceof CircleCollider) {
            return CollisionJumpTable.CollideCirclePolygon(collider, this);
        }
        else if (collider instanceof PolygonCollider) {
            return CollisionJumpTable.CollidePolygonPolygon(this, collider);
        }
        else if (collider instanceof EdgeCollider) {
            return CollisionJumpTable.CollidePolygonEdge(this, collider);
        }
        else {
            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof collider}`);
        }
    }
    /**
     * Find the point on the collider furthest in the direction specified
     */
    getFurthestPoint(direction) {
        const pts = this.getTransformedPoints();
        let furthestPoint = null;
        let maxDistance = -Number.MAX_VALUE;
        for (let i = 0; i < pts.length; i++) {
            const distance = direction.dot(pts[i]);
            if (distance > maxDistance) {
                maxDistance = distance;
                furthestPoint = pts[i];
            }
        }
        return furthestPoint;
    }
    /**
     * Find the local point on the collider furthest in the direction specified
     * @param direction
     */
    getFurthestLocalPoint(direction) {
        const pts = this.points;
        let furthestPoint = pts[0];
        let maxDistance = -Number.MAX_VALUE;
        for (let i = 0; i < pts.length; i++) {
            const distance = direction.dot(pts[i]);
            if (distance > maxDistance) {
                maxDistance = distance;
                furthestPoint = pts[i];
            }
        }
        return furthestPoint;
    }
    /**
     * Finds the closes face to the point using perpendicular distance
     * @param point point to test against polygon
     */
    getClosestFace(point) {
        const sides = this.getSides();
        let min = Number.POSITIVE_INFINITY;
        let faceIndex = -1;
        let distance = -1;
        for (let i = 0; i < sides.length; i++) {
            const dist = sides[i].distanceToPoint(point);
            if (dist < min) {
                min = dist;
                faceIndex = i;
                distance = dist;
            }
        }
        if (faceIndex !== -1) {
            return {
                distance: sides[faceIndex].normal().scale(distance),
                face: sides[faceIndex]
            };
        }
        return null;
    }
    /**
     * Get the axis aligned bounding box for the polygon collider in world coordinates
     */
    get bounds() {
        var _a, _b, _c;
        const tx = this._transform;
        const scale = (_a = tx === null || tx === void 0 ? void 0 : tx.globalScale) !== null && _a !== void 0 ? _a : Vector.One;
        const rotation = (_b = tx === null || tx === void 0 ? void 0 : tx.globalRotation) !== null && _b !== void 0 ? _b : 0;
        const pos = ((_c = tx === null || tx === void 0 ? void 0 : tx.globalPos) !== null && _c !== void 0 ? _c : Vector.Zero).add(this.offset);
        return this.localBounds.scale(scale).rotate(rotation).translate(pos);
    }
    /**
     * Get the axis aligned bounding box for the polygon collider in local coordinates
     */
    get localBounds() {
        return BoundingBox.fromPoints(this.points);
    }
    /**
     * Get the moment of inertia for an arbitrary polygon
     * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
     */
    getInertia(mass) {
        let numerator = 0;
        let denominator = 0;
        for (let i = 0; i < this.points.length; i++) {
            const iplusone = (i + 1) % this.points.length;
            const crossTerm = this.points[iplusone].cross(this.points[i]);
            numerator +=
                crossTerm *
                    (this.points[i].dot(this.points[i]) + this.points[i].dot(this.points[iplusone]) + this.points[iplusone].dot(this.points[iplusone]));
            denominator += crossTerm;
        }
        return (mass / 6) * (numerator / denominator);
    }
    /**
     * Casts a ray into the polygon and returns a vector representing the point of contact (in world space) or null if no collision.
     */
    rayCast(ray, max = Infinity) {
        // find the minimum contact time greater than 0
        // contact times less than 0 are behind the ray and we don't want those
        const sides = this.getSides();
        const len = sides.length;
        let minContactTime = Number.MAX_VALUE;
        let contactIndex = -1;
        for (let i = 0; i < len; i++) {
            const contactTime = ray.intersect(sides[i]);
            if (contactTime >= 0 && contactTime < minContactTime && contactTime <= max) {
                minContactTime = contactTime;
                contactIndex = i;
            }
        }
        // contact was found
        if (contactIndex >= 0) {
            return ray.getPoint(minContactTime);
        }
        // no contact found
        return null;
    }
    /**
     * Project the edges of the polygon along a specified axis
     */
    project(axis) {
        const points = this.getTransformedPoints();
        const len = points.length;
        let min = Number.MAX_VALUE;
        let max = -Number.MAX_VALUE;
        for (let i = 0; i < len; i++) {
            const scalar = points[i].dot(axis);
            min = Math.min(min, scalar);
            max = Math.max(max, scalar);
        }
        return new Projection(min, max);
    }
    draw(ctx, color = Color.Green, pos = Vector.Zero) {
        const effectiveOffset = pos.add(this.offset);
        ctx.beginPath();
        ctx.fillStyle = color.toString();
        const firstPoint = this.points[0].add(effectiveOffset);
        ctx.moveTo(firstPoint.x, firstPoint.y);
        // Points are relative
        this.points
            .map((p) => p.add(effectiveOffset))
            .forEach(function (point) {
            ctx.lineTo(point.x, point.y);
        });
        ctx.lineTo(firstPoint.x, firstPoint.y);
        ctx.closePath();
        ctx.fill();
    }
    debug(ex, color) {
        const firstPoint = this.getTransformedPoints()[0];
        const points = [firstPoint, ...this.getTransformedPoints(), firstPoint];
        for (let i = 0; i < points.length - 1; i++) {
            ex.drawLine(points[i], points[i + 1], color, 2);
            ex.drawCircle(points[i], 2, color);
            ex.drawCircle(points[i + 1], 2, color);
        }
    }
    /* istanbul ignore next */
    debugDraw(ctx, color = Color.Red) {
        ctx.beginPath();
        ctx.strokeStyle = color.toString();
        // Iterate through the supplied points and construct a 'polygon'
        const firstPoint = this.getTransformedPoints()[0];
        ctx.moveTo(firstPoint.x, firstPoint.y);
        this.getTransformedPoints().forEach(function (point) {
            ctx.lineTo(point.x, point.y);
        });
        ctx.lineTo(firstPoint.x, firstPoint.y);
        ctx.closePath();
        ctx.stroke();
    }
}

;// CONCATENATED MODULE: ./Collision/Colliders/Shape.ts







/**
 * Excalibur helper for defining colliders quickly
 */
class Shape {
    /**
     * Creates a box collider, under the hood defines a [[PolygonCollider]] collider
     * @param width Width of the box
     * @param height Height of the box
     * @param anchor Anchor of the box (default (.5, .5)) which positions the box relative to the center of the collider's position
     * @param offset Optional offset relative to the collider in local coordinates
     */
    static Box(width, height, anchor = Vector.Half, offset = Vector.Zero) {
        return new PolygonCollider({
            points: new BoundingBox(-width * anchor.x, -height * anchor.y, width - width * anchor.x, height - height * anchor.y).getPoints(),
            offset: offset
        });
    }
    /**
     * Creates a new [[PolygonCollider|arbitrary polygon]] collider
     *
     * PolygonColliders are useful for creating convex polygon shapes
     * @param points Points specified in counter clockwise
     * @param clockwiseWinding Optionally changed the winding of points, by default false meaning counter-clockwise winding.
     * @param offset Optional offset relative to the collider in local coordinates
     */
    static Polygon(points, clockwiseWinding = false, offset = Vector.Zero) {
        return new PolygonCollider({
            points: points,
            offset: offset,
            clockwiseWinding: clockwiseWinding
        });
    }
    /**
     * Creates a new [[CircleCollider|circle]] collider
     *
     * Circle colliders are useful for balls, or to make collisions more forgiving on sharp edges
     * @param radius Radius of the circle collider
     * @param offset Optional offset relative to the collider in local coordinates
     */
    static Circle(radius, offset = Vector.Zero) {
        return new CircleCollider({
            radius: radius,
            offset: offset
        });
    }
    /**
     * Creates a new [[EdgeCollider|edge]] collider
     *
     * Edge colliders are useful for  floors, walls, and other barriers
     * @param begin Beginning of the edge in local coordinates to the collider
     * @param end Ending of the edge in local coordinates to the collider
     */
    static Edge(begin, end) {
        return new EdgeCollider({
            begin: begin,
            end: end
        });
    }
    /**
     * Creates a new capsule shaped [[CompositeCollider]] using 2 circles and a box
     *
     * Capsule colliders are useful for platformers with incline or jagged floors to have a smooth
     * player experience.
     *
     * @param width
     * @param height
     * @param offset Optional offset
     */
    static Capsule(width, height, offset = Vector.Zero) {
        const logger = Logger.getInstance();
        if (width === height) {
            logger.warn('A capsule collider with equal width and height is a circle, consider using a ex.Shape.Circle or ex.CircleCollider');
        }
        const vertical = height >= width;
        if (vertical) {
            // height > width, if equal maybe use a circle
            const capsule = new CompositeCollider([
                Shape.Circle(width / 2, vec(0, -height / 2 + width / 2).add(offset)),
                Shape.Box(width, height - width, Vector.Half, offset),
                Shape.Circle(width / 2, vec(0, height / 2 - width / 2).add(offset))
            ]);
            return capsule;
        }
        else {
            // width > height, if equal maybe use a circle
            const capsule = new CompositeCollider([
                Shape.Circle(height / 2, vec(-width / 2 + height / 2, 0).add(offset)),
                Shape.Box(width - height, height, Vector.Half, offset),
                Shape.Circle(height / 2, vec(width / 2 - height / 2, 0).add(offset))
            ]);
            return capsule;
        }
    }
}

;// CONCATENATED MODULE: ./Collision/ColliderComponent.ts









class ColliderComponent extends Component {
    constructor(collider) {
        super();
        this.type = 'ex.collider';
        this.events = new EventDispatcher(this);
        /**
         * Observable that notifies when a collider is added to the body
         */
        this.$colliderAdded = new Observable();
        /**
         * Observable that notifies when a collider is removed from the body
         */
        this.$colliderRemoved = new Observable();
        this.set(collider);
    }
    /**
     * Get the current collider geometry
     * @returns
     */
    get() {
        return this._collider;
    }
    /**
     * Set the collider geometry
     * @param collider
     * @returns the collider you set
     */
    set(collider) {
        this.clear();
        if (collider) {
            this._collider = collider;
            this._collider.owner = this.owner;
            this.events.wire(collider.events);
            this.$colliderAdded.notifyAll(collider);
            this.update();
        }
        return collider;
    }
    /**
     * Remove collider geometry from collider component
     */
    clear() {
        if (this._collider) {
            this.events.unwire(this._collider.events);
            this.$colliderRemoved.notifyAll(this._collider);
            this._collider.owner = null;
            this._collider = null;
        }
    }
    /**
     * Return world space bounds
     */
    get bounds() {
        var _a, _b;
        return (_b = (_a = this._collider) === null || _a === void 0 ? void 0 : _a.bounds) !== null && _b !== void 0 ? _b : new BoundingBox();
    }
    /**
     * Return local space bounds
     */
    get localBounds() {
        var _a, _b;
        return (_b = (_a = this._collider) === null || _a === void 0 ? void 0 : _a.localBounds) !== null && _b !== void 0 ? _b : new BoundingBox();
    }
    /**
     * Update the collider's transformed geometry
     */
    update() {
        var _a;
        const tx = (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent);
        if (this._collider) {
            this._collider.owner = this.owner;
            if (tx) {
                this._collider.update(tx);
            }
        }
    }
    /**
     * Collide component with another
     * @param other
     * @returns
     */
    collide(other) {
        let colliderA = this._collider;
        let colliderB = other._collider;
        if (!colliderA || !colliderB) {
            return [];
        }
        // If we have a composite lefthand side :(
        // Might bite us, but to avoid updating all the handlers make composite always left side
        let flipped = false;
        if (colliderB instanceof CompositeCollider) {
            colliderA = colliderB;
            colliderB = this._collider;
            flipped = true;
        }
        if (this._collider) {
            const contacts = colliderA.collide(colliderB);
            if (contacts) {
                if (flipped) {
                    contacts.forEach((contact) => {
                        contact.mtv = contact.mtv.negate();
                        contact.normal = contact.normal.negate();
                        contact.tangent = contact.normal.perpendicular();
                        contact.colliderA = this._collider;
                        contact.colliderB = other._collider;
                    });
                }
                return contacts;
            }
            return [];
        }
        return [];
    }
    onAdd(entity) {
        if (this._collider) {
            this.update();
        }
        // Wire up the collider events to the owning entity
        this.events.on('precollision', (evt) => {
            const precollision = evt;
            entity.events.emit('precollision', new PreCollisionEvent(precollision.target.owner, precollision.other.owner, precollision.side, precollision.intersection));
        });
        this.events.on('postcollision', (evt) => {
            const postcollision = evt;
            entity.events.emit('postcollision', new PostCollisionEvent(postcollision.target.owner, postcollision.other.owner, postcollision.side, postcollision.intersection));
        });
        this.events.on('collisionstart', (evt) => {
            const start = evt;
            entity.events.emit('collisionstart', new CollisionStartEvent(start.target.owner, start.other.owner, start.contact));
        });
        this.events.on('collisionend', (evt) => {
            const end = evt;
            entity.events.emit('collisionend', new CollisionEndEvent(end.target.owner, end.other.owner));
        });
    }
    onRemove() {
        this.events.clear();
        this.$colliderRemoved.notifyAll(this._collider);
    }
    /**
     * Sets up a box geometry based on the current bounds of the associated actor of this physics body.
     *
     * If no width/height are specified the body will attempt to use the associated actor's width/height.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    useBoxCollider(width, height, anchor = Vector.Half, center = Vector.Zero) {
        const collider = Shape.Box(width, height, anchor, center);
        return (this.set(collider));
    }
    /**
     * Sets up a [[PolygonCollider|polygon]] collision geometry based on a list of of points relative
     *  to the anchor of the associated actor
     * of this physics body.
     *
     * Only [convex polygon](https://en.wikipedia.org/wiki/Convex_polygon) definitions are supported.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    usePolygonCollider(points, center = Vector.Zero) {
        const poly = Shape.Polygon(points, false, center);
        return (this.set(poly));
    }
    /**
     * Sets up a [[Circle|circle collision geometry]] as the only collider with a specified radius in pixels.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    useCircleCollider(radius, center = Vector.Zero) {
        const collider = Shape.Circle(radius, center);
        return (this.set(collider));
    }
    /**
     * Sets up an [[Edge|edge collision geometry]] with a start point and an end point relative to the anchor of the associated actor
     * of this physics body.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    useEdgeCollider(begin, end) {
        const collider = Shape.Edge(begin, end);
        return (this.set(collider));
    }
    /**
     * Setups up a [[CompositeCollider]] which can define any arbitrary set of excalibur colliders
     * @param colliders
     * @returns
     */
    useCompositeCollider(colliders) {
        return (this.set(new CompositeCollider(colliders)));
    }
}

;// CONCATENATED MODULE: ./Collision/BodyComponent.ts











var DegreeOfFreedom;
(function (DegreeOfFreedom) {
    DegreeOfFreedom["Rotation"] = "rotation";
    DegreeOfFreedom["X"] = "x";
    DegreeOfFreedom["Y"] = "y";
})(DegreeOfFreedom || (DegreeOfFreedom = {}));
/**
 * Body describes all the physical properties pos, vel, acc, rotation, angular velocity for the purpose of
 * of physics simulation.
 */
class BodyComponent extends Component {
    constructor(options) {
        var _a, _b, _c;
        super();
        this.type = 'ex.body';
        this.dependencies = [TransformComponent, MotionComponent];
        this.id = createId('body', BodyComponent._ID++);
        this.events = new EventDispatcher(this);
        /**
         * Collision type for the rigidbody physics simulation, by default [[CollisionType.PreventCollision]]
         */
        this.collisionType = CollisionType.PreventCollision;
        /**
         * The collision group for the body's colliders, by default body colliders collide with everything
         */
        this.group = CollisionGroup.All;
        /**
         * The amount of mass the body has
         */
        this.mass = Physics.defaultMass;
        /**
         * Amount of "motion" the body has before sleeping. If below [[Physics.sleepEpsilon]] it goes to "sleep"
         */
        this.sleepMotion = Physics.sleepEpsilon * 5;
        /**
         * Can this body sleep, by default bodies do not sleep
         */
        this.canSleep = Physics.bodiesCanSleepByDefault;
        this._sleeping = false;
        /**
         * The also known as coefficient of restitution of this actor, represents the amount of energy preserved after collision or the
         * bounciness. If 1, it is 100% bouncy, 0 it completely absorbs.
         */
        this.bounciness = 0.2;
        /**
         * The coefficient of friction on this actor
         */
        this.friction = 0.99;
        /**
         * Should use global gravity [[Physics.gravity]] in it's physics simulation, default is true
         */
        this.useGravity = true;
        /**
         * Degrees of freedom to limit
         */
        this.limitDegreeOfFreedom = [];
        /**
         * The position of the actor last frame (x, y) in pixels
         */
        this.oldPos = new Vector(0, 0);
        /**
         * The velocity of the actor last frame (vx, vy) in pixels/second
         */
        this.oldVel = new Vector(0, 0);
        /**
         * Gets/sets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].
         */
        this.oldAcc = Vector.Zero;
        /**
         * Gets/sets the rotation of the body from the last frame.
         */
        this.oldRotation = 0; // radians
        /**
         * The scale of the actor last frame
         * @deprecated ex.Body.scale will be removed in v0.25.0
         */
        this.oldScale = Vector.One;
        if (options) {
            this.collisionType = (_a = options.type) !== null && _a !== void 0 ? _a : this.collisionType;
            this.group = (_b = options.group) !== null && _b !== void 0 ? _b : this.group;
            this.useGravity = (_c = options.useGravity) !== null && _c !== void 0 ? _c : this.useGravity;
        }
    }
    /**
     * The inverse mass (1/mass) of the body. If [[CollisionType.Fixed]] this is 0, meaning "infinite" mass
     */
    get inverseMass() {
        return this.collisionType === CollisionType.Fixed ? 0 : 1 / this.mass;
    }
    /**
     * Whether this body is sleeping or not
     */
    get sleeping() {
        return this._sleeping;
    }
    /**
     * Set the sleep state of the body
     * @param sleeping
     */
    setSleeping(sleeping) {
        this._sleeping = sleeping;
        if (!sleeping) {
            // Give it a kick to keep it from falling asleep immediately
            this.sleepMotion = Physics.sleepEpsilon * 5;
        }
        else {
            this.vel = Vector.Zero;
            this.acc = Vector.Zero;
            this.angularVelocity = 0;
            this.sleepMotion = 0;
        }
    }
    /**
     * Update body's [[BodyComponent.sleepMotion]] for the purpose of sleeping
     */
    updateMotion() {
        if (this._sleeping) {
            this.setSleeping(true);
        }
        const currentMotion = this.vel.size * this.vel.size + Math.abs(this.angularVelocity * this.angularVelocity);
        const bias = Physics.sleepBias;
        this.sleepMotion = bias * this.sleepMotion + (1 - bias) * currentMotion;
        this.sleepMotion = clamp(this.sleepMotion, 0, 10 * Physics.sleepEpsilon);
        if (this.canSleep && this.sleepMotion < Physics.sleepEpsilon) {
            this.setSleeping(true);
        }
    }
    /**
     * Get the moment of inertia from the [[ColliderComponent]]
     */
    get inertia() {
        // Inertia is a property of the geometry, so this is a little goofy but seems to be okay?
        const collider = this.owner.get(ColliderComponent);
        if (collider === null || collider === void 0 ? void 0 : collider.get()) {
            return collider.get().getInertia(this.mass);
        }
        return 0;
    }
    /**
     * Get the inverse moment of inertial from the [[ColliderComponent]]. If [[CollisionType.Fixed]] this is 0, meaning "infinite" mass
     */
    get inverseInertia() {
        return this.collisionType === CollisionType.Fixed ? 0 : 1 / this.inertia;
    }
    /**
     * Returns if the owner is active
     */
    get active() {
        var _a;
        return !!((_a = this.owner) === null || _a === void 0 ? void 0 : _a.active);
    }
    get center() {
        return this.pos;
    }
    get transform() {
        var _a;
        return (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent);
    }
    get motion() {
        var _a;
        return (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(MotionComponent);
    }
    /**
     * The (x, y) position of the actor this will be in the middle of the actor if the
     * [[Actor.anchor]] is set to (0.5, 0.5) which is default.
     * If you want the (x, y) position to be the top left of the actor specify an anchor of (0, 0).
     */
    get pos() {
        return this.transform.globalPos;
    }
    set pos(val) {
        this.transform.globalPos = val;
    }
    /**
     * The current velocity vector (vx, vy) of the actor in pixels/second
     */
    get vel() {
        return this.motion.vel;
    }
    set vel(val) {
        this.motion.vel = val;
    }
    /**
     * The current acceleration vector (ax, ay) of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may
     * be useful to simulate a gravitational effect.
     */
    get acc() {
        return this.motion.acc;
    }
    set acc(val) {
        this.motion.acc = val;
    }
    /**
     * The current torque applied to the actor
     */
    get torque() {
        return this.motion.torque;
    }
    set torque(val) {
        this.motion.torque = val;
    }
    /**
     * The rotation of the body in radians
     */
    get rotation() {
        return this.transform.globalRotation;
    }
    set rotation(val) {
        this.transform.globalRotation = val;
    }
    /**
     * The scale vector of the actor
     * @deprecated ex.Body.scale will be removed in v0.25.0, Use ex.Transform.scale
     */
    get scale() {
        return this.transform.globalScale;
    }
    set scale(val) {
        this.transform.globalScale = val;
    }
    /**
     * The x scalar velocity of the actor in scale/second
     * @deprecated ex.Body.scale will be removed in v0.25.0
     */
    get sx() {
        return this.motion.scaleFactor.x;
    }
    set sx(xFactor) {
        this.motion.scaleFactor.x = xFactor;
    }
    /**
     * The y scalar velocity of the actor in scale/second
     * @deprecated ex.Body.scale will be removed in v0.25.0
     */
    get sy() {
        return this.motion.scaleFactor.y;
    }
    set sy(yFactor) {
        this.motion.scaleFactor.y = yFactor;
    }
    /**
     * The rotational velocity of the actor in radians/second
     * @deprecated
     */
    get rx() {
        return this.motion.angularVelocity;
    }
    /**
     * The rotational velocity of the actor in radians/second
     * @deprecated
     */
    set rx(value) {
        this.motion.angularVelocity = value;
    }
    /**
     * Get the angular velocity in radians/second
     */
    get angularVelocity() {
        return this.motion.angularVelocity;
    }
    /**
     * Set the angular velocity in radians/second
     */
    set angularVelocity(value) {
        this.motion.angularVelocity = value;
    }
    /**
     * Apply a specific impulse to the body
     * @param point
     * @param impulse
     */
    applyImpulse(point, impulse) {
        if (this.collisionType !== CollisionType.Active) {
            return; // only active objects participate in the simulation
        }
        const finalImpulse = impulse.scale(this.inverseMass);
        if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {
            finalImpulse.x = 0;
        }
        if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {
            finalImpulse.y = 0;
        }
        this.vel.addEqual(finalImpulse);
        if (!this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {
            const distanceFromCenter = point.sub(this.pos);
            this.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);
        }
    }
    /**
     * Apply only linear impulse to the body
     * @param impulse
     */
    applyLinearImpulse(impulse) {
        if (this.collisionType !== CollisionType.Active) {
            return; // only active objects participate in the simulation
        }
        const finalImpulse = impulse.scale(this.inverseMass);
        if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {
            finalImpulse.x = 0;
        }
        if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {
            finalImpulse.y = 0;
        }
        this.vel = this.vel.add(finalImpulse);
    }
    /**
     * Apply only angular impuse to the body
     * @param point
     * @param impulse
     */
    applyAngularImpulse(point, impulse) {
        if (this.collisionType !== CollisionType.Active) {
            return; // only active objects participate in the simulation
        }
        if (!this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {
            const distanceFromCenter = point.sub(this.pos);
            this.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);
        }
    }
    /**
     * Sets the old versions of pos, vel, acc, and scale.
     */
    captureOldTransform() {
        // Capture old values before integration step updates them
        this.oldVel.setTo(this.vel.x, this.vel.y);
        this.oldPos.setTo(this.pos.x, this.pos.y);
        this.oldAcc.setTo(this.acc.x, this.acc.y);
        this.oldScale.setTo(this.scale.x, this.scale.y);
        this.oldRotation = this.rotation;
    }
    debugDraw(_ctx) {
        // pass
    }
}
BodyComponent._ID = 0;

;// CONCATENATED MODULE: ./Util/CullingBox.ts


/**
 * @deprecated Will be removed in 0.26.0
 */
class CullingBox {
    constructor() {
        this._topLeft = new Vector(0, 0);
        this._topRight = new Vector(0, 0);
        this._bottomLeft = new Vector(0, 0);
        this._bottomRight = new Vector(0, 0);
    }
    isSpriteOffScreen(actor, engine) {
        const drawingWidth = actor.currentDrawing.drawWidth;
        const drawingHeight = actor.currentDrawing.drawHeight;
        const rotation = actor.rotation;
        const anchor = actor.center;
        const worldPos = actor.getGlobalPos();
        this._topLeft = vec(worldPos.x - drawingWidth / 2, worldPos.y - drawingHeight / 2);
        this._topLeft = this._topLeft.rotate(rotation, anchor);
        this._topRight = vec(worldPos.x + drawingWidth / 2, worldPos.y - drawingHeight / 2);
        this._topRight = this._topRight.rotate(rotation, anchor);
        this._bottomLeft = vec(worldPos.x - drawingWidth / 2, worldPos.y + drawingHeight / 2);
        this._bottomLeft = this._bottomLeft.rotate(rotation, anchor);
        this._bottomRight = vec(worldPos.x + drawingWidth / 2, worldPos.y + drawingHeight / 2);
        this._bottomRight = this._bottomRight.rotate(rotation, anchor);
        const topLeftScreen = engine.worldToScreenCoordinates(this._topLeft);
        const topRightScreen = engine.worldToScreenCoordinates(this._topRight);
        const bottomLeftScreen = engine.worldToScreenCoordinates(this._bottomLeft);
        const bottomRightScreen = engine.worldToScreenCoordinates(this._bottomRight);
        this._xCoords = [];
        this._yCoords = [];
        this._xCoords.push(topLeftScreen.x, topRightScreen.x, bottomLeftScreen.x, bottomRightScreen.x);
        this._yCoords.push(topLeftScreen.y, topRightScreen.y, bottomLeftScreen.y, bottomRightScreen.y);
        this._xMin = Math.min.apply(null, this._xCoords);
        this._yMin = Math.min.apply(null, this._yCoords);
        this._xMax = Math.max.apply(null, this._xCoords);
        this._yMax = Math.max.apply(null, this._yCoords);
        const minWorld = engine.screenToWorldCoordinates(new Vector(this._xMin, this._yMin));
        const maxWorld = engine.screenToWorldCoordinates(new Vector(this._xMax, this._yMax));
        this._xMinWorld = minWorld.x;
        this._yMinWorld = minWorld.y;
        this._xMaxWorld = maxWorld.x;
        this._yMaxWorld = maxWorld.y;
        const boundingPoints = [
            new Vector(this._xMin, this._yMin),
            new Vector(this._xMax, this._yMin),
            new Vector(this._xMin, this._yMax),
            new Vector(this._xMax, this._yMax) // bottom right
        ];
        // sprite can be wider than canvas screen (and still visible within canvas)
        // top or bottom of sprite must be within canvas
        if (boundingPoints[0].x < 0 &&
            boundingPoints[1].x > engine.canvas.clientWidth &&
            (boundingPoints[0].y > 0 || boundingPoints[2].y < engine.canvas.clientHeight)) {
            return false;
        }
        // sprite can be taller than canvas screen (and still visible within canvas)
        // left or right of sprite must be within canvas
        if (boundingPoints[0].y < 0 &&
            boundingPoints[2].y > engine.canvas.clientHeight &&
            (boundingPoints[1].x > 0 || boundingPoints[0].x < engine.canvas.clientWidth)) {
            return false;
        }
        // otherwise if any corner is visible, we're not offscreen
        for (let i = 0; i < boundingPoints.length; i++) {
            if (boundingPoints[i].x > 0 &&
                boundingPoints[i].y > 0 &&
                boundingPoints[i].x < engine.canvas.clientWidth &&
                boundingPoints[i].y < engine.canvas.clientHeight) {
                return false;
            }
        }
        return true;
    }
    debugDraw(ctx) {
        // bounding rectangle
        ctx.beginPath();
        ctx.strokeStyle = Color.White.toString();
        ctx.rect(this._xMinWorld, this._yMinWorld, this._xMaxWorld - this._xMinWorld, this._yMaxWorld - this._yMinWorld);
        ctx.stroke();
        ctx.fillStyle = Color.Red.toString();
        ctx.beginPath();
        ctx.arc(this._topLeft.x, this._topLeft.y, 5, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = Color.Green.toString();
        ctx.beginPath();
        ctx.arc(this._topRight.x, this._topRight.y, 5, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = Color.Blue.toString();
        ctx.beginPath();
        ctx.arc(this._bottomLeft.x, this._bottomLeft.y, 5, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = Color.Magenta.toString();
        ctx.beginPath();
        ctx.arc(this._bottomRight.x, this._bottomRight.y, 5, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();
    }
}

;// CONCATENATED MODULE: ./Traits/OffscreenCulling.ts



/**
 * @deprecated will be removed in 0.26.0
 */
class OffscreenCulling {
    constructor() {
        this.cullingBox = new CullingBox();
    }
    update(actor, engine) {
        const events = actor.eventDispatcher;
        let isSpriteOffScreen = true;
        if (actor.currentDrawing != null) {
            isSpriteOffScreen = this.cullingBox.isSpriteOffScreen(actor, engine);
        }
        let actorBoundsOffscreen = false;
        if (engine && engine.currentScene && engine.currentScene.camera && engine.currentScene.camera.viewport && !actor.parent) {
            actorBoundsOffscreen = !engine.currentScene.camera.viewport.intersect(actor.collider.bounds);
        }
        if (!actor.isOffScreen) {
            if (actorBoundsOffscreen && isSpriteOffScreen) {
                events.emit('exitviewport', new ExitViewPortEvent(actor));
                actor.addComponent(new TagComponent('offscreen'));
            }
        }
        else {
            if (!actorBoundsOffscreen || !isSpriteOffScreen) {
                events.emit('enterviewport', new EnterViewPortEvent(actor));
                actor.removeComponent('offscreen');
            }
        }
    }
}

;// CONCATENATED MODULE: ./Traits/CapturePointer.ts
/**
 * Revises pointer events path accordingly to the actor
 * @deprecated Will be removed in 0.26.0
 */
class CapturePointer {
    update(actor, engine) {
        if (!actor.enableCapturePointer) {
            return;
        }
        if (actor.isKilled()) {
            return;
        }
        engine.input.pointers.checkAndUpdateActorUnderPointer(actor);
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/Entity.ts





/**
 * AddedComponent message
 */
class AddedComponent {
    constructor(data) {
        this.data = data;
        this.type = 'Component Added';
    }
}
/**
 * Type guard to know if message is f an Added Component
 */
function isAddedComponent(x) {
    return !!x && x.type === 'Component Added';
}
/**
 * RemovedComponent message
 */
class RemovedComponent {
    constructor(data) {
        this.data = data;
        this.type = 'Component Removed';
    }
}
/**
 * Type guard to know if message is for a Removed Component
 */
function isRemovedComponent(x) {
    return !!x && x.type === 'Component Removed';
}
/**
 * An Entity is the base type of anything that can have behavior in Excalibur, they are part of the built in entity component system
 *
 * Entities can be strongly typed with the components they contain
 *
 * ```typescript
 * const entity = new Entity<ComponentA | ComponentB>();
 * entity.components.a; // Type ComponentA
 * entity.components.b; // Type ComponentB
 * ```
 */
class Entity extends Class {
    constructor(components, name) {
        super();
        /**
         * The unique identifier for the entity
         */
        this.id = Entity._ID++;
        this._name = 'anonymous';
        /**
         * Whether this entity is active, if set to false it will be reclaimed
         */
        this.active = true;
        /**
         * Bucket to hold on to deferred removals
         */
        this._componentsToRemove = [];
        this._componentTypeToInstance = new Map();
        this._componentStringToInstance = new Map();
        this._tagsMemo = [];
        this._typesMemo = [];
        /**
         * Observable that keeps track of component add or remove changes on the entity
         */
        this.componentAdded$ = new Observable();
        this.componentRemoved$ = new Observable();
        this._parent = null;
        this.childrenAdded$ = new Observable();
        this.childrenRemoved$ = new Observable();
        this._children = [];
        this._isInitialized = false;
        this._setName(name);
        if (components) {
            for (const component of components) {
                this.addComponent(component);
            }
        }
    }
    _setName(name) {
        if (name) {
            this._name = name;
        }
    }
    get name() {
        return this._name;
    }
    get events() {
        return this.eventDispatcher;
    }
    /**
     * Kill the entity, means it will no longer be updated. Kills are deferred to the end of the update.
     */
    kill() {
        this.active = false;
    }
    isKilled() {
        return !this.active;
    }
    /**
     * Specifically get the tags on the entity from [[TagComponent]]
     */
    get tags() {
        return this._tagsMemo;
    }
    /**
     * Check if a tag exists on the entity
     * @param tag name to check for
     */
    hasTag(tag) {
        return this.tags.includes(tag);
    }
    /**
     * Adds a tag to an entity
     * @param tag
     * @returns Entity
     */
    addTag(tag) {
        return this.addComponent(new TagComponent(tag));
    }
    /**
     * Removes a tag on the entity
     *
     * Removals are deferred until the end of update
     * @param tag
     * @param force Remove component immediately, no deferred
     */
    removeTag(tag, force = false) {
        return this.removeComponent(tag, force);
    }
    /**
     * The types of the components on the Entity
     */
    get types() {
        return this._typesMemo;
    }
    _rebuildMemos() {
        this._tagsMemo = Array.from(this._componentStringToInstance.values())
            .filter((c) => c instanceof TagComponent)
            .map((c) => c.type);
        this._typesMemo = Array.from(this._componentStringToInstance.keys());
    }
    getComponents() {
        return Array.from(this._componentStringToInstance.values());
    }
    _notifyAddComponent(component) {
        this._rebuildMemos();
        const added = new AddedComponent({
            component,
            entity: this
        });
        this.componentAdded$.notifyAll(added);
    }
    _notifyRemoveComponent(component) {
        const removed = new RemovedComponent({
            component,
            entity: this
        });
        this.componentRemoved$.notifyAll(removed);
        this._rebuildMemos();
    }
    get parent() {
        return this._parent;
    }
    /**
     * Get the direct children of this entity
     */
    get children() {
        return this._children;
    }
    /**
     * Unparents this entity, if there is a parent. Otherwise it does nothing.
     */
    unparent() {
        if (this._parent) {
            this._parent.removeChild(this);
            this._parent = null;
        }
    }
    /**
     * Adds an entity to be a child of this entity
     * @param entity
     */
    addChild(entity) {
        if (entity.parent === null) {
            if (this.getAncestors().includes(entity)) {
                throw new Error('Cycle detected, cannot add entity');
            }
            this._children.push(entity);
            entity._parent = this;
            this.childrenAdded$.notifyAll(entity);
        }
        else {
            throw new Error('Entity already has a parent, cannot add without unparenting');
        }
        return this;
    }
    /**
     * Remove an entity from children if it exists
     * @param entity
     */
    removeChild(entity) {
        if (entity.parent === this) {
            removeItemFromArray(entity, this._children);
            entity._parent = null;
            this.childrenRemoved$.notifyAll(entity);
        }
        return this;
    }
    /**
     * Removes all children from this entity
     */
    removeAllChildren() {
        this.children.forEach((c) => {
            this.removeChild(c);
        });
        return this;
    }
    /**
     * Returns a list of parent entities starting with the topmost parent. Includes the current entity.
     */
    getAncestors() {
        const result = [this];
        let current = this.parent;
        while (current) {
            result.push(current);
            current = current.parent;
        }
        return result.reverse();
    }
    /**
     * Returns a list of all the entities that descend from this entity. Includes the current entity.
     */
    getDescendants() {
        let result = [this];
        let queue = [this];
        while (queue.length > 0) {
            const curr = queue.pop();
            queue = queue.concat(curr.children);
            result = result.concat(curr.children);
        }
        return result;
    }
    /**
     * Creates a deep copy of the entity and a copy of all its components
     */
    clone() {
        const newEntity = new Entity();
        for (const c of this.types) {
            newEntity.addComponent(this.get(c).clone());
        }
        for (const child of this.children) {
            newEntity.addChild(child.clone());
        }
        return newEntity;
    }
    /**
     * Adds a copy of all the components from another template entity as a "prefab"
     * @param templateEntity Entity to use as a template
     * @param force Force component replacement if it aleady exists on the target entity
     */
    addTemplate(templateEntity, force = false) {
        for (const c of templateEntity.getComponents()) {
            this.addComponent(c.clone(), force);
        }
        for (const child of templateEntity.children) {
            this.addChild(child.clone().addTemplate(child));
        }
        return this;
    }
    /**
     * Adds a component to the entity
     * @param component Component or Entity to add copy of components from
     * @param force Optionally overwrite any existing components of the same type
     */
    addComponent(component, force = false) {
        // if component already exists, skip if not forced
        if (this.has(component.type)) {
            if (force) {
                // Remove existing component type if exists when forced
                this.removeComponent(component);
            }
            else {
                // early exit component exiss
                return this;
            }
        }
        // TODO circular dependencies will be a problem
        if (component.dependencies && component.dependencies.length) {
            for (const ctor of component.dependencies) {
                this.addComponent(new ctor());
            }
        }
        component.owner = this;
        const constuctorType = component.constructor;
        this._componentTypeToInstance.set(constuctorType, component);
        this._componentStringToInstance.set(component.type, component);
        if (component.onAdd) {
            component.onAdd(this);
        }
        this._notifyAddComponent(component);
        return this;
    }
    /**
     * Removes a component from the entity, by default removals are deferred to the end of entity update to avoid consistency issues
     *
     * Components can be force removed with the `force` flag, the removal is not deferred and happens immediately
     * @param componentOrType
     * @param force
     */
    removeComponent(componentOrType, force = false) {
        if (force) {
            if (typeof componentOrType === 'string') {
                this._removeComponentByType(componentOrType);
            }
            else if (componentOrType instanceof Component) {
                this._removeComponentByType(componentOrType.type);
            }
        }
        else {
            this._componentsToRemove.push(componentOrType);
        }
        return this;
    }
    _removeComponentByType(type) {
        if (this.has(type)) {
            const component = this.get(type);
            component.owner = null;
            if (component.onRemove) {
                component.onRemove(this);
            }
            const ctor = component.constructor;
            this._componentTypeToInstance.delete(ctor);
            this._componentStringToInstance.delete(component.type);
            this._notifyRemoveComponent(component);
        }
    }
    /**
     * @hidden
     * @internal
     */
    processComponentRemoval() {
        for (const componentOrType of this._componentsToRemove) {
            const type = typeof componentOrType === 'string' ? componentOrType : componentOrType.type;
            this._removeComponentByType(type);
        }
        this._componentsToRemove.length = 0;
    }
    has(type) {
        if (typeof type === 'string') {
            return this._componentStringToInstance.has(type);
        }
        else {
            return this._componentTypeToInstance.has(type);
        }
    }
    get(type) {
        if (typeof type === 'string') {
            return this._componentStringToInstance.get(type);
        }
        else {
            return this._componentTypeToInstance.get(type);
        }
    }
    /**
     * Gets whether the actor is Initialized
     */
    get isInitialized() {
        return this._isInitialized;
    }
    /**
     * Initializes this entity, meant to be called by the Scene before first update not by users of Excalibur.
     *
     * It is not recommended that internal excalibur methods be overriden, do so at your own risk.
     *
     * @internal
     */
    _initialize(engine) {
        if (!this.isInitialized) {
            this.onInitialize(engine);
            super.emit('initialize', new InitializeEvent(engine, this));
            this._isInitialized = true;
        }
    }
    /**
     * It is not recommended that internal excalibur methods be overriden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event
     * @internal
     */
    _preupdate(engine, delta) {
        this.emit('preupdate', new PreUpdateEvent(engine, delta, this));
        this.onPreUpdate(engine, delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overriden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event
     * @internal
     */
    _postupdate(engine, delta) {
        this.emit('postupdate', new PostUpdateEvent(engine, delta, this));
        this.onPostUpdate(engine, delta);
    }
    /**
     * `onInitialize` is called before the first update of the entity. This method is meant to be
     * overridden.
     *
     * Synonymous with the event handler `.on('initialize', (evt) => {...})`
     */
    onInitialize(_engine) {
        // Override me
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before an entity is updated.
     */
    onPreUpdate(_engine, _delta) {
        // Override me
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after an entity is updated.
     */
    onPostUpdate(_engine, _delta) {
        // Override me
    }
    /**
     *
     * Entity update lifecycle, called internally
     *
     * @internal
     * @param engine
     * @param delta
     */
    update(engine, delta) {
        this._initialize(engine);
        this._preupdate(engine, delta);
        for (const child of this.children) {
            child.update(engine, delta);
        }
        this._postupdate(engine, delta);
    }
}
Entity._ID = 0;

;// CONCATENATED MODULE: ./Drawing/CanvasDrawComponent.ts

/**
 * Shim to draw to the canvas when in LegacyDrawing mode
 * @deprecated
 */
class CanvasDrawComponent extends Component {
    constructor(draw) {
        var _a;
        super();
        this.draw = draw;
        this.type = 'ex.canvas';
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        this.draw = (_a = this.draw) !== null && _a !== void 0 ? _a : (() => { });
    }
}

;// CONCATENATED MODULE: ./Graphics/GraphicsComponent.ts





/**
 * Type guard for checking if a Graphic HasTick (used for graphics that change over time like animations)
 * @param graphic
 */
function hasGraphicsTick(graphic) {
    return !!graphic.tick;
}
class GraphicsLayer {
    constructor(_options, _graphics) {
        this._options = _options;
        this._graphics = _graphics;
        this.graphics = [];
    }
    get name() {
        return this._options.name;
    }
    hide(nameOrGraphic) {
        if (!nameOrGraphic) {
            this.graphics.length = 0;
        }
        else {
            let gfx = null;
            if (nameOrGraphic instanceof Graphic) {
                gfx = nameOrGraphic;
            }
            else {
                gfx = this._graphics.getGraphic(nameOrGraphic);
            }
            this.graphics = this.graphics.filter((g) => g.graphic !== gfx);
        }
    }
    /**
     * Show a graphic by name or instance at an offset, graphics are shown in the order in which `show()` is called.
     *
     * If `show()` is called multiple times for the same graphic it will be shown multiple times.
     * @param nameOrGraphic
     * @param options
     */
    show(nameOrGraphic, options) {
        options = Object.assign({}, options);
        let gfx;
        if (nameOrGraphic instanceof Graphic) {
            gfx = this._graphics.copyGraphics ? nameOrGraphic.clone() : nameOrGraphic;
        }
        else {
            gfx = this._graphics.getGraphic(nameOrGraphic);
            if (!gfx) {
                Logger.getInstance().error(`No such graphic added to component named ${nameOrGraphic}. These named graphics are available: `, this._graphics.getNames());
            }
        }
        if (gfx) {
            this.graphics.push({ graphic: gfx, options });
            return gfx;
        }
        else {
            return null;
        }
    }
    /**
     * Use a specific graphic, swap out any current graphics being shown
     * @param nameOrGraphic
     * @param options
     */
    use(nameOrGraphic, options) {
        options = Object.assign({}, options);
        this.hide();
        return this.show(nameOrGraphic, options);
    }
    /**
     * Current order of the layer, higher numbers are on top, lower numbers are on the bottom.
     *
     * For example a layer with `order = -1` would be under a layer of `order = 1`
     */
    get order() {
        return this._options.order;
    }
    /**
     * Set the order of the layer, higher numbers are on top, lower numbers are on the bottom.
     *
     * For example a layer with `order = -1` would be under a layer of `order = 1`
     */
    set order(order) {
        this._options.order = order;
    }
    /**
     * Get or set the pixel offset from the layer anchor for all graphics in the layer
     */
    get offset() {
        var _a;
        return (_a = this._options.offset) !== null && _a !== void 0 ? _a : Vector.Zero;
    }
    set offset(value) {
        this._options.offset = value;
    }
    get currentKeys() {
        var _a;
        return (_a = this.name) !== null && _a !== void 0 ? _a : 'anonymous';
    }
}
class GraphicsLayers {
    constructor(_component) {
        this._component = _component;
        this._layers = [];
        this._layerMap = {};
        this.default = new GraphicsLayer({ name: 'default', order: 0 }, _component);
        this._maybeAddLayer(this.default);
    }
    create(options) {
        const layer = new GraphicsLayer(options, this._component);
        return this._maybeAddLayer(layer);
    }
    get(name) {
        if (name) {
            return this._getLayer(name);
        }
        return this._layers;
    }
    currentKeys() {
        const graphicsLayerKeys = [];
        for (const layer of this._layers) {
            graphicsLayerKeys.push(layer.currentKeys);
        }
        return graphicsLayerKeys;
    }
    has(name) {
        return name in this._layerMap;
    }
    _maybeAddLayer(layer) {
        if (this._layerMap[layer.name]) {
            // todo log warning
            return this._layerMap[layer.name];
        }
        this._layerMap[layer.name] = layer;
        this._layers.push(layer);
        this._layers.sort((a, b) => a.order - b.order);
        return layer;
    }
    _getLayer(name) {
        return this._layerMap[name];
    }
}
/**
 * Component to manage drawings, using with the position component
 */
class GraphicsComponent extends Component {
    constructor(options) {
        super();
        this.type = 'ex.graphics';
        this._graphics = {};
        /**
         * Sets or gets wether any drawing should be visible in this component
         */
        this.visible = true;
        /**
         * Sets or gets wither all drawings should have an opacity applied
         */
        this.opacity = 1;
        /**
         * Offset to apply to graphics by default
         */
        this.offset = Vector.Zero;
        /**
         * Anchor to apply to graphics by default
         */
        this.anchor = Vector.Half;
        /**
         * If set to true graphics added to the component will be copied. This can affect performance
         */
        this.copyGraphics = false;
        this._bounds = null;
        // Defaults
        options = Object.assign({ visible: this.visible }, options);
        const { current, anchor, opacity, visible, graphics, offset, copyGraphics, onPreDraw, onPostDraw } = options;
        this._graphics = graphics || {};
        this.offset = offset !== null && offset !== void 0 ? offset : this.offset;
        this.opacity = opacity !== null && opacity !== void 0 ? opacity : this.opacity;
        this.anchor = anchor !== null && anchor !== void 0 ? anchor : this.anchor;
        this.copyGraphics = copyGraphics !== null && copyGraphics !== void 0 ? copyGraphics : this.copyGraphics;
        this.onPreDraw = onPreDraw !== null && onPreDraw !== void 0 ? onPreDraw : this.onPreDraw;
        this.onPostDraw = onPostDraw !== null && onPostDraw !== void 0 ? onPostDraw : this.onPostDraw;
        this.visible = !!visible;
        this.layers = new GraphicsLayers(this);
        if (current && this._graphics[current]) {
            this.show(this._graphics[current]);
        }
    }
    getGraphic(name) {
        return this._graphics[name];
    }
    /**
     * Get registered graphics names
     */
    getNames() {
        return Object.keys(this._graphics);
    }
    /**
     * Returns the currently displayed graphics and their offsets, empty array if hidden
     */
    get current() {
        return this.layers.default.graphics;
    }
    /**
     * Returns all graphics associated with this component
     */
    get graphics() {
        return this._graphics;
    }
    add(nameOrGraphic, graphic) {
        let name = 'default';
        let graphicToSet = null;
        if (typeof nameOrGraphic === 'string') {
            name = nameOrGraphic;
            graphicToSet = graphic;
        }
        else {
            graphicToSet = nameOrGraphic;
        }
        this._graphics[name] = this.copyGraphics ? graphicToSet.clone() : graphicToSet;
        if (name === 'default') {
            this.show('default');
        }
        return graphicToSet;
    }
    /**
     * Show a graphic by name on the **default** layer, returns the new [[Graphic]]
     */
    show(nameOrGraphic, options) {
        return this.layers.default.show(nameOrGraphic, options);
    }
    /**
     * Use a graphic only, swap out any graphics on the **default** layer, returns the new [[Graphic]]
     * @param nameOrGraphic
     * @param options
     */
    use(nameOrGraphic, options) {
        return this.layers.default.use(nameOrGraphic, options);
    }
    hide(nameOrGraphic) {
        this.layers.default.hide(nameOrGraphic);
    }
    set localBounds(bounds) {
        this._bounds = bounds;
    }
    get localBounds() {
        if (this._bounds) {
            return this._bounds;
        }
        let bb = new BoundingBox();
        for (const layer of this.layers.get()) {
            for (const { graphic, options } of layer.graphics) {
                let anchor = this.anchor;
                let offset = this.offset;
                if (options === null || options === void 0 ? void 0 : options.anchor) {
                    anchor = options.anchor;
                }
                if (options === null || options === void 0 ? void 0 : options.offset) {
                    offset = options.offset;
                }
                const bounds = graphic.localBounds;
                const offsetX = -bounds.width * graphic.scale.x * anchor.x + offset.x;
                const offsetY = -bounds.height * graphic.scale.y * anchor.y + offset.y;
                bb = graphic === null || graphic === void 0 ? void 0 : graphic.localBounds.translate(vec(offsetX + layer.offset.x, offsetY + layer.offset.y)).combine(bb);
            }
        }
        return bb;
    }
    /**
     * Update underlying graphics if necesary, called internally
     * @param elapsed
     * @internal
     */
    update(elapsed, idempotencyToken = 0) {
        for (const layer of this.layers.get()) {
            for (const { graphic } of layer.graphics) {
                if (hasGraphicsTick(graphic)) {
                    graphic === null || graphic === void 0 ? void 0 : graphic.tick(elapsed, idempotencyToken);
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/Rectangle.ts

/**
 * A Rectangle [[Graphic]] for drawing rectangles to the [[ExcaliburGraphicsContext]]
 */
class Rectangle extends Raster {
    constructor(options) {
        super(options);
        this.width = options.width;
        this.height = options.height;
        this.rasterize();
    }
    clone() {
        return new Rectangle(Object.assign(Object.assign({ width: this.width, height: this.height }, this.cloneGraphicOptions()), this.cloneRasterOptions()));
    }
    execute(ctx) {
        if (this.color) {
            ctx.fillRect(0, 0, this.width, this.height);
        }
        if (this.strokeColor) {
            ctx.strokeRect(0, 0, this.width, this.height);
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/Circle.ts

/**
 * A circle [[Graphic]] for drawing circles to the [[ExcaliburGraphicsContext]]
 */
class Circle extends Raster {
    constructor(options) {
        var _a;
        super(options);
        this._radius = 0;
        this.padding = (_a = options.padding) !== null && _a !== void 0 ? _a : 2; // default 2 padding for circles looks nice
        this.radius = options.radius;
        this.rasterize();
    }
    get radius() {
        return this._radius;
    }
    set radius(value) {
        this._radius = value;
        this.width = this._radius * 2;
        this.height = this._radius * 2;
        this.flagDirty();
    }
    clone() {
        return new Circle(Object.assign(Object.assign({ radius: this.radius }, this.cloneGraphicOptions()), this.cloneRasterOptions()));
    }
    execute(ctx) {
        if (this.radius > 0) {
            ctx.beginPath();
            ctx.arc(this.radius, this.radius, this.radius, 0, Math.PI * 2);
            if (this.color) {
                ctx.fill();
            }
            if (this.strokeColor) {
                ctx.stroke();
            }
        }
    }
}

;// CONCATENATED MODULE: ./Util/EasingFunctions.ts
var EasingFunctions_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


/**
 * Standard easing functions for motion in Excalibur, defined on a domain of [0, duration] and a range from [+startValue,+endValue]
 * Given a time, the function will return a value from positive startValue to positive endValue.
 *
 * ```js
 * function Linear (t) {
 *    return t * t;
 * }
 *
 * // accelerating from zero velocity
 * function EaseInQuad (t) {
 *    return t * t;
 * }
 *
 * // decelerating to zero velocity
 * function EaseOutQuad (t) {
 *    return t * (2 - t);
 * }
 *
 * // acceleration until halfway, then deceleration
 * function EaseInOutQuad (t) {
 *    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
 * }
 *
 * // accelerating from zero velocity
 * function EaseInCubic (t) {
 *    return t * t * t;
 * }
 *
 * // decelerating to zero velocity
 * function EaseOutCubic (t) {
 *    return (--t) * t * t + 1;
 * }
 *
 * // acceleration until halfway, then deceleration
 * function EaseInOutCubic (t) {
 *    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
 * }
 * ```
 */
class EasingFunctions {
    static CreateReversibleEasingFunction(easing) {
        return (time, start, end, duration) => {
            if (end < start) {
                return start - (easing(time, end, start, duration) - end);
            }
            else {
                return easing(time, start, end, duration);
            }
        };
    }
    static CreateReversableEasingFunction(easing) {
        return EasingFunctions.CreateReversibleEasingFunction(easing);
    }
    static CreateVectorEasingFunction(easing) {
        return (time, start, end, duration) => {
            return new Vector(easing(time, start.x, end.x, duration), easing(time, start.y, end.y, duration));
        };
    }
}
EasingFunctions.Linear = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    return (endValue * currentTime) / duration + startValue;
});
EasingFunctions.EaseInQuad = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    return endValue * currentTime * currentTime + startValue;
});
EasingFunctions.EaseOutQuad = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    return -endValue * currentTime * (currentTime - 2) + startValue;
});
EasingFunctions.EaseInOutQuad = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration / 2;
    if (currentTime < 1) {
        return (endValue / 2) * currentTime * currentTime + startValue;
    }
    currentTime--;
    return (-endValue / 2) * (currentTime * (currentTime - 2) - 1) + startValue;
});
EasingFunctions.EaseInCubic = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    return endValue * currentTime * currentTime * currentTime + startValue;
});
EasingFunctions.EaseOutCubic = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    currentTime--;
    return endValue * (currentTime * currentTime * currentTime + 1) + startValue;
});
EasingFunctions.EaseInOutCubic = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration / 2;
    if (currentTime < 1) {
        return (endValue / 2) * currentTime * currentTime * currentTime + startValue;
    }
    currentTime -= 2;
    return (endValue / 2) * (currentTime * currentTime * currentTime + 2) + startValue;
});
EasingFunctions_decorate([
    obsolete({
        message: 'Alias for incorrect spelling used in older versions, will be removed in v0.25.0',
        alternateMethod: 'CreateReversibleEasingFunction'
    })
], EasingFunctions, "CreateReversableEasingFunction", null);

;// CONCATENATED MODULE: ./Actions/ActionQueue.ts
/**
 * Action Queues represent an ordered sequence of actions
 *
 * Action queues are part of the [[ActionContext|Action API]] and
 * store the list of actions to be executed for an [[Actor]].
 *
 * Actors implement [[Actor.actions]] which can be manipulated by
 * advanced users to adjust the actions currently being executed in the
 * queue.
 */
class ActionQueue {
    constructor(entity) {
        this._actions = [];
        this._completedActions = [];
        this._entity = entity;
    }
    /**
     * Add an action to the sequence
     * @param action
     */
    add(action) {
        this._actions.push(action);
    }
    /**
     * Remove an action by reference from the sequence
     * @param action
     */
    remove(action) {
        const index = this._actions.indexOf(action);
        this._actions.splice(index, 1);
    }
    /**
     * Removes all actions from this sequence
     */
    clearActions() {
        this._actions.length = 0;
        this._completedActions.length = 0;
        if (this._currentAction) {
            this._currentAction.stop();
        }
    }
    /**
     *
     * @returns The total list of actions in this sequence complete or not
     */
    getActions() {
        return this._actions.concat(this._completedActions);
    }
    /**
     *
     * @returns `true` if there are more actions to process in the sequence
     */
    hasNext() {
        return this._actions.length > 0;
    }
    /**
     * @returns `true` if the current sequence of actions is done
     */
    isComplete() {
        return this._actions.length === 0;
    }
    /**
     * Resets the sequence of actions, this is used to restart a sequence from the beginning
     */
    reset() {
        this._actions = this.getActions();
        const len = this._actions.length;
        for (let i = 0; i < len; i++) {
            this._actions[i].reset();
        }
        this._completedActions = [];
    }
    /**
     * Update the queue which updates actions and handles completing actions
     * @param elapsedMs
     */
    update(elapsedMs) {
        if (this._actions.length > 0) {
            this._currentAction = this._actions[0];
            this._currentAction.update(elapsedMs);
            if (this._currentAction.isComplete(this._entity)) {
                this._completedActions.push(this._actions.shift());
            }
        }
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Repeat.ts

class Repeat {
    constructor(entity, repeatBuilder, repeat) {
        this._stopped = false;
        this._repeatBuilder = repeatBuilder;
        this._repeatContext = new ActionContext(entity);
        this._actionQueue = this._repeatContext.getQueue();
        this._repeat = repeat;
        this._originalRepeat = repeat;
        this._repeatBuilder(this._repeatContext);
        this._repeat--; // current execution is the first repeat
    }
    update(delta) {
        if (this._actionQueue.isComplete()) {
            this._actionQueue.clearActions();
            this._repeatBuilder(this._repeatContext);
            this._repeat--;
        }
        this._actionQueue.update(delta);
    }
    isComplete() {
        return this._stopped || (this._repeat <= 0 && this._actionQueue.isComplete());
    }
    stop() {
        this._stopped = true;
    }
    reset() {
        this._repeat = this._originalRepeat;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/RepeatForever.ts

/**
 * RepeatForever Action implementation, it is recommended you use the fluent action
 * context API.
 *
 *
 */
class RepeatForever {
    constructor(entity, repeatBuilder) {
        this._stopped = false;
        this._repeatBuilder = repeatBuilder;
        this._repeatContext = new ActionContext(entity);
        this._actionQueue = this._repeatContext.getQueue();
        this._repeatBuilder(this._repeatContext);
    }
    update(delta) {
        if (this._stopped) {
            return;
        }
        if (this._actionQueue.isComplete()) {
            this._actionQueue.clearActions();
            this._repeatBuilder(this._repeatContext);
        }
        this._actionQueue.update(delta);
    }
    isComplete() {
        return this._stopped;
    }
    stop() {
        this._stopped = true;
        this._actionQueue.clearActions();
    }
    reset() {
        return;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/MoveBy.ts




class MoveBy {
    constructor(entity, offsetX, offsetY, speed) {
        this._started = false;
        this._stopped = false;
        this._entity = entity;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._speed = speed;
        this._offset = new Vector(offsetX, offsetY);
        if (speed <= 0) {
            Logger.getInstance().error('Attempted to moveBy with speed less than or equal to zero : ' + speed);
            throw new Error('Speed must be greater than 0 pixels per second');
        }
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._start = new Vector(this._tx.pos.x, this._tx.pos.y);
            this._end = this._start.add(this._offset);
            this._distance = this._offset.size;
            this._dir = this._end.sub(this._start).normalize();
        }
        if (this.isComplete(this._entity)) {
            this._tx.pos = vec(this._end.x, this._end.y);
            this._motion.vel = vec(0, 0);
        }
        else {
            this._motion.vel = this._dir.scale(this._speed);
        }
    }
    isComplete(entity) {
        const tx = entity.get(TransformComponent);
        return this._stopped || tx.pos.distance(this._start) >= this._distance;
    }
    stop() {
        this._motion.vel = vec(0, 0);
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/MoveTo.ts



class MoveTo {
    constructor(entity, destx, desty, speed) {
        this.entity = entity;
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._end = new Vector(destx, desty);
        this._speed = speed;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._start = new Vector(this._tx.pos.x, this._tx.pos.y);
            this._distance = this._start.distance(this._end);
            this._dir = this._end.sub(this._start).normalize();
        }
        const m = this._dir.scale(this._speed);
        this._motion.vel = vec(m.x, m.y);
        if (this.isComplete(this.entity)) {
            this._tx.pos = vec(this._end.x, this._end.y);
            this._motion.vel = vec(0, 0);
        }
    }
    isComplete(entity) {
        const tx = entity.get(TransformComponent);
        return this._stopped || new Vector(tx.pos.x, tx.pos.y).distance(this._start) >= this._distance;
    }
    stop() {
        this._motion.vel = vec(0, 0);
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
}

;// CONCATENATED MODULE: ./Actions/RotationType.ts
/**
 * An enum that describes the strategies that rotation actions can use
 */
var RotationType;
(function (RotationType) {
    /**
     * Rotation via `ShortestPath` will use the smallest angle
     * between the starting and ending points. This strategy is the default behavior.
     */
    RotationType[RotationType["ShortestPath"] = 0] = "ShortestPath";
    /**
     * Rotation via `LongestPath` will use the largest angle
     * between the starting and ending points.
     */
    RotationType[RotationType["LongestPath"] = 1] = "LongestPath";
    /**
     * Rotation via `Clockwise` will travel in a clockwise direction,
     * regardless of the starting and ending points.
     */
    RotationType[RotationType["Clockwise"] = 2] = "Clockwise";
    /**
     * Rotation via `CounterClockwise` will travel in a counterclockwise direction,
     * regardless of the starting and ending points.
     */
    RotationType[RotationType["CounterClockwise"] = 3] = "CounterClockwise";
})(RotationType || (RotationType = {}));

;// CONCATENATED MODULE: ./Actions/Action/RotateTo.ts




class RotateTo {
    constructor(entity, angleRadians, speed, rotationType) {
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._end = angleRadians;
        this._speed = speed;
        this._rotationType = rotationType || RotationType.ShortestPath;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._start = this._tx.rotation;
            this._currentNonCannonAngle = this._tx.rotation;
            const distance1 = Math.abs(this._end - this._start);
            const distance2 = TwoPI - distance1;
            if (distance1 > distance2) {
                this._shortDistance = distance2;
                this._longDistance = distance1;
            }
            else {
                this._shortDistance = distance1;
                this._longDistance = distance2;
            }
            this._shortestPathIsPositive = (this._start - this._end + TwoPI) % TwoPI >= Math.PI;
            switch (this._rotationType) {
                case RotationType.ShortestPath:
                    this._distance = this._shortDistance;
                    if (this._shortestPathIsPositive) {
                        this._direction = 1;
                    }
                    else {
                        this._direction = -1;
                    }
                    break;
                case RotationType.LongestPath:
                    this._distance = this._longDistance;
                    if (this._shortestPathIsPositive) {
                        this._direction = -1;
                    }
                    else {
                        this._direction = 1;
                    }
                    break;
                case RotationType.Clockwise:
                    this._direction = 1;
                    if (this._shortestPathIsPositive) {
                        this._distance = this._shortDistance;
                    }
                    else {
                        this._distance = this._longDistance;
                    }
                    break;
                case RotationType.CounterClockwise:
                    this._direction = -1;
                    if (!this._shortestPathIsPositive) {
                        this._distance = this._shortDistance;
                    }
                    else {
                        this._distance = this._longDistance;
                    }
                    break;
            }
        }
        this._motion.angularVelocity = this._direction * this._speed;
        this._currentNonCannonAngle += this._direction * this._speed * (_delta / 1000);
        if (this.isComplete()) {
            this._tx.rotation = this._end;
            this._motion.angularVelocity = 0;
            this._stopped = true;
        }
    }
    isComplete() {
        const distanceTravelled = Math.abs(this._currentNonCannonAngle - this._start);
        return this._stopped || distanceTravelled >= Math.abs(this._distance);
    }
    stop() {
        this._motion.angularVelocity = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/RotateBy.ts




class RotateBy {
    constructor(entity, angleRadiansOffset, speed, rotationType) {
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._speed = speed;
        this._offset = angleRadiansOffset;
        this._rotationType = rotationType || RotationType.ShortestPath;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._start = this._tx.rotation;
            this._currentNonCannonAngle = this._tx.rotation;
            this._end = this._start + this._offset;
            const distance1 = Math.abs(this._end - this._start);
            const distance2 = TwoPI - distance1;
            if (distance1 > distance2) {
                this._shortDistance = distance2;
                this._longDistance = distance1;
            }
            else {
                this._shortDistance = distance1;
                this._longDistance = distance2;
            }
            this._shortestPathIsPositive = (this._start - this._end + TwoPI) % TwoPI >= Math.PI;
            switch (this._rotationType) {
                case RotationType.ShortestPath:
                    this._distance = this._shortDistance;
                    if (this._shortestPathIsPositive) {
                        this._direction = 1;
                    }
                    else {
                        this._direction = -1;
                    }
                    break;
                case RotationType.LongestPath:
                    this._distance = this._longDistance;
                    if (this._shortestPathIsPositive) {
                        this._direction = -1;
                    }
                    else {
                        this._direction = 1;
                    }
                    break;
                case RotationType.Clockwise:
                    this._direction = 1;
                    if (this._shortDistance >= 0) {
                        this._distance = this._shortDistance;
                    }
                    else {
                        this._distance = this._longDistance;
                    }
                    break;
                case RotationType.CounterClockwise:
                    this._direction = -1;
                    if (this._shortDistance <= 0) {
                        this._distance = this._shortDistance;
                    }
                    else {
                        this._distance = this._longDistance;
                    }
                    break;
            }
        }
        this._motion.angularVelocity = this._direction * this._speed;
        this._currentNonCannonAngle += this._direction * this._speed * (_delta / 1000);
        if (this.isComplete()) {
            this._tx.rotation = this._end;
            this._motion.angularVelocity = 0;
            this._stopped = true;
        }
    }
    isComplete() {
        const distanceTravelled = Math.abs(this._currentNonCannonAngle - this._start);
        return this._stopped || distanceTravelled >= Math.abs(this._distance);
    }
    stop() {
        this._motion.angularVelocity = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/ScaleTo.ts



class ScaleTo {
    constructor(entity, scaleX, scaleY, speedX, speedY) {
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._endX = scaleX;
        this._endY = scaleY;
        this._speedX = speedX;
        this._speedY = speedY;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._startX = this._tx.scale.x;
            this._startY = this._tx.scale.y;
            this._distanceX = Math.abs(this._endX - this._startX);
            this._distanceY = Math.abs(this._endY - this._startY);
        }
        if (!(Math.abs(this._tx.scale.x - this._startX) >= this._distanceX)) {
            const directionX = this._endY < this._startY ? -1 : 1;
            this._motion.scaleFactor.x = this._speedX * directionX;
        }
        else {
            this._motion.scaleFactor.x = 0;
        }
        if (!(Math.abs(this._tx.scale.y - this._startY) >= this._distanceY)) {
            const directionY = this._endY < this._startY ? -1 : 1;
            this._motion.scaleFactor.y = this._speedY * directionY;
        }
        else {
            this._motion.scaleFactor.y = 0;
        }
        if (this.isComplete()) {
            this._tx.scale = vec(this._endX, this._endY);
            this._motion.scaleFactor.x = 0;
            this._motion.scaleFactor.y = 0;
        }
    }
    isComplete() {
        return (this._stopped ||
            (Math.abs(this._tx.scale.y - this._startX) >= this._distanceX && Math.abs(this._tx.scale.y - this._startY) >= this._distanceY));
    }
    stop() {
        this._motion.scaleFactor.x = 0;
        this._motion.scaleFactor.y = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/ScaleBy.ts



class ScaleBy {
    constructor(entity, scaleOffsetX, scaleOffsetY, speed) {
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._offset = new Vector(scaleOffsetX, scaleOffsetY);
        this._speedX = this._speedY = speed;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._startScale = this._tx.scale.clone();
            this._endScale = this._startScale.add(this._offset);
            this._distanceX = Math.abs(this._endScale.x - this._startScale.x);
            this._distanceY = Math.abs(this._endScale.y - this._startScale.y);
            this._directionX = this._endScale.x < this._startScale.x ? -1 : 1;
            this._directionY = this._endScale.y < this._startScale.y ? -1 : 1;
        }
        this._motion.scaleFactor.x = this._speedX * this._directionX;
        this._motion.scaleFactor.y = this._speedY * this._directionY;
        if (this.isComplete()) {
            this._tx.scale = this._endScale;
            this._motion.scaleFactor.x = 0;
            this._motion.scaleFactor.y = 0;
        }
    }
    isComplete() {
        return (this._stopped ||
            (Math.abs(this._tx.scale.x - this._startScale.x) >= this._distanceX &&
                Math.abs(this._tx.scale.y - this._startScale.y) >= this._distanceY));
    }
    stop() {
        this._motion.scaleFactor.x = 0;
        this._motion.scaleFactor.y = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/CallMethod.ts
class CallMethod {
    constructor(method) {
        this._method = null;
        this._hasBeenCalled = false;
        this._method = method;
    }
    update(_delta) {
        this._method();
        this._hasBeenCalled = true;
    }
    isComplete() {
        return this._hasBeenCalled;
    }
    reset() {
        this._hasBeenCalled = false;
    }
    stop() {
        this._hasBeenCalled = true;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/EaseTo.ts



class EaseTo {
    constructor(entity, x, y, duration, easingFcn) {
        this.easingFcn = easingFcn;
        this._currentLerpTime = 0;
        this._lerpDuration = 1 * 1000; // 1 second
        this._lerpStart = new Vector(0, 0);
        this._lerpEnd = new Vector(0, 0);
        this._initialized = false;
        this._stopped = false;
        this._distance = 0;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._lerpDuration = duration;
        this._lerpEnd = new Vector(x, y);
    }
    _initialize() {
        this._lerpStart = new Vector(this._tx.pos.x, this._tx.pos.y);
        this._currentLerpTime = 0;
        this._distance = this._lerpStart.distance(this._lerpEnd);
    }
    update(delta) {
        if (!this._initialized) {
            this._initialize();
            this._initialized = true;
        }
        // Need to update lerp time first, otherwise the first update will always be zero
        this._currentLerpTime += delta;
        let newX = this._tx.pos.x;
        let newY = this._tx.pos.y;
        if (this._currentLerpTime < this._lerpDuration) {
            if (this._lerpEnd.x < this._lerpStart.x) {
                newX =
                    this._lerpStart.x -
                        (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);
            }
            else {
                newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);
            }
            if (this._lerpEnd.y < this._lerpStart.y) {
                newY =
                    this._lerpStart.y -
                        (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);
            }
            else {
                newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
            }
            // Given the lerp position figure out the velocity in pixels per second
            this._motion.vel = vec((newX - this._tx.pos.x) / (delta / 1000), (newY - this._tx.pos.y) / (delta / 1000));
        }
        else {
            this._tx.pos = vec(this._lerpEnd.x, this._lerpEnd.y);
            this._motion.vel = Vector.Zero;
        }
    }
    isComplete(actor) {
        return this._stopped || new Vector(actor.pos.x, actor.pos.y).distance(this._lerpStart) >= this._distance;
    }
    reset() {
        this._initialized = false;
    }
    stop() {
        this._motion.vel = vec(0, 0);
        this._stopped = true;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Blink.ts

class Blink {
    constructor(entity, timeVisible, timeNotVisible, numBlinks = 1) {
        this._timeVisible = 0;
        this._timeNotVisible = 0;
        this._elapsedTime = 0;
        this._totalTime = 0;
        this._stopped = false;
        this._started = false;
        this._graphics = entity.get(GraphicsComponent);
        this._timeVisible = timeVisible;
        this._timeNotVisible = timeNotVisible;
        this._duration = (timeVisible + timeNotVisible) * numBlinks;
    }
    update(delta) {
        if (!this._started) {
            this._started = true;
        }
        if (!this._graphics) {
            return;
        }
        this._elapsedTime += delta;
        this._totalTime += delta;
        if (this._graphics.visible && this._elapsedTime >= this._timeVisible) {
            this._graphics.visible = false;
            this._elapsedTime = 0;
        }
        if (!this._graphics.visible && this._elapsedTime >= this._timeNotVisible) {
            this._graphics.visible = true;
            this._elapsedTime = 0;
        }
        if (this.isComplete()) {
            this._graphics.visible = true;
        }
    }
    isComplete() {
        return this._stopped || this._totalTime >= this._duration;
    }
    stop() {
        if (this._graphics) {
            this._graphics.visible = true;
        }
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._elapsedTime = 0;
        this._totalTime = 0;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Fade.ts


class Fade {
    constructor(entity, endOpacity, speed) {
        this._multiplier = 1;
        this._started = false;
        this._stopped = false;
        this._graphics = entity.get(GraphicsComponent);
        this._endOpacity = endOpacity;
        this._speed = speed;
    }
    update(delta) {
        if (!this._graphics) {
            return;
        }
        if (!this._started) {
            this._started = true;
            // determine direction when we start
            if (this._endOpacity < this._graphics.opacity) {
                this._multiplier = -1;
            }
            else {
                this._multiplier = 1;
            }
        }
        if (this._speed > 0) {
            this._graphics.opacity += (this._multiplier *
                (Math.abs(this._graphics.opacity - this._endOpacity) * delta)) / this._speed;
        }
        this._speed -= delta;
        if (this.isComplete()) {
            this._graphics.opacity = this._endOpacity;
        }
        Logger.getInstance().debug('[Action fade] Actor opacity:', this._graphics.opacity);
    }
    isComplete() {
        return this._stopped || Math.abs(this._graphics.opacity - this._endOpacity) < 0.05;
    }
    stop() {
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Delay.ts
class Delay {
    constructor(delay) {
        this._elapsedTime = 0;
        this._started = false;
        this._stopped = false;
        this._delay = delay;
    }
    update(delta) {
        if (!this._started) {
            this._started = true;
        }
        this._elapsedTime += delta;
    }
    isComplete() {
        return this._stopped || this._elapsedTime >= this._delay;
    }
    stop() {
        this._stopped = true;
    }
    reset() {
        this._elapsedTime = 0;
        this._started = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Die.ts

class Die {
    constructor(entity) {
        this._stopped = false;
        this._entity = entity;
    }
    update(_delta) {
        this._entity.get(ActionsComponent).clearActions();
        this._entity.kill();
        this._stopped = true;
    }
    isComplete() {
        return this._stopped;
    }
    stop() {
        return;
    }
    reset() {
        return;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Follow.ts



class Follow {
    constructor(entity, entityToFollow, followDistance) {
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._followTx = entityToFollow.get(TransformComponent);
        this._followMotion = entityToFollow.get(MotionComponent);
        this._current = new Vector(this._tx.pos.x, this._tx.pos.y);
        this._end = new Vector(this._followTx.pos.x, this._followTx.pos.y);
        this._maximumDistance = followDistance !== undefined ? followDistance : this._current.distance(this._end);
        this._speed = 0;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._distanceBetween = this._current.distance(this._end);
            this._dir = this._end.sub(this._current).normalize();
        }
        const actorToFollowSpeed = Math.sqrt(Math.pow(this._followMotion.vel.x, 2) + Math.pow(this._followMotion.vel.y, 2));
        if (actorToFollowSpeed !== 0) {
            this._speed = actorToFollowSpeed;
        }
        this._current = vec(this._tx.pos.x, this._tx.pos.y);
        this._end = vec(this._followTx.pos.x, this._followTx.pos.y);
        this._distanceBetween = this._current.distance(this._end);
        this._dir = this._end.sub(this._current).normalize();
        if (this._distanceBetween >= this._maximumDistance) {
            const m = this._dir.scale(this._speed);
            this._motion.vel = vec(m.x, m.y);
        }
        else {
            this._motion.vel = vec(0, 0);
        }
        if (this.isComplete()) {
            this._tx.pos = vec(this._end.x, this._end.y);
            this._motion.vel = vec(0, 0);
        }
    }
    stop() {
        this._motion.vel = vec(0, 0);
        this._stopped = true;
    }
    isComplete() {
        // the actor following should never stop unless specified to do so
        return this._stopped;
    }
    reset() {
        this._started = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Meet.ts



class Meet {
    constructor(actor, actorToMeet, speed) {
        this._started = false;
        this._stopped = false;
        this._speedWasSpecified = false;
        this._tx = actor.get(TransformComponent);
        this._motion = actor.get(MotionComponent);
        this._meetTx = actorToMeet.get(TransformComponent);
        this._meetMotion = actorToMeet.get(MotionComponent);
        this._current = new Vector(this._tx.pos.x, this._tx.pos.y);
        this._end = new Vector(this._meetTx.pos.x, this._meetTx.pos.y);
        this._speed = speed || 0;
        if (speed !== undefined) {
            this._speedWasSpecified = true;
        }
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._distanceBetween = this._current.distance(this._end);
            this._dir = this._end.sub(this._current).normalize();
        }
        const actorToMeetSpeed = Math.sqrt(Math.pow(this._meetMotion.vel.x, 2) + Math.pow(this._meetMotion.vel.y, 2));
        if (actorToMeetSpeed !== 0 && !this._speedWasSpecified) {
            this._speed = actorToMeetSpeed;
        }
        this._current = vec(this._tx.pos.x, this._tx.pos.y);
        this._end = vec(this._meetTx.pos.x, this._meetTx.pos.y);
        this._distanceBetween = this._current.distance(this._end);
        this._dir = this._end.sub(this._current).normalize();
        const m = this._dir.scale(this._speed);
        this._motion.vel = vec(m.x, m.y);
        if (this.isComplete()) {
            this._tx.pos = vec(this._end.x, this._end.y);
            this._motion.vel = vec(0, 0);
        }
    }
    isComplete() {
        return this._stopped || this._distanceBetween <= 1;
    }
    stop() {
        this._motion.vel = vec(0, 0);
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
}

;// CONCATENATED MODULE: ./Actions/ActionContext.ts



















/**
 * The fluent Action API allows you to perform "actions" on
 * [[Actor|Actors]] such as following, moving, rotating, and
 * more. You can implement your own actions by implementing
 * the [[Action]] interface.
 */
class ActionContext {
    constructor(entity) {
        this._entity = entity;
        this._queue = new ActionQueue(entity);
    }
    getQueue() {
        return this._queue;
    }
    update(elapsedMs) {
        this._queue.update(elapsedMs);
    }
    /**
     * Clears all queued actions from the Actor
     */
    clearActions() {
        this._queue.clearActions();
    }
    easeTo(...args) {
        var _a, _b;
        let x = 0;
        let y = 0;
        let duration = 0;
        let easingFcn = EasingFunctions.Linear;
        if (args[0] instanceof Vector) {
            x = args[0].x;
            y = args[0].y;
            duration = args[1];
            easingFcn = (_a = args[2]) !== null && _a !== void 0 ? _a : easingFcn;
        }
        else {
            x = args[0];
            y = args[1];
            duration = args[2];
            easingFcn = (_b = args[3]) !== null && _b !== void 0 ? _b : easingFcn;
        }
        this._queue.add(new EaseTo(this._entity, x, y, duration, easingFcn));
        return this;
    }
    moveTo(xOrPos, yOrSpeed, speedOrUndefined) {
        let x = 0;
        let y = 0;
        let speed = 0;
        if (xOrPos instanceof Vector) {
            x = xOrPos.x;
            y = xOrPos.y;
            speed = yOrSpeed;
        }
        else {
            x = xOrPos;
            y = yOrSpeed;
            speed = speedOrUndefined;
        }
        this._queue.add(new MoveTo(this._entity, x, y, speed));
        return this;
    }
    moveBy(xOffsetOrVector, yOffsetOrSpeed, speedOrUndefined) {
        let xOffset = 0;
        let yOffset = 0;
        let speed = 0;
        if (xOffsetOrVector instanceof Vector) {
            xOffset = xOffsetOrVector.x;
            yOffset = xOffsetOrVector.y;
            speed = yOffsetOrSpeed;
        }
        else {
            xOffset = xOffsetOrVector;
            yOffset = yOffsetOrSpeed;
            speed = speedOrUndefined;
        }
        this._queue.add(new MoveBy(this._entity, xOffset, yOffset, speed));
        return this;
    }
    /**
     * This method will rotate an actor to the specified angle at the speed
     * specified (in radians per second) and return back the actor. This
     * method is part of the actor 'Action' fluent API allowing action chaining.
     * @param angleRadians  The angle to rotate to in radians
     * @param speed         The angular velocity of the rotation specified in radians per second
     * @param rotationType  The [[RotationType]] to use for this rotation
     */
    rotateTo(angleRadians, speed, rotationType) {
        this._queue.add(new RotateTo(this._entity, angleRadians, speed, rotationType));
        return this;
    }
    /**
     * This method will rotate an actor by the specified angle offset, from it's current rotation given a certain speed
     * in radians/sec and return back the actor. This method is part
     * of the actor 'Action' fluent API allowing action chaining.
     * @param angleRadiansOffset  The angle to rotate to in radians relative to the current rotation
     * @param speed          The speed in radians/sec the actor should rotate at
     * @param rotationType  The [[RotationType]] to use for this rotation, default is shortest path
     */
    rotateBy(angleRadiansOffset, speed, rotationType) {
        this._queue.add(new RotateBy(this._entity, angleRadiansOffset, speed, rotationType));
        return this;
    }
    scaleTo(sizeXOrVector, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined) {
        let sizeX = 1;
        let sizeY = 1;
        let speedX = 0;
        let speedY = 0;
        if (sizeXOrVector instanceof Vector && sizeYOrSpeed instanceof Vector) {
            sizeX = sizeXOrVector.x;
            sizeY = sizeXOrVector.y;
            speedX = sizeYOrSpeed.x;
            speedY = sizeYOrSpeed.y;
        }
        if (typeof sizeXOrVector === 'number' && typeof sizeYOrSpeed === 'number') {
            sizeX = sizeXOrVector;
            sizeY = sizeYOrSpeed;
            speedX = speedXOrUndefined;
            speedY = speedYOrUndefined;
        }
        this._queue.add(new ScaleTo(this._entity, sizeX, sizeY, speedX, speedY));
        return this;
    }
    scaleBy(sizeOffsetXOrVector, sizeOffsetYOrSpeed, speed) {
        let sizeOffsetX = 1;
        let sizeOffsetY = 1;
        if (sizeOffsetXOrVector instanceof Vector) {
            sizeOffsetX = sizeOffsetXOrVector.x;
            sizeOffsetY = sizeOffsetXOrVector.y;
            speed = sizeOffsetYOrSpeed;
        }
        if (typeof sizeOffsetXOrVector === 'number' && typeof sizeOffsetYOrSpeed === 'number') {
            sizeOffsetX = sizeOffsetXOrVector;
            sizeOffsetY = sizeOffsetYOrSpeed;
        }
        this._queue.add(new ScaleBy(this._entity, sizeOffsetX, sizeOffsetY, speed));
        return this;
    }
    /**
     * This method will cause an actor to blink (become visible and not
     * visible). Optionally, you may specify the number of blinks. Specify the amount of time
     * the actor should be visible per blink, and the amount of time not visible.
     * This method is part of the actor 'Action' fluent API allowing action chaining.
     * @param timeVisible     The amount of time to stay visible per blink in milliseconds
     * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds
     * @param numBlinks       The number of times to blink
     */
    blink(timeVisible, timeNotVisible, numBlinks = 1) {
        this._queue.add(new Blink(this._entity, timeVisible, timeNotVisible, numBlinks));
        return this;
    }
    /**
     * This method will cause an actor's opacity to change from its current value
     * to the provided value by a specified time (in milliseconds). This method is
     * part of the actor 'Action' fluent API allowing action chaining.
     * @param opacity  The ending opacity
     * @param time     The time it should take to fade the actor (in milliseconds)
     */
    fade(opacity, time) {
        this._queue.add(new Fade(this._entity, opacity, time));
        return this;
    }
    /**
     * This method will delay the next action from executing for a certain
     * amount of time (in milliseconds). This method is part of the actor
     * 'Action' fluent API allowing action chaining.
     * @param time  The amount of time to delay the next action in the queue from executing in milliseconds
     */
    delay(time) {
        this._queue.add(new Delay(time));
        return this;
    }
    /**
     * This method will add an action to the queue that will remove the actor from the
     * scene once it has completed its previous  Any actions on the
     * action queue after this action will not be executed.
     */
    die() {
        this._queue.add(new Die(this._entity));
        return this;
    }
    /**
     * This method allows you to call an arbitrary method as the next action in the
     * action queue. This is useful if you want to execute code in after a specific
     * action, i.e An actor arrives at a destination after traversing a path
     */
    callMethod(method) {
        this._queue.add(new CallMethod(method));
        return this;
    }
    /**
     * This method will cause the actor to repeat all of the actions built in
     * the `repeatBuilder` callback. If the number of repeats
     * is not specified it will repeat forever. This method is part of
     * the actor 'Action' fluent API allowing action chaining
     *
     * ```typescript
     * // Move up in a zig-zag by repeated moveBy's
     * actor.actions.repeat(repeatCtx => {
     *  repeatCtx.moveBy(10, 0, 10);
     *  repeatCtx.moveBy(0, 10, 10);
     * }, 5);
     * ```
     *
     * @param repeatBuilder The builder to specify the repeatable list of actions
     * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions
     * will repeat forever
     */
    repeat(repeatBuilder, times) {
        if (!times) {
            this.repeatForever(repeatBuilder);
            return this;
        }
        this._queue.add(new Repeat(this._entity, repeatBuilder, times));
        return this;
    }
    /**
     * This method will cause the actor to repeat all of the actions built in
     * the `repeatBuilder` callback. If the number of repeats
     * is not specified it will repeat forever. This method is part of
     * the actor 'Action' fluent API allowing action chaining
     *
     * ```typescript
     * // Move up in a zig-zag by repeated moveBy's
     * actor.actions.repeat(repeatCtx => {
     *  repeatCtx.moveBy(10, 0, 10);
     *  repeatCtx.moveBy(0, 10, 10);
     * }, 5);
     * ```
     *
     * @param repeatBuilder The builder to specify the repeatable list of actions
     */
    repeatForever(repeatBuilder) {
        this._queue.add(new RepeatForever(this._entity, repeatBuilder));
        return this;
    }
    /**
     * This method will cause the entity to follow another at a specified distance
     * @param entity           The entity to follow
     * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.
     */
    follow(entity, followDistance) {
        if (followDistance === undefined) {
            this._queue.add(new Follow(this._entity, entity));
        }
        else {
            this._queue.add(new Follow(this._entity, entity, followDistance));
        }
        return this;
    }
    /**
     * This method will cause the entity to move towards another until they
     * collide "meet" at a specified speed.
     * @param entity  The entity to meet
     * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor
     */
    meet(entity, speed) {
        if (speed === undefined) {
            this._queue.add(new Meet(this._entity, entity));
        }
        else {
            this._queue.add(new Meet(this._entity, entity, speed));
        }
        return this;
    }
    /**
     * Returns a promise that resolves when the current action queue up to now
     * is finished.
     * @deprecated Use `toPromise()` will be removed in v0.26.0
     */
    asPromise() {
        return this.toPromise();
    }
    /**
     * Returns a promise that resolves when the current action queue up to now
     * is finished.
     */
    toPromise() {
        const temp = new Promise((resolve) => {
            this._queue.add(new CallMethod(() => {
                resolve();
            }));
        });
        return temp;
    }
}

;// CONCATENATED MODULE: ./Actions/ActionsComponent.ts




;
class ActionsComponent extends Component {
    constructor() {
        super(...arguments);
        this.type = 'ex.actions';
        this.dependencies = [TransformComponent, MotionComponent];
    }
    onAdd(entity) {
        this._ctx = new ActionContext(entity);
    }
    onRemove() {
        this._ctx = null;
    }
    /**
     * Returns the internal action queue
     * @returns action queu
     */
    getQueue() {
        var _a;
        return (_a = this._ctx) === null || _a === void 0 ? void 0 : _a.getQueue();
    }
    /**
     * Updates the internal action context, performing action and moving through the internal queue
     * @param elapsedMs
     */
    update(elapsedMs) {
        var _a;
        return (_a = this._ctx) === null || _a === void 0 ? void 0 : _a.update(elapsedMs);
    }
    /**
     * Clears all queued actions from the Actor
     */
    clearActions() {
        var _a;
        (_a = this._ctx) === null || _a === void 0 ? void 0 : _a.clearActions();
    }
    easeTo(...args) {
        return this._ctx.easeTo.apply(this._ctx, args);
    }
    moveTo(xOrPos, yOrSpeed, speedOrUndefined) {
        return this._ctx.moveTo.apply(this._ctx, [xOrPos, yOrSpeed, speedOrUndefined]);
    }
    moveBy(xOffsetOrVector, yOffsetOrSpeed, speedOrUndefined) {
        return this._ctx.moveBy.apply(this._ctx, [xOffsetOrVector, yOffsetOrSpeed, speedOrUndefined]);
    }
    /**
     * This method will rotate an actor to the specified angle at the speed
     * specified (in radians per second) and return back the actor. This
     * method is part of the actor 'Action' fluent API allowing action chaining.
     * @param angleRadians  The angle to rotate to in radians
     * @param speed         The angular velocity of the rotation specified in radians per second
     * @param rotationType  The [[RotationType]] to use for this rotation
     */
    rotateTo(angleRadians, speed, rotationType) {
        return this._ctx.rotateTo(angleRadians, speed, rotationType);
    }
    /**
     * This method will rotate an actor by the specified angle offset, from it's current rotation given a certain speed
     * in radians/sec and return back the actor. This method is part
     * of the actor 'Action' fluent API allowing action chaining.
     * @param angleRadiansOffset  The angle to rotate to in radians relative to the current rotation
     * @param speed          The speed in radians/sec the actor should rotate at
     * @param rotationType  The [[RotationType]] to use for this rotation, default is shortest path
     */
    rotateBy(angleRadiansOffset, speed, rotationType) {
        return this._ctx.rotateBy(angleRadiansOffset, speed, rotationType);
    }
    scaleTo(sizeXOrVector, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined) {
        return this._ctx.scaleTo.apply(this._ctx, [sizeXOrVector, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined]);
    }
    scaleBy(sizeOffsetXOrVector, sizeOffsetYOrSpeed, speed) {
        return this._ctx.scaleBy.apply(this._ctx, [sizeOffsetXOrVector, sizeOffsetYOrSpeed, speed]);
    }
    /**
     * This method will cause an actor to blink (become visible and not
     * visible). Optionally, you may specify the number of blinks. Specify the amount of time
     * the actor should be visible per blink, and the amount of time not visible.
     * This method is part of the actor 'Action' fluent API allowing action chaining.
     * @param timeVisible     The amount of time to stay visible per blink in milliseconds
     * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds
     * @param numBlinks       The number of times to blink
     */
    blink(timeVisible, timeNotVisible, numBlinks) {
        return this._ctx.blink(timeVisible, timeNotVisible, numBlinks);
    }
    /**
     * This method will cause an actor's opacity to change from its current value
     * to the provided value by a specified time (in milliseconds). This method is
     * part of the actor 'Action' fluent API allowing action chaining.
     * @param opacity  The ending opacity
     * @param time     The time it should take to fade the actor (in milliseconds)
     */
    fade(opacity, time) {
        return this._ctx.fade(opacity, time);
    }
    /**
     * This method will delay the next action from executing for a certain
     * amount of time (in milliseconds). This method is part of the actor
     * 'Action' fluent API allowing action chaining.
     * @param time  The amount of time to delay the next action in the queue from executing in milliseconds
     */
    delay(time) {
        return this._ctx.delay(time);
    }
    /**
     * This method will add an action to the queue that will remove the actor from the
     * scene once it has completed its previous  Any actions on the
     * action queue after this action will not be executed.
     */
    die() {
        return this._ctx.die();
    }
    /**
     * This method allows you to call an arbitrary method as the next action in the
     * action queue. This is useful if you want to execute code in after a specific
     * action, i.e An actor arrives at a destination after traversing a path
     */
    callMethod(method) {
        return this._ctx.callMethod(method);
    }
    /**
     * This method will cause the actor to repeat all of the actions built in
     * the `repeatBuilder` callback. If the number of repeats
     * is not specified it will repeat forever. This method is part of
     * the actor 'Action' fluent API allowing action chaining
     *
     * ```typescript
     * // Move up in a zig-zag by repeated moveBy's
     * actor.actions.repeat(repeatCtx => {
     *  repeatCtx.moveBy(10, 0, 10);
     *  repeatCtx.moveBy(0, 10, 10);
     * }, 5);
     * ```
     *
     * @param repeatBuilder The builder to specify the repeatable list of actions
     * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions
     * will repeat forever
     */
    repeat(repeatBuilder, times) {
        return this._ctx.repeat(repeatBuilder, times);
    }
    /**
     * This method will cause the actor to repeat all of the actions built in
     * the `repeatBuilder` callback. If the number of repeats
     * is not specified it will repeat forever. This method is part of
     * the actor 'Action' fluent API allowing action chaining
     *
     * ```typescript
     * // Move up in a zig-zag by repeated moveBy's
     * actor.actions.repeat(repeatCtx => {
     *  repeatCtx.moveBy(10, 0, 10);
     *  repeatCtx.moveBy(0, 10, 10);
     * }, 5);
     * ```
     *
     * @param repeatBuilder The builder to specify the repeatable list of actions
     */
    repeatForever(repeatBuilder) {
        return this._ctx.repeatForever(repeatBuilder);
    }
    /**
     * This method will cause the entity to follow another at a specified distance
     * @param entity           The entity to follow
     * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.
     */
    follow(entity, followDistance) {
        return this._ctx.follow(entity, followDistance);
    }
    /**
     * This method will cause the entity to move towards another until they
     * collide "meet" at a specified speed.
     * @param entity  The entity to meet
     * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor
     */
    meet(entity, speed) {
        return this._ctx.meet(entity, speed);
    }
    /**
     * Returns a promise that resolves when the current action queue up to now
     * is finished.
     * @deprecated Use `toPromise()` will be removed in v0.26.0
     */
    asPromise() {
        return this.toPromise();
    }
    /**
     * Returns a promise that resolves when the current action queue up to now
     * is finished.
     */
    toPromise() {
        return this._ctx.toPromise();
    }
}

;// CONCATENATED MODULE: ./Actor.ts
var Actor_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};






















/**
 * Type guard for checking if something is an Actor
 * @param x
 */
function isActor(x) {
    return x instanceof Actor;
}
/**
 * The most important primitive in Excalibur is an `Actor`. Anything that
 * can move on the screen, collide with another `Actor`, respond to events,
 * or interact with the current scene, must be an actor. An `Actor` **must**
 * be part of a [[Scene]] for it to be drawn to the screen.
 */
class Actor extends Entity {
    // #endregion
    /**
     *
     * @param config
     */
    constructor(config) {
        super();
        /**
         * The anchor to apply all actor related transformations like rotation,
         * translation, and scaling. By default the anchor is in the center of
         * the actor. By default it is set to the center of the actor (.5, .5)
         *
         * An anchor of (.5, .5) will ensure that drawings are centered.
         *
         * Use `anchor.setTo` to set the anchor to a different point using
         * values between 0 and 1. For example, anchoring to the top-left would be
         * `Actor.anchor.setTo(0, 0)` and top-right would be `Actor.anchor.setTo(0, 1)`.
         */
        this._anchor = watch(Vector.Half, (v) => this._handleAnchorChange(v));
        /**
         * Convenience reference to the global logger
         */
        this.logger = Logger.getInstance();
        /**
         * The scene that the actor is in
         */
        this.scene = null;
        this.frames = {};
        /**
         * Access to the current drawing for the actor, this can be
         * an [[Animation]], [[Sprite]], or [[Polygon]].
         * Set drawings with [[setDrawing]].
         * @deprecated
         */
        this.currentDrawing = null;
        /**
         * Draggable helper
         */
        this._draggable = false;
        this._dragging = false;
        this._pointerDragStartHandler = () => {
            this._dragging = true;
        };
        this._pointerDragEndHandler = () => {
            this._dragging = false;
        };
        this._pointerDragMoveHandler = (pe) => {
            if (this._dragging) {
                this.pos = pe.pointer.lastWorldPos;
            }
        };
        this._pointerDragLeaveHandler = (pe) => {
            if (this._dragging) {
                this.pos = pe.pointer.lastWorldPos;
            }
        };
        /**
         * Modify the current actor update pipeline.
         */
        this.traits = [];
        /**
         * Whether or not to enable the [[Traits.CapturePointer]] trait that propagates
         * pointer events to this actor
         */
        this.enableCapturePointer = false;
        /**
         * Configuration for [[Traits.CapturePointer]] trait
         */
        this.capturePointer = {
            captureMoveEvents: false,
            captureDragEvents: false
        };
        // #region Events
        this._capturePointerEvents = [
            'pointerup',
            'pointerdown',
            'pointermove',
            'pointerenter',
            'pointerleave',
            'pointerdragstart',
            'pointerdragend',
            'pointerdragmove',
            'pointerdragenter',
            'pointerdragleave'
        ];
        this._captureMoveEvents = [
            'pointermove',
            'pointerenter',
            'pointerleave',
            'pointerdragmove',
            'pointerdragenter',
            'pointerdragleave'
        ];
        this._captureDragEvents = [
            'pointerdragstart',
            'pointerdragend',
            'pointerdragmove',
            'pointerdragenter',
            'pointerdragleave'
        ];
        const { name, x, y, pos, scale, width, height, radius, collider, vel, acc, rotation, angularVelocity, z, color, visible, anchor, collisionType, collisionGroup } = Object.assign({}, config);
        this._setName(name);
        this.anchor = anchor !== null && anchor !== void 0 ? anchor : Actor.defaults.anchor.clone();
        this.addComponent(new TransformComponent());
        this.pos = pos !== null && pos !== void 0 ? pos : vec(x !== null && x !== void 0 ? x : 0, y !== null && y !== void 0 ? y : 0);
        this.rotation = rotation !== null && rotation !== void 0 ? rotation : 0;
        this.scale = scale !== null && scale !== void 0 ? scale : vec(1, 1);
        this.z = z !== null && z !== void 0 ? z : 0;
        this.addComponent(new GraphicsComponent());
        this.addComponent(new CanvasDrawComponent((ctx, delta) => this.draw(ctx, delta)));
        this.addComponent(new MotionComponent());
        this.vel = vel !== null && vel !== void 0 ? vel : Vector.Zero;
        this.acc = acc !== null && acc !== void 0 ? acc : Vector.Zero;
        this.angularVelocity = angularVelocity !== null && angularVelocity !== void 0 ? angularVelocity : 0;
        this.addComponent(new ActionsComponent());
        this.addComponent(new BodyComponent());
        this.body.collisionType = collisionType !== null && collisionType !== void 0 ? collisionType : CollisionType.Passive;
        if (collisionGroup) {
            this.body.group = collisionGroup;
        }
        if (collider) {
            this.addComponent(new ColliderComponent(collider));
        }
        else if (radius) {
            this.addComponent(new ColliderComponent(Shape.Circle(radius, this.anchor)));
        }
        else {
            if (width > 0 && height > 0) {
                this.addComponent(new ColliderComponent(Shape.Box(width, height, this.anchor)));
            }
            else {
                this.addComponent(new ColliderComponent()); // no collider
            }
        }
        this.graphics.visible = visible !== null && visible !== void 0 ? visible : true;
        if (color) {
            this.color = color;
            if (width && height) {
                this.graphics.add(new Rectangle({
                    color: color,
                    width,
                    height
                }));
            }
            else if (radius) {
                this.graphics.add(new Circle({
                    color: color,
                    radius
                }));
            }
        }
        // Build default pipeline
        if (Flags.isEnabled(Legacy.LegacyDrawing)) {
            // TODO remove offscreen trait after legacy drawing removed
            this.traits.push(new OffscreenCulling());
        }
        this.traits.push(new CapturePointer());
    }
    /**
     * The physics body the is associated with this actor. The body is the container for all physical properties, like position, velocity,
     * acceleration, mass, inertia, etc.
     */
    get body() {
        return this.get(BodyComponent);
    }
    /**
     * Access the Actor's built in [[TransformComponent]]
     */
    get transform() {
        return this.get(TransformComponent);
    }
    /**
     * Access the Actor's built in [[MotionComponent]]
     */
    get motion() {
        return this.get(MotionComponent);
    }
    /**
     * Access to the Actor's built in [[GraphicsComponent]]
     */
    get graphics() {
        return this.get(GraphicsComponent);
    }
    /**
     * Access to the Actor's built in [[ColliderComponent]]
     */
    get collider() {
        return this.get(ColliderComponent);
    }
    /**
     * Useful for quickly scripting actor behavior, like moving to a place, patroling back and forth, blinking, etc.
     *
     *  Access to the Actor's built in [[ActionsComponent]] which forwards to the
     * [[ActionContext|Action context]] of the actor.
     */
    get actions() {
        return this.get(ActionsComponent);
    }
    /**
     * Gets the position vector of the actor in pixels
     */
    get pos() {
        return this.transform.pos;
    }
    /**
     * Sets the position vector of the actor in pixels
     */
    set pos(thePos) {
        this.transform.pos = thePos.clone();
    }
    /**
     * Gets the position vector of the actor from the last frame
     */
    get oldPos() {
        return this.body.oldPos;
    }
    /**
     * Sets the position vector of the actor in the last frame
     */
    set oldPos(thePos) {
        this.body.oldPos.setTo(thePos.x, thePos.y);
    }
    /**
     * Gets the velocity vector of the actor in pixels/sec
     */
    get vel() {
        return this.motion.vel;
    }
    /**
     * Sets the velocity vector of the actor in pixels/sec
     */
    set vel(theVel) {
        this.motion.vel = theVel.clone();
    }
    /**
     * Gets the velocity vector of the actor from the last frame
     */
    get oldVel() {
        return this.body.oldVel;
    }
    /**
     * Sets the velocity vector of the actor from the last frame
     */
    set oldVel(theVel) {
        this.body.oldVel.setTo(theVel.x, theVel.y);
    }
    /**
     * Gets the acceleration vector of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may be
     * useful to simulate a gravitational effect.
     */
    get acc() {
        return this.motion.acc;
    }
    /**
     * Sets the acceleration vector of teh actor in pixels/second/second
     */
    set acc(theAcc) {
        this.motion.acc = theAcc.clone();
    }
    /**
     * Sets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].
     */
    set oldAcc(theAcc) {
        this.body.oldAcc.setTo(theAcc.x, theAcc.y);
    }
    /**
     * Gets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].
     */
    get oldAcc() {
        return this.body.oldAcc;
    }
    /**
     * Gets the rotation of the actor in radians. 1 radian = 180/PI Degrees.
     */
    get rotation() {
        return this.transform.rotation;
    }
    /**
     * Sets the rotation of the actor in radians. 1 radian = 180/PI Degrees.
     */
    set rotation(theAngle) {
        this.transform.rotation = theAngle;
    }
    /**
     * Gets the rotational velocity of the actor in radians/second
     */
    get angularVelocity() {
        return this.motion.angularVelocity;
    }
    /**
     * Sets the rotational velocity of the actor in radians/sec
     */
    set angularVelocity(angularVelocity) {
        this.motion.angularVelocity = angularVelocity;
    }
    get scale() {
        return this.get(TransformComponent).scale;
    }
    set scale(scale) {
        this.get(TransformComponent).scale = scale;
    }
    get anchor() {
        return this._anchor;
    }
    set anchor(vec) {
        this._anchor = watch(vec, (v) => this._handleAnchorChange(v));
        this._handleAnchorChange(vec);
    }
    _handleAnchorChange(v) {
        if (this.graphics) {
            this.graphics.anchor = v;
        }
    }
    /**
     * Indicates whether the actor is physically in the viewport
     */
    get isOffScreen() {
        return this.hasTag('offscreen');
    }
    /**
     * The visibility of an actor
     * @deprecated Use [[GraphicsComponent.visible|Actor.graphics.visible]], will be removed in v0.26.0
     */
    get visible() {
        return this.graphics.visible;
    }
    set visible(isVisible) {
        this.graphics.visible = isVisible;
    }
    /**
     * The opacity of an actor.
     *
     * @deprecated Actor.opacity will be removed in v0.26.0, use [[GraphicsComponent.opacity|Actor.graphics.opacity]].
     */
    get opacity() {
        return this.graphics.opacity;
    }
    set opacity(opacity) {
        this.graphics.opacity = opacity;
    }
    get draggable() {
        return this._draggable;
    }
    set draggable(isDraggable) {
        if (isDraggable) {
            if (isDraggable && !this._draggable) {
                this.on('pointerdragstart', this._pointerDragStartHandler);
                this.on('pointerdragend', this._pointerDragEndHandler);
                this.on('pointerdragmove', this._pointerDragMoveHandler);
                this.on('pointerdragleave', this._pointerDragLeaveHandler);
            }
            else if (!isDraggable && this._draggable) {
                this.off('pointerdragstart', this._pointerDragStartHandler);
                this.off('pointerdragend', this._pointerDragEndHandler);
                this.off('pointerdragmove', this._pointerDragMoveHandler);
                this.off('pointerdragleave', this._pointerDragLeaveHandler);
            }
            this._draggable = isDraggable;
        }
    }
    /**
     * Sets the color of the actor. A rectangle of this color will be
     * drawn if no [[Drawable]] is specified as the actors drawing.
     *
     * The default is `null` which prevents a rectangle from being drawn.
     */
    get color() {
        return this._color;
    }
    set color(v) {
        this._color = v.clone();
    }
    /**
     * `onInitialize` is called before the first update of the actor. This method is meant to be
     * overridden. This is where initialization of child actors should take place.
     *
     * Synonymous with the event handler `.on('initialize', (evt) => {...})`
     */
    onInitialize(_engine) {
        // Override me
    }
    /**
     * Initializes this actor and all it's child actors, meant to be called by the Scene before first update not by users of Excalibur.
     *
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * @internal
     */
    _initialize(engine) {
        super._initialize(engine);
        for (const child of this.children) {
            child._initialize(engine);
        }
    }
    _checkForPointerOptIn(eventName) {
        if (eventName) {
            const normalized = eventName.toLowerCase();
            if (this._capturePointerEvents.indexOf(normalized) !== -1) {
                this.enableCapturePointer = true;
                if (this._captureMoveEvents.indexOf(normalized) !== -1) {
                    this.capturePointer.captureMoveEvents = true;
                }
                if (this._captureDragEvents.indexOf(normalized) !== -1) {
                    this.capturePointer.captureDragEvents = true;
                }
            }
        }
    }
    on(eventName, handler) {
        this._checkForPointerOptIn(eventName);
        super.on(eventName, handler);
    }
    once(eventName, handler) {
        this._checkForPointerOptIn(eventName);
        super.once(eventName, handler);
    }
    off(eventName, handler) {
        super.off(eventName, handler);
    }
    // #endregion
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _prekill handler for [[onPreKill]] lifecycle event
     * @internal
     */
    _prekill(_scene) {
        super.emit('prekill', new PreKillEvent(this));
        this.onPreKill(_scene);
    }
    /**
     * Safe to override onPreKill lifecycle event handler. Synonymous with `.on('prekill', (evt) =>{...})`
     *
     * `onPreKill` is called directly before an actor is killed and removed from its current [[Scene]].
     */
    onPreKill(_scene) {
        // Override me
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _prekill handler for [[onPostKill]] lifecycle event
     * @internal
     */
    _postkill(_scene) {
        super.emit('postkill', new PostKillEvent(this));
        this.onPostKill(_scene);
    }
    /**
     * Safe to override onPostKill lifecycle event handler. Synonymous with `.on('postkill', (evt) => {...})`
     *
     * `onPostKill` is called directly after an actor is killed and remove from its current [[Scene]].
     */
    onPostKill(_scene) {
        // Override me
    }
    /**
     * If the current actor is a member of the scene, this will remove
     * it from the scene graph. It will no longer be drawn or updated.
     */
    kill() {
        if (this.scene) {
            this._prekill(this.scene);
            this.emit('kill', new KillEvent(this));
            super.kill();
            this._postkill(this.scene);
        }
        else {
            this.logger.warn('Cannot kill actor, it was never added to the Scene');
        }
    }
    /**
     * If the current actor is killed, it will now not be killed.
     */
    unkill() {
        this.active = true;
    }
    /**
     * Indicates wether the actor has been killed.
     */
    isKilled() {
        return !this.active;
    }
    setDrawing(key) {
        key = key.toString();
        if (this.currentDrawing !== this.frames[key]) {
            if (this.frames[key] != null) {
                this.frames[key].reset();
                this.currentDrawing = this.frames[key];
            }
            else {
                Logger.getInstance().error(`the specified drawing key ${key} does not exist`);
            }
        }
        if (this.currentDrawing && this.currentDrawing instanceof Animation_Animation) {
            this.currentDrawing.tick(0);
        }
    }
    addDrawing() {
        if (arguments.length === 2) {
            this.frames[arguments[0]] = arguments[1];
            if (!this.currentDrawing) {
                this.currentDrawing = arguments[1];
            }
        }
        else {
            if (arguments[0] instanceof Sprite_Sprite) {
                this.addDrawing('default', arguments[0]);
            }
            if (arguments[0] instanceof Texture) {
                this.addDrawing('default', arguments[0].asSprite());
            }
        }
    }
    /**
     * Gets the z-index of an actor. The z-index determines the relative order an actor is drawn in.
     * Actors with a higher z-index are drawn on top of actors with a lower z-index
     */
    get z() {
        return this.get(TransformComponent).z;
    }
    /**
     * @deprecated Use [[Actor.z]]
     */
    getZIndex() {
        return this.get(TransformComponent).z;
    }
    /**
     * Sets the z-index of an actor and updates it in the drawing list for the scene.
     * The z-index determines the relative order an actor is drawn in.
     * Actors with a higher z-index are drawn on top of actors with a lower z-index
     * @param newZ new z-index to assign
     */
    set z(newZ) {
        this.get(TransformComponent).z = newZ;
    }
    /**
     * @param newIndex new z-index to assign
     * @deprecated Use [[Actor.z]]
     */
    setZIndex(newIndex) {
        this.get(TransformComponent).z = newIndex;
    }
    /**
     * Get the center point of an actor
     */
    get center() {
        return new Vector(this.pos.x + this.width / 2 - this.anchor.x * this.width, this.pos.y + this.height / 2 - this.anchor.y * this.height);
    }
    get width() {
        return this.collider.localBounds.width * this.getGlobalScale().x;
    }
    get height() {
        return this.collider.localBounds.height * this.getGlobalScale().y;
    }
    /**
     * Gets this actor's rotation taking into account any parent relationships
     *
     * @returns Rotation angle in radians
     */
    getGlobalRotation() {
        return this.get(TransformComponent).globalRotation;
    }
    /**
     * Gets an actor's world position taking into account parent relationships, scaling, rotation, and translation
     *
     * @returns Position in world coordinates
     */
    getGlobalPos() {
        return this.get(TransformComponent).globalPos;
    }
    /**
     * Gets the global scale of the Actor
     */
    getGlobalScale() {
        return this.get(TransformComponent).globalScale;
    }
    // #region Collision
    /**
     * Tests whether the x/y specified are contained in the actor
     * @param x  X coordinate to test (in world coordinates)
     * @param y  Y coordinate to test (in world coordinates)
     * @param recurse checks whether the x/y are contained in any child actors (if they exist).
     */
    contains(x, y, recurse = false) {
        const point = vec(x, y);
        const collider = this.get(ColliderComponent);
        collider.update();
        const geom = collider.get();
        if (!geom) {
            return false;
        }
        const containment = geom.contains(point);
        if (recurse) {
            return (containment ||
                this.children.some((child) => {
                    return child.contains(x, y, true);
                }));
        }
        return containment;
    }
    /**
     * Returns true if the two actor.collider's surfaces are less than or equal to the distance specified from each other
     * @param actor     Actor to test
     * @param distance  Distance in pixels to test
     */
    within(actor, distance) {
        const collider = this.get(ColliderComponent);
        const otherCollider = actor.get(ColliderComponent);
        const me = collider.get();
        const other = otherCollider.get();
        if (me && other) {
            return me.getClosestLineBetween(other).getLength() <= distance;
        }
        return false;
    }
    // #endregion
    // #region Update
    /**
     * Called by the Engine, updates the state of the actor
     * @internal
     * @param engine The reference to the current game engine
     * @param delta  The time elapsed since the last update in milliseconds
     */
    update(engine, delta) {
        this._initialize(engine);
        this._preupdate(engine, delta);
        // Tick animations
        const drawing = this.currentDrawing;
        if (drawing && drawing instanceof Animation_Animation) {
            drawing.tick(delta, engine.stats.currFrame.id);
        }
        // Update actor pipeline (movement, collision detection, event propagation, offscreen culling)
        for (const trait of this.traits) {
            trait.update(this, engine, delta);
        }
        this._postupdate(engine, delta);
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before an actor is updated.
     */
    onPreUpdate(_engine, _delta) {
        // Override me
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after an actor is updated.
     */
    onPostUpdate(_engine, _delta) {
        // Override me
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event
     * @internal
     */
    _preupdate(engine, delta) {
        this.emit('preupdate', new PreUpdateEvent(engine, delta, this));
        this.onPreUpdate(engine, delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event
     * @internal
     */
    _postupdate(engine, delta) {
        this.emit('postupdate', new PreUpdateEvent(engine, delta, this));
        this.onPostUpdate(engine, delta);
    }
    // endregion
    // #region Drawing
    /**
     * Called by the Engine, draws the actor to the screen
     * @param ctx   The rendering context
     * @param delta The time since the last draw in milliseconds
     *
     * **Warning** only works with Flags.useLegacyDrawing() enabled
     * @deprecated Use Actor.graphics, will be removed in v0.26.0
     */
    draw(ctx, delta) {
        var _a;
        // translate canvas by anchor offset
        ctx.save();
        if (this.currentDrawing) {
            ctx.translate(-(this.width * this.anchor.x), -(this.height * this.anchor.y));
            this._predraw(ctx, delta);
            const drawing = this.currentDrawing;
            // See https://github.com/excaliburjs/Excalibur/pull/619 for discussion on this formula
            const offsetX = (this.width - drawing.width * drawing.scale.x) * this.anchor.x;
            const offsetY = (this.height - drawing.height * drawing.scale.y) * this.anchor.y;
            this.currentDrawing.draw({ ctx, x: offsetX, y: offsetY, opacity: this.graphics.opacity });
        }
        else {
            this._predraw(ctx, delta);
            if (this.color && this.collider) {
                // update collider geometry based on transform
                const collider = this.get(ColliderComponent);
                collider.update();
                if (collider && !collider.bounds.hasZeroDimensions()) {
                    // Colliders are already shifted by anchor, unshift
                    ctx.globalAlpha = this.graphics.opacity;
                    (_a = collider.get()) === null || _a === void 0 ? void 0 : _a.draw(ctx, this.color, vec(0, 0));
                }
            }
        }
        ctx.restore();
        this._postdraw(ctx, delta);
    }
    /**
     * Safe to override onPreDraw lifecycle event handler. Synonymous with `.on('predraw', (evt) =>{...})`
     *
     * `onPreDraw` is called directly before an actor is drawn, but after local transforms are made.
     *
     * **Warning** only works with Flags.useLegacyDrawing() enabled
     * @deprecated Use Actor.graphics.onPostDraw, will be removed in v0.26.0
     */
    onPreDraw(_ctx, _delta) {
        // Override me
    }
    /**
     * Safe to override onPostDraw lifecycle event handler. Synonymous with `.on('postdraw', (evt) =>{...})`
     *
     * `onPostDraw` is called directly after an actor is drawn, and before local transforms are removed.
     *
     * **Warning** only works with Flags.useLegacyDrawing() enabled
     * @deprecated Use Actor.graphics.onPostDraw, will be removed in v0.26.0
     */
    onPostDraw(_ctx, _delta) {
        // Override me
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _predraw handler for [[onPreDraw]] lifecycle event
     *
     * **Warning** only works with Flags.useLegacyDrawing() enabled
     * @deprecated Use Actor.graphics.onPreDraw, will be removed in v0.26.0
     * @internal
     */
    _predraw(ctx, delta) {
        this.emit('predraw', new PreDrawEvent(ctx, delta, this));
        this.onPreDraw(ctx, delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _postdraw handler for [[onPostDraw]] lifecycle event
     *
     * **Warning** only works with Flags.useLegacyDrawing() enabled
     * @deprecated Use Actor.graphics.onPostDraw, will be removed in v0.26.0
     * @internal
     */
    _postdraw(ctx, delta) {
        this.emit('postdraw', new PreDrawEvent(ctx, delta, this));
        this.onPostDraw(ctx, delta);
    }
    /**
     * Called by the Engine, draws the actors debugging to the screen
     * @param ctx The rendering context
     *
     *
     * **Warning** only works with Flags.useLegacyDrawing() enabled
     * @deprecated Use Actor.graphics.onPostDraw, will be removed in v0.26.0
     * @internal
     */
    /* istanbul ignore next */
    debugDraw(_ctx) {
        // pass
    }
}
// #region Properties
/**
 * Set defaults for all Actors
 */
Actor.defaults = {
    anchor: Vector.Half
};
Actor_decorate([
    obsolete({ message: 'Actor.visible will be removed in v0.26.0', alternateMethod: 'Use Actor.graphics.visible' })
], Actor.prototype, "visible", null);
Actor_decorate([
    obsolete({
        message: 'Actor.opacity will be removed in v0.26.0',
        alternateMethod: 'Use Actor.graphics.opacity'
    })
], Actor.prototype, "opacity", null);
Actor_decorate([
    obsolete({
        message: 'Actor.setDrawing will be removed in v0.26.0',
        alternateMethod: 'Use Actor.graphics.show() or Actor.graphics.use()'
    })
], Actor.prototype, "setDrawing", null);
Actor_decorate([
    obsolete({
        message: 'Actor.addDrawing will be removed in v0.26.0',
        alternateMethod: 'Use Actor.graphics.add()'
    })
], Actor.prototype, "addDrawing", null);
Actor_decorate([
    obsolete({
        message: 'Actor.getZIndex will be removed in v0.26.0',
        alternateMethod: 'Use Actor.transform.z or Actor.z'
    })
], Actor.prototype, "getZIndex", null);
Actor_decorate([
    obsolete({
        message: 'Actor.setZIndex will be removed in v0.26.0',
        alternateMethod: 'Use Actor.transform.z or Actor.z'
    })
], Actor.prototype, "setZIndex", null);

;// CONCATENATED MODULE: ./ScreenElement.ts





/**
 * Helper [[Actor]] primitive for drawing UI's, optimized for UI drawing. Does
 * not participate in collisions. Drawn on top of all other actors.
 */
class ScreenElement_ScreenElement extends Actor {
    constructor(config) {
        super(Object.assign({}, config));
        this.get(TransformComponent).coordPlane = CoordPlane.Screen;
        this.traits = [];
        this.traits.push(new CapturePointer());
        this.anchor = vec(0, 0);
        this.body.collisionType = CollisionType.PreventCollision;
        this.collider.useBoxCollider(this.width, this.height, this.anchor);
        this.enableCapturePointer = true;
    }
    _initialize(engine) {
        this._engine = engine;
        super._initialize(engine);
    }
    contains(x, y, useWorld = true) {
        if (useWorld) {
            return super.contains(x, y);
        }
        const coords = this._engine.worldToScreenCoordinates(new Vector(x, y));
        return super.contains(coords.x, coords.y);
    }
}

;// CONCATENATED MODULE: ./Timer.ts
var Timer_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


/**
 * The Excalibur timer hooks into the internal timer and fires callbacks,
 * after a certain interval, optionally repeating.
 */
class Timer {
    constructor(fcn, interval, repeats, numberOfRepeats) {
        this._logger = Logger.getInstance();
        this.id = 0;
        this._elapsedTime = 0;
        this._totalTimeAlive = 0;
        this._running = false;
        this._numberOfTicks = 0;
        this.interval = 10;
        this.repeats = false;
        this.maxNumberOfRepeats = -1;
        this._complete = false;
        this.scene = null;
        if (typeof fcn !== 'function') {
            const options = fcn;
            fcn = options.fcn;
            interval = options.interval;
            repeats = options.repeats;
            numberOfRepeats = options.numberOfRepeats;
        }
        if (!!numberOfRepeats && numberOfRepeats >= 0) {
            this.maxNumberOfRepeats = numberOfRepeats;
            if (!repeats) {
                throw new Error('repeats must be set to true if numberOfRepeats is set');
            }
        }
        this.id = Timer._MAX_ID++;
        this.interval = interval || this.interval;
        this.repeats = repeats || this.repeats;
        this._callbacks = [];
        if (fcn) {
            this.on(fcn);
        }
    }
    get complete() {
        return this._complete;
    }
    /**
     * Adds a new callback to be fired after the interval is complete
     * @param fcn The callback to be added to the callback list, to be fired after the interval is complete.
     */
    on(fcn) {
        this._callbacks.push(fcn);
    }
    /**
     * Removes a callback from the callback list to be fired after the interval is complete.
     * @param fcn The callback to be removed from the callback list, to be fired after the interval is complete.
     */
    off(fcn) {
        const index = this._callbacks.indexOf(fcn);
        this._callbacks.splice(index, 1);
    }
    /**
     * Updates the timer after a certain number of milliseconds have elapsed. This is used internally by the engine.
     * @param delta  Number of elapsed milliseconds since the last update.
     */
    update(delta) {
        if (this._running) {
            this._totalTimeAlive += delta;
            this._elapsedTime += delta;
            if (this.maxNumberOfRepeats > -1 && this._numberOfTicks >= this.maxNumberOfRepeats) {
                this._complete = true;
                this._running = false;
                this._elapsedTime = 0;
            }
            if (!this.complete && this._elapsedTime >= this.interval) {
                this._callbacks.forEach((c) => {
                    c.call(this);
                });
                this._numberOfTicks++;
                if (this.repeats) {
                    this._elapsedTime = 0;
                }
                else {
                    this._complete = true;
                    this._running = false;
                    this._elapsedTime = 0;
                }
            }
        }
    }
    /**
     * Resets the timer so that it can be reused, and optionally reconfigure the timers interval.
     *
     * Warning** you may need to call `timer.start()` again if the timer had completed
     * @param newInterval If specified, sets a new non-negative interval in milliseconds to refire the callback
     * @param newNumberOfRepeats If specified, sets a new non-negative upper limit to the number of time this timer executes
     */
    reset(newInterval, newNumberOfRepeats) {
        if (!!newInterval && newInterval >= 0) {
            this.interval = newInterval;
        }
        if (!!this.maxNumberOfRepeats && this.maxNumberOfRepeats >= 0) {
            this.maxNumberOfRepeats = newNumberOfRepeats;
            if (!this.repeats) {
                throw new Error('repeats must be set to true if numberOfRepeats is set');
            }
        }
        this._complete = false;
        this._elapsedTime = 0;
        this._numberOfTicks = 0;
    }
    get timesRepeated() {
        return this._numberOfTicks;
    }
    getTimeRunning() {
        return this._totalTimeAlive;
    }
    /**
     * @returns milliseconds until the next action callback, if complete will return 0
     */
    get timeToNextAction() {
        if (this.complete) {
            return 0;
        }
        return this.interval - this._elapsedTime;
    }
    /**
     * @returns milliseconds elapsed toward the next action
     */
    get timeElapsedTowardNextAction() {
        return this._elapsedTime;
    }
    get isRunning() {
        return this._running;
    }
    /**
     * Pauses the timer, time will no longer increment towards the next call
     */
    pause() {
        this._running = false;
        return this;
    }
    /**
     * Unpauses the timer. Time will now increment towards the next call
     * @deprecated Will be removed in v0.26.0
     */
    unpause() {
        this._running = true;
    }
    /**
     * Resumes the timer, time will now increment towards the next call.
     */
    resume() {
        this._running = true;
        return this;
    }
    /**
     * Starts the timer, if the timer was complete it will restart the timer and reset the elapsed time counter
     */
    start() {
        if (!this.scene) {
            this._logger.warn('Cannot start a timer not part of a scene, timer wont start until added');
        }
        this._running = true;
        if (this.complete) {
            this._complete = false;
            this._elapsedTime = 0;
            this._numberOfTicks = 0;
        }
        return this;
    }
    /**
     * Stops the timer and resets the elapsed time counter towards the next action invocation
     */
    stop() {
        this._running = false;
        this._elapsedTime = 0;
        this._numberOfTicks = 0;
        return this;
    }
    /**
     * Cancels the timer, preventing any further executions.
     */
    cancel() {
        this.pause();
        if (this.scene) {
            this.scene.cancelTimer(this);
        }
    }
}
Timer._MAX_ID = 0;
Timer_decorate([
    obsolete({ message: 'Will be removed in v0.26.0', alternateMethod: 'Use Timer.resume()' })
], Timer.prototype, "unpause", null);

;// CONCATENATED MODULE: ./TileMap.ts
var TileMap_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


















/**
 * @hidden
 */
class TileMapImpl extends Entity {
    /**
     * @param xOrConfig     The x coordinate to anchor the TileMap's upper left corner (should not be changed once set) or TileMap option bag
     * @param y             The y coordinate to anchor the TileMap's upper left corner (should not be changed once set)
     * @param cellWidth     The individual width of each cell (in pixels) (should not be changed once set)
     * @param cellHeight    The individual height of each cell (in pixels) (should not be changed once set)
     * @param rows          The number of rows in the TileMap (should not be changed once set)
     * @param cols          The number of cols in the TileMap (should not be changed once set)
     */
    constructor(xOrConfig, y, cellWidth, cellHeight, rows, cols) {
        super();
        this._token = 0;
        this._onScreenXStart = 0;
        this._onScreenXEnd = 9999;
        this._onScreenYStart = 0;
        this._onScreenYEnd = 9999;
        this._spriteSheets = {};
        this._legacySpriteMap = new Map();
        this.logger = Logger.getInstance();
        this.data = [];
        this._rows = [];
        this._cols = [];
        this.visible = true;
        this.isOffscreen = false;
        this._dirty = true;
        if (xOrConfig && typeof xOrConfig === 'object') {
            const config = xOrConfig;
            xOrConfig = config.x;
            y = config.y;
            cellWidth = config.cellWidth;
            cellHeight = config.cellHeight;
            rows = config.rows;
            cols = config.cols;
        }
        this.addComponent(new TransformComponent());
        this.addComponent(new MotionComponent());
        this.addComponent(new BodyComponent({
            type: CollisionType.Fixed
        }));
        this.addComponent(new CanvasDrawComponent((ctx, delta) => this.draw(ctx, delta)));
        this.addComponent(new GraphicsComponent({
            onPostDraw: (ctx, delta) => this.draw(ctx, delta)
        }));
        this.addComponent(new ColliderComponent());
        this._transform = this.get(TransformComponent);
        this._motion = this.get(MotionComponent);
        this._collider = this.get(ColliderComponent);
        this._composite = this._collider.useCompositeCollider([]);
        this.x = xOrConfig;
        this.y = y;
        this.cellWidth = cellWidth;
        this.cellHeight = cellHeight;
        this.rows = rows;
        this.cols = cols;
        this.data = new Array(rows * cols);
        this._rows = new Array(rows);
        this._cols = new Array(cols);
        let currentCol = [];
        for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
                const cd = new Cell(i * cellWidth + xOrConfig, j * cellHeight + y, cellWidth, cellHeight, i + j * cols);
                cd.map = this;
                this.data[i + j * cols] = cd;
                currentCol.push(cd);
                if (!this._rows[j]) {
                    this._rows[j] = [];
                }
                this._rows[j].push(cd);
            }
            this._cols[i] = currentCol;
            currentCol = [];
        }
        this.get(GraphicsComponent).localBounds = new BoundingBox({
            left: 0,
            top: 0,
            right: this.cols * this.cellWidth,
            bottom: this.rows * this.cellHeight
        });
    }
    flagDirty() {
        this._dirty = true;
    }
    get x() {
        var _a;
        return (_a = this._transform.pos.x) !== null && _a !== void 0 ? _a : 0;
    }
    set x(val) {
        var _a;
        if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) {
            this.get(TransformComponent).pos = vec(val, this.y);
        }
    }
    get y() {
        var _a, _b;
        return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos.y) !== null && _b !== void 0 ? _b : 0;
    }
    set y(val) {
        var _a;
        if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) {
            this._transform.pos = vec(this.x, val);
        }
    }
    get z() {
        var _a;
        return (_a = this._transform.z) !== null && _a !== void 0 ? _a : 0;
    }
    set z(val) {
        if (this._transform) {
            this._transform.z = val;
        }
    }
    get rotation() {
        var _a, _b;
        return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.rotation) !== null && _b !== void 0 ? _b : 0;
    }
    set rotation(val) {
        var _a;
        if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.rotation) {
            this._transform.rotation = val;
        }
    }
    get scale() {
        var _a, _b;
        return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.scale) !== null && _b !== void 0 ? _b : Vector.One;
    }
    set scale(val) {
        var _a;
        if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.scale) {
            this._transform.scale = val;
        }
    }
    get pos() {
        return this._transform.pos;
    }
    set pos(val) {
        this._transform.pos = val;
    }
    get vel() {
        return this._motion.vel;
    }
    set vel(val) {
        this._motion.vel = val;
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    _initialize(engine) {
        super._initialize(engine);
    }
    registerSpriteSheet(key, spriteSheet) {
        if (spriteSheet instanceof SpriteSheet) {
            this._spriteSheets[key] = spriteSheet;
        }
        else {
            this._spriteSheets[key] = SpriteSheet.fromLegacySpriteSheet(spriteSheet);
        }
    }
    /**
     * Tiles colliders based on the solid tiles in the tilemap.
     */
    _updateColliders() {
        this._composite.clearColliders();
        const colliders = [];
        let current;
        // Bad square tessalation algo
        for (let i = 0; i < this.cols; i++) {
            // Scan column for colliders
            for (let j = 0; j < this.rows; j++) {
                // Columns start with a new collider
                if (j === 0) {
                    current = null;
                }
                const tile = this.data[i + j * this.cols];
                // Current tile in column is solid build up current collider
                if (tile.solid) {
                    if (!current) {
                        current = tile.bounds;
                    }
                    else {
                        current = current.combine(tile.bounds);
                    }
                }
                else {
                    // Not solid skip and cut off the current collider
                    if (current) {
                        colliders.push(current);
                    }
                    current = null;
                }
            }
            // After a column is complete check to see if it can be merged into the last one
            if (current) {
                // if previous is the same combine it
                const prev = colliders[colliders.length - 1];
                if (prev && prev.top === current.top && prev.bottom === current.bottom) {
                    colliders[colliders.length - 1] = prev.combine(current);
                }
                else {
                    // else new collider
                    colliders.push(current);
                }
            }
        }
        this._composite = this._collider.useCompositeCollider([]);
        for (const c of colliders) {
            const collider = Shape.Box(c.width, c.height, Vector.Zero, vec(c.left - this.pos.x, c.top - this.pos.y));
            collider.owner = this;
            this._composite.addCollider(collider);
        }
        this._collider.update();
    }
    /**
     * Returns the [[Cell]] by index (row major order)
     */
    getCellByIndex(index) {
        return this.data[index];
    }
    /**
     * Returns the [[Cell]] by its x and y coordinates
     */
    getCell(x, y) {
        if (x < 0 || y < 0 || x >= this.cols || y >= this.rows) {
            return null;
        }
        return this.data[x + y * this.cols];
    }
    /**
     * Returns the [[Cell]] by testing a point in global coordinates,
     * returns `null` if no cell was found.
     */
    getCellByPoint(x, y) {
        x = Math.floor((x - this.pos.x) / this.cellWidth);
        y = Math.floor((y - this.pos.y) / this.cellHeight);
        const cell = this.getCell(x, y);
        if (x >= 0 && y >= 0 && x < this.cols && y < this.rows && cell) {
            return cell;
        }
        return null;
    }
    getRows() {
        return this._rows;
    }
    getColumns() {
        return this._cols;
    }
    onPreUpdate(_engine, _delta) {
        // Override me
    }
    onPostUpdate(_engine, _delta) {
        // Override me
    }
    update(engine, delta) {
        this.onPreUpdate(engine, delta);
        this.emit('preupdate', new PreUpdateEvent(engine, delta, this));
        if (this._dirty) {
            this._dirty = false;
            this._updateColliders();
        }
        this._token++;
        const worldBounds = engine.getWorldBounds();
        const worldCoordsUpperLeft = vec(worldBounds.left, worldBounds.top);
        const worldCoordsLowerRight = vec(worldBounds.right, worldBounds.bottom);
        this._onScreenXStart = Math.max(Math.floor((worldCoordsUpperLeft.x - this.x) / this.cellWidth) - 2, 0);
        this._onScreenYStart = Math.max(Math.floor((worldCoordsUpperLeft.y - this.y) / this.cellHeight) - 2, 0);
        this._onScreenXEnd = Math.max(Math.floor((worldCoordsLowerRight.x - this.x) / this.cellWidth) + 2, 0);
        this._onScreenYEnd = Math.max(Math.floor((worldCoordsLowerRight.y - this.y) / this.cellHeight) + 2, 0);
        this._transform.pos = vec(this.x, this.y);
        this.onPostUpdate(engine, delta);
        this.emit('postupdate', new PostUpdateEvent(engine, delta, this));
    }
    /**
     * Draws the tile map to the screen. Called by the [[Scene]].
     * @param ctx CanvasRenderingContext2D or ExcaliburGraphicsContext
     * @param delta  The number of milliseconds since the last draw
     */
    draw(ctx, delta) {
        this.emit('predraw', new PreDrawEvent(ctx, delta, this)); // TODO fix event
        let x = this._onScreenXStart;
        const xEnd = Math.min(this._onScreenXEnd, this.cols);
        let y = this._onScreenYStart;
        const yEnd = Math.min(this._onScreenYEnd, this.rows);
        let graphics, graphicsIndex, graphicsLen;
        for (x; x < xEnd; x++) {
            for (y; y < yEnd; y++) {
                // get non-negative tile sprites
                graphics = this.getCell(x, y).graphics;
                for (graphicsIndex = 0, graphicsLen = graphics.length; graphicsIndex < graphicsLen; graphicsIndex++) {
                    // draw sprite, warning if sprite doesn't exist
                    const graphic = graphics[graphicsIndex];
                    if (graphic) {
                        if (!(ctx instanceof CanvasRenderingContext2D)) {
                            if (hasGraphicsTick(graphic)) {
                                graphic === null || graphic === void 0 ? void 0 : graphic.tick(delta, this._token);
                            }
                            graphic.draw(ctx, x * this.cellWidth, y * this.cellHeight);
                        }
                        else if (graphic instanceof Sprite) {
                            // TODO legacy drawing mode
                            if (!this._legacySpriteMap.has(graphic)) {
                                this._legacySpriteMap.set(graphic, Sprite.toLegacySprite(graphic));
                            }
                            this._legacySpriteMap.get(graphic).draw(ctx, x * this.cellWidth, y * this.cellHeight);
                        }
                    }
                }
            }
            y = this._onScreenYStart;
        }
        this.emit('postdraw', new PostDrawEvent(ctx, delta, this));
    }
}
TileMap_decorate([
    obsolete({ message: 'No longer used, will be removed in v0.26.0' })
], TileMapImpl.prototype, "registerSpriteSheet", null);
/**
 * The [[TileMap]] class provides a lightweight way to do large complex scenes with collision
 * without the overhead of actors.
 */
class TileMap extends Configurable(TileMapImpl) {
    constructor(xOrConfig, y, cellWidth, cellHeight, rows, cols) {
        super(xOrConfig, y, cellWidth, cellHeight, rows, cols);
    }
}
/**
 * @hidden
 */
class CellImpl extends Entity {
    /**
     * @param xOrConfig Gets or sets x coordinate of the cell in world coordinates or cell option bag
     * @param y       Gets or sets y coordinate of the cell in world coordinates
     * @param width   Gets or sets the width of the cell
     * @param height  Gets or sets the height of the cell
     * @param index   The index of the cell in row major order
     * @param solid   Gets or sets whether this cell is solid
     * @param graphics The list of tile graphics to use to draw in this cell (in order)
     */
    constructor(xOrConfig, y, width, height, index, solid = false, graphics = []) {
        super();
        this._solid = false;
        /**
         * Current list of graphics for this cell
         */
        this.graphics = [];
        /**
         * Abitrary data storage per cell, useful for any game specific data
         */
        this.data = new Map();
        if (xOrConfig && typeof xOrConfig === 'object') {
            const config = xOrConfig;
            xOrConfig = config.x;
            y = config.y;
            width = config.width;
            height = config.height;
            index = config.index;
            solid = config.solid;
            graphics = config.sprites;
        }
        this.x = xOrConfig;
        this.y = y;
        this.width = width;
        this.height = height;
        this.index = index;
        this.solid = solid;
        this.graphics = graphics;
        this._bounds = new BoundingBox(this.x, this.y, this.x + this.width, this.y + this.height);
    }
    /**
     * Wether this cell should be treated as solid by the tilemap
     */
    get solid() {
        return this._solid;
    }
    /**
     * Wether this cell should be treated as solid by the tilemap
     */
    set solid(val) {
        var _a;
        (_a = this.map) === null || _a === void 0 ? void 0 : _a.flagDirty();
        this._solid = val;
    }
    get bounds() {
        return this._bounds;
    }
    get center() {
        return new Vector(this.x + this.width / 2, this.y + this.height / 2);
    }
    /**
     * Add another [[Sprite]] to this cell
     * @deprecated Use addSprite, will be removed in v0.26.0
     */
    pushSprite(sprite) {
        this.addGraphic(sprite);
    }
    /**
     * Add another [[Graphic]] to this TileMap cell
     * @param graphic
     */
    addGraphic(graphic) {
        if (graphic instanceof Sprite_Sprite) {
            this.graphics.push(Sprite.fromLegacySprite(graphic));
        }
        else {
            this.graphics.push(graphic);
        }
    }
    /**
     * Remove an instance of a [[Graphic]] from this cell
     */
    removeGraphic(graphic) {
        removeItemFromArray(graphic, this.graphics);
    }
    /**
     * Clear all graphis from this cell
     */
    clearGraphics() {
        this.graphics.length = 0;
    }
}
TileMap_decorate([
    obsolete({ message: 'Will be removed in v0.26.0', alternateMethod: 'addSprite' })
], CellImpl.prototype, "pushSprite", null);
/**
 * TileMap Cell
 *
 * A light-weight object that occupies a space in a collision map. Generally
 * created by a [[TileMap]].
 *
 * Cells can draw multiple sprites. Note that the order of drawing is the order
 * of the sprites in the array so the last one will be drawn on top. You can
 * use transparency to create layers this way.
 */
class Cell extends Configurable(CellImpl) {
    constructor(xOrConfig, y, width, height, index, solid, sprites) {
        super(xOrConfig, y, width, height, index, solid, sprites);
    }
}

;// CONCATENATED MODULE: ./Camera.ts








/**
 * Container to house convenience strategy methods
 * @internal
 */
class StrategyContainer {
    constructor(camera) {
        this.camera = camera;
    }
    /**
     * Creates and adds the [[LockCameraToActorStrategy]] on the current camera.
     * @param actor The actor to lock the camera to
     */
    lockToActor(actor) {
        this.camera.addStrategy(new LockCameraToActorStrategy(actor));
    }
    /**
     * Creates and adds the [[LockCameraToActorAxisStrategy]] on the current camera
     * @param actor The actor to lock the camera to
     * @param axis The axis to follow the actor on
     */
    lockToActorAxis(actor, axis) {
        this.camera.addStrategy(new LockCameraToActorAxisStrategy(actor, axis));
    }
    /**
     * Creates and adds the [[ElasticToActorStrategy]] on the current camera
     * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing
     * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over
     * correct and bounce around the target
     *
     * @param actor Target actor to elastically follow
     * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target
     * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target
     */
    elasticToActor(actor, cameraElasticity, cameraFriction) {
        this.camera.addStrategy(new ElasticToActorStrategy(actor, cameraElasticity, cameraFriction));
    }
    /**
     * Creates and adds the [[RadiusAroundActorStrategy]] on the current camera
     * @param actor Target actor to follow when it is "radius" pixels away
     * @param radius Number of pixels away before the camera will follow
     */
    radiusAroundActor(actor, radius) {
        this.camera.addStrategy(new RadiusAroundActorStrategy(actor, radius));
    }
    /**
     * Creates and adds the [[LimitCameraBoundsStrategy]] on the current camera
     * @param box The bounding box to limit the camera to.
     */
    limitCameraBounds(box) {
        this.camera.addStrategy(new LimitCameraBoundsStrategy(box));
    }
}
/**
 * Camera axis enum
 */
var Axis;
(function (Axis) {
    Axis[Axis["X"] = 0] = "X";
    Axis[Axis["Y"] = 1] = "Y";
})(Axis || (Axis = {}));
/**
 * Lock a camera to the exact x/y position of an actor.
 */
class LockCameraToActorStrategy {
    constructor(target) {
        this.target = target;
        this.action = (target, _cam, _eng, _delta) => {
            const center = target.center;
            return center;
        };
    }
}
/**
 * Lock a camera to a specific axis around an actor.
 */
class LockCameraToActorAxisStrategy {
    constructor(target, axis) {
        this.target = target;
        this.axis = axis;
        this.action = (target, cam, _eng, _delta) => {
            const center = target.center;
            const currentFocus = cam.getFocus();
            if (this.axis === Axis.X) {
                return new Vector(center.x, currentFocus.y);
            }
            else {
                return new Vector(currentFocus.x, center.y);
            }
        };
    }
}
/**
 * Using [Hook's law](https://en.wikipedia.org/wiki/Hooke's_law), elastically move the camera towards the target actor.
 */
class ElasticToActorStrategy {
    /**
     * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing
     * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over
     * correct and bounce around the target
     *
     * @param target Target actor to elastically follow
     * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target
     * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target
     */
    constructor(target, cameraElasticity, cameraFriction) {
        this.target = target;
        this.cameraElasticity = cameraElasticity;
        this.cameraFriction = cameraFriction;
        this.action = (target, cam, _eng, _delta) => {
            const position = target.center;
            let focus = cam.getFocus();
            let cameraVel = cam.vel.clone();
            // Calculate the stretch vector, using the spring equation
            // F = kX
            // https://en.wikipedia.org/wiki/Hooke's_law
            // Apply to the current camera velocity
            const stretch = position.sub(focus).scale(this.cameraElasticity); // stretch is X
            cameraVel = cameraVel.add(stretch);
            // Calculate the friction (-1 to apply a force in the opposition of motion)
            // Apply to the current camera velocity
            const friction = cameraVel.scale(-1).scale(this.cameraFriction);
            cameraVel = cameraVel.add(friction);
            // Update position by velocity deltas
            focus = focus.add(cameraVel);
            return focus;
        };
    }
}
class RadiusAroundActorStrategy {
    /**
     *
     * @param target Target actor to follow when it is "radius" pixels away
     * @param radius Number of pixels away before the camera will follow
     */
    constructor(target, radius) {
        this.target = target;
        this.radius = radius;
        this.action = (target, cam, _eng, _delta) => {
            const position = target.center;
            const focus = cam.getFocus();
            const direction = position.sub(focus);
            const distance = direction.size;
            if (distance >= this.radius) {
                const offset = distance - this.radius;
                return focus.add(direction.normalize().scale(offset));
            }
            return focus;
        };
    }
}
/**
 * Prevent a camera from going beyond the given camera dimensions.
 */
class LimitCameraBoundsStrategy {
    constructor(target) {
        this.target = target;
        /**
         * Useful for limiting the camera to a [[TileMap]]'s dimensions, or a specific area inside the map.
         *
         * Note that this strategy does not perform any movement by itself.
         * It only sets the camera position to within the given bounds when the camera has gone beyond them.
         * Thus, it is a good idea to combine it with other camera strategies and set this strategy as the last one.
         *
         * Make sure that the camera bounds are at least as large as the viewport size.
         *
         * @param target The bounding box to limit the camera to
         */
        this.boundSizeChecked = false; // Check and warn only once
        this.action = (target, cam, _eng, _delta) => {
            const focus = cam.getFocus();
            if (!this.boundSizeChecked) {
                if (target.bottom - target.top < _eng.drawHeight || target.right - target.left < _eng.drawWidth) {
                    Logger.getInstance().warn('Camera bounds should not be smaller than the engine viewport');
                }
                this.boundSizeChecked = true;
            }
            let focusX = focus.x;
            let focusY = focus.y;
            if (focus.x < target.left + _eng.halfDrawWidth) {
                focusX = target.left + _eng.halfDrawWidth;
            }
            else if (focus.x > target.right - _eng.halfDrawWidth) {
                focusX = target.right - _eng.halfDrawWidth;
            }
            if (focus.y < target.top + _eng.halfDrawHeight) {
                focusY = target.top + _eng.halfDrawHeight;
            }
            else if (focus.y > target.bottom - _eng.halfDrawHeight) {
                focusY = target.bottom - _eng.halfDrawHeight;
            }
            return vec(focusX, focusY);
        };
    }
}
/**
 * Cameras
 *
 * [[Camera]] is the base class for all Excalibur cameras. Cameras are used
 * to move around your game and set focus. They are used to determine
 * what is "off screen" and can be used to scale the game.
 *
 */
class Camera extends Class {
    constructor() {
        super(...arguments);
        this._cameraStrategies = [];
        this.strategy = new StrategyContainer(this);
        /**
         * Get or set current zoom of the camera, defaults to 1
         */
        this._z = 1;
        /**
         * Get or set rate of change in zoom, defaults to 0
         */
        this.dz = 0;
        /**
         * Get or set zoom acceleration
         */
        this.az = 0;
        /**
         * Current rotation of the camera
         */
        this.rotation = 0;
        /**
         * Current angular velocity
         */
        this.rx = 0;
        /**
         * Get or set the camera's position
         */
        this._posChanged = false;
        this._pos = watchAny(Vector.Zero, () => (this._posChanged = true));
        /**
         * Get or set the camera's velocity
         */
        this.vel = Vector.Zero;
        /**
         * GEt or set the camera's acceleration
         */
        this.acc = Vector.Zero;
        this._cameraMoving = false;
        this._currentLerpTime = 0;
        this._lerpDuration = 1000; // 1 second
        this._lerpStart = null;
        this._lerpEnd = null;
        //camera effects
        this._isShaking = false;
        this._shakeMagnitudeX = 0;
        this._shakeMagnitudeY = 0;
        this._shakeDuration = 0;
        this._elapsedShakeTime = 0;
        this._xShake = 0;
        this._yShake = 0;
        this._isZooming = false;
        this._zoomStart = 1;
        this._zoomEnd = 1;
        this._currentZoomTime = 0;
        this._zoomDuration = 0;
        this._zoomEasing = EasingFunctions.EaseInOutCubic;
        this._easing = EasingFunctions.EaseInOutCubic;
        this._halfWidth = 0;
        this._halfHeight = 0;
        this._viewport = null;
        this._isInitialized = false;
    }
    get zoom() {
        return this._z;
    }
    set zoom(val) {
        this._z = val;
        if (this._engine) {
            this._halfWidth = this._engine.halfDrawWidth;
            this._halfHeight = this._engine.halfDrawHeight;
        }
    }
    /**
     * Get or set the camera's angular velocity
     */
    get angularVelocity() {
        return this.rx;
    }
    set angularVelocity(value) {
        this.rx = value;
    }
    get pos() {
        return this._pos;
    }
    set pos(vec) {
        this._pos = watchAny(vec, () => (this._posChanged = true));
        this._posChanged = true;
    }
    /**
     * Get the camera's x position
     */
    get x() {
        return this.pos.x;
    }
    /**
     * Set the camera's x position (cannot be set when following an [[Actor]] or when moving)
     */
    set x(value) {
        if (!this._follow && !this._cameraMoving) {
            this.pos = vec(value, this.pos.y);
        }
    }
    /**
     * Get the camera's y position
     */
    get y() {
        return this.pos.y;
    }
    /**
     * Set the camera's y position (cannot be set when following an [[Actor]] or when moving)
     */
    set y(value) {
        if (!this._follow && !this._cameraMoving) {
            this.pos = vec(this.pos.x, value);
        }
    }
    /**
     * Get or set the camera's x velocity
     */
    get dx() {
        return this.vel.x;
    }
    set dx(value) {
        this.vel = vec(value, this.vel.y);
    }
    /**
     * Get or set the camera's y velocity
     */
    get dy() {
        return this.vel.y;
    }
    set dy(value) {
        this.vel = vec(this.vel.x, value);
    }
    /**
     * Get or set the camera's x acceleration
     */
    get ax() {
        return this.acc.x;
    }
    set ax(value) {
        this.acc = vec(value, this.acc.y);
    }
    /**
     * Get or set the camera's y acceleration
     */
    get ay() {
        return this.acc.y;
    }
    set ay(value) {
        this.acc = vec(this.acc.x, value);
    }
    /**
     * Returns the focal point of the camera, a new point giving the x and y position of the camera
     */
    getFocus() {
        return this.pos;
    }
    /**
     * This moves the camera focal point to the specified position using specified easing function. Cannot move when following an Actor.
     *
     * @param pos The target position to move to
     * @param duration The duration in milliseconds the move should last
     * @param [easingFn] An optional easing function ([[ex.EasingFunctions.EaseInOutCubic]] by default)
     * @returns A [[Promise]] that resolves when movement is finished, including if it's interrupted.
     *          The [[Promise]] value is the [[Vector]] of the target position. It will be rejected if a move cannot be made.
     */
    move(pos, duration, easingFn = EasingFunctions.EaseInOutCubic) {
        if (typeof easingFn !== 'function') {
            throw 'Please specify an EasingFunction';
        }
        // cannot move when following an actor
        if (this._follow) {
            return Promise.reject(pos);
        }
        // resolve existing promise, if any
        if (this._lerpPromise && this._lerpResolve) {
            this._lerpResolve(pos);
        }
        this._lerpPromise = new Promise((resolve) => {
            this._lerpResolve = resolve;
        });
        this._lerpStart = this.getFocus().clone();
        this._lerpDuration = duration;
        this._lerpEnd = pos;
        this._currentLerpTime = 0;
        this._cameraMoving = true;
        this._easing = easingFn;
        return this._lerpPromise;
    }
    /**
     * Sets the camera to shake at the specified magnitudes for the specified duration
     * @param magnitudeX  The x magnitude of the shake
     * @param magnitudeY  The y magnitude of the shake
     * @param duration    The duration of the shake in milliseconds
     */
    shake(magnitudeX, magnitudeY, duration) {
        this._isShaking = true;
        this._shakeMagnitudeX = magnitudeX;
        this._shakeMagnitudeY = magnitudeY;
        this._shakeDuration = duration;
    }
    /**
     * Zooms the camera in or out by the specified scale over the specified duration.
     * If no duration is specified, it take effect immediately.
     * @param scale    The scale of the zoom
     * @param duration The duration of the zoom in milliseconds
     */
    zoomOverTime(scale, duration = 0, easingFn = EasingFunctions.EaseInOutCubic) {
        this._zoomPromise = new Promise((resolve) => {
            this._zoomResolve = resolve;
        });
        if (duration) {
            this._isZooming = true;
            this._zoomEasing = easingFn;
            this._currentZoomTime = 0;
            this._zoomDuration = duration;
            this._zoomStart = this.zoom;
            this._zoomEnd = scale;
        }
        else {
            this._isZooming = false;
            this.zoom = scale;
            return Promise.resolve(true);
        }
        return this._zoomPromise;
    }
    /**
     * Gets the bounding box of the viewport of this camera in world coordinates
     */
    get viewport() {
        if (this._viewport) {
            return this._viewport;
        }
        return new BoundingBox(0, 0, 0, 0);
    }
    /**
     * Adds a new camera strategy to this camera
     * @param cameraStrategy Instance of an [[CameraStrategy]]
     */
    addStrategy(cameraStrategy) {
        this._cameraStrategies.push(cameraStrategy);
    }
    /**
     * Removes a camera strategy by reference
     * @param cameraStrategy Instance of an [[CameraStrategy]]
     */
    removeStrategy(cameraStrategy) {
        removeItemFromArray(cameraStrategy, this._cameraStrategies);
    }
    /**
     * Clears all camera strategies from the camera
     */
    clearAllStrategies() {
        this._cameraStrategies.length = 0;
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event
     * @internal
     */
    _preupdate(engine, delta) {
        this.emit('preupdate', new PreUpdateEvent(engine, delta, this));
        this.onPreUpdate(engine, delta);
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before a scene is updated.
     */
    onPreUpdate(_engine, _delta) {
        // Overridable
    }
    /**
     *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event
     * @internal
     */
    _postupdate(engine, delta) {
        this.emit('postupdate', new PostUpdateEvent(engine, delta, this));
        this.onPostUpdate(engine, delta);
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after a scene is updated.
     */
    onPostUpdate(_engine, _delta) {
        // Overridable
    }
    get isInitialized() {
        return this._isInitialized;
    }
    _initialize(_engine) {
        if (!this.isInitialized) {
            this._engine = _engine;
            const currentRes = this._engine.screen.resolution;
            let center = vec(currentRes.width / 2, currentRes.height / 2);
            if (!this._engine.loadingComplete) {
                // If there was a loading screen, we peek the configured resolution
                const res = this._engine.screen.peekResolution();
                if (res) {
                    center = vec(res.width / 2, res.height / 2);
                }
            }
            this._halfWidth = center.x;
            this._halfHeight = center.x;
            // If the user has not set the camera pos, apply default center screen position
            if (!this._posChanged) {
                this.pos = center;
            }
            this.onInitialize(_engine);
            super.emit('initialize', new InitializeEvent(_engine, this));
            this._isInitialized = true;
        }
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after a scene is updated.
     */
    onInitialize(_engine) {
        // Overridable
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    off(eventName, handler) {
        super.off(eventName, handler);
    }
    once(eventName, handler) {
        super.once(eventName, handler);
    }
    update(_engine, delta) {
        this._initialize(_engine);
        this._preupdate(_engine, delta);
        // Update placements based on linear algebra
        this.pos = this.pos.add(this.vel.scale(delta / 1000));
        this.zoom += (this.dz * delta) / 1000;
        this.vel = this.vel.add(this.acc.scale(delta / 1000));
        this.dz += (this.az * delta) / 1000;
        this.rotation += (this.angularVelocity * delta) / 1000;
        if (this._isZooming) {
            if (this._currentZoomTime < this._zoomDuration) {
                const zoomEasing = this._zoomEasing;
                const newZoom = zoomEasing(this._currentZoomTime, this._zoomStart, this._zoomEnd, this._zoomDuration);
                this.zoom = newZoom;
                this._currentZoomTime += delta;
            }
            else {
                this._isZooming = false;
                this.zoom = this._zoomEnd;
                this._currentZoomTime = 0;
                this._zoomResolve(true);
            }
        }
        if (this._cameraMoving) {
            if (this._currentLerpTime < this._lerpDuration) {
                const moveEasing = EasingFunctions.CreateVectorEasingFunction(this._easing);
                const lerpPoint = moveEasing(this._currentLerpTime, this._lerpStart, this._lerpEnd, this._lerpDuration);
                this.pos = lerpPoint;
                this._currentLerpTime += delta;
            }
            else {
                this.pos = this._lerpEnd;
                const end = this._lerpEnd.clone();
                this._lerpStart = null;
                this._lerpEnd = null;
                this._currentLerpTime = 0;
                this._cameraMoving = false;
                // Order matters here, resolve should be last so any chain promises have a clean slate
                this._lerpResolve(end);
            }
        }
        if (this._isDoneShaking()) {
            this._isShaking = false;
            this._elapsedShakeTime = 0;
            this._shakeMagnitudeX = 0;
            this._shakeMagnitudeY = 0;
            this._shakeDuration = 0;
            this._xShake = 0;
            this._yShake = 0;
        }
        else {
            this._elapsedShakeTime += delta;
            this._xShake = ((Math.random() * this._shakeMagnitudeX) | 0) + 1;
            this._yShake = ((Math.random() * this._shakeMagnitudeY) | 0) + 1;
        }
        for (const s of this._cameraStrategies) {
            this.pos = s.action.call(s, s.target, this, _engine, delta);
        }
        this._viewport = new BoundingBox(this.x - this._halfWidth, this.y - this._halfHeight, this.x + this._halfWidth, this.y + this._halfHeight);
        this._postupdate(_engine, delta);
    }
    draw(ctx) {
        let canvasWidth = 0;
        let canvasHeight = 0;
        if (ctx instanceof CanvasRenderingContext2D) {
            canvasWidth = ctx.canvas.width;
            canvasHeight = ctx.canvas.height;
        }
        else {
            canvasWidth = ctx.width;
            canvasHeight = ctx.height;
        }
        const focus = this.getFocus();
        const pixelRatio = this._engine ? this._engine.pixelRatio : 1;
        const zoom = this.zoom;
        const newCanvasWidth = canvasWidth / zoom / pixelRatio;
        const newCanvasHeight = canvasHeight / zoom / pixelRatio;
        ctx.scale(zoom, zoom);
        ctx.translate(-focus.x + newCanvasWidth / 2 + this._xShake, -focus.y + newCanvasHeight / 2 + this._yShake);
    }
    /* istanbul ignore next */
    debugDraw(_ctx) {
        // pass
    }
    _isDoneShaking() {
        return !this._isShaking || this._elapsedShakeTime >= this._shakeDuration;
    }
}

;// CONCATENATED MODULE: ./Util/Actors.ts



/**
 * Type guard to detect if something is an actor
 * @deprecated Will be removed in v0.26.0
 * @param actor
 */
function isVanillaActor(actor) {
    return !(actor instanceof ScreenElement) && !(actor instanceof Trigger) && !(actor instanceof Label);
}
/**
 * Type guard to detect a screen element
 * @todo move to ScreenElement
 */
function isScreenElement(actor) {
    return actor instanceof ScreenElement_ScreenElement;
}

;// CONCATENATED MODULE: ./Trigger.ts







const triggerDefaults = {
    pos: Vector.Zero,
    width: 10,
    height: 10,
    visible: false,
    action: () => {
        return;
    },
    filter: () => true,
    repeat: -1
};
/**
 * Triggers are a method of firing arbitrary code on collision. These are useful
 * as 'buttons', 'switches', or to trigger effects in a game. By default triggers
 * are invisible, and can only be seen when [[Trigger.visible]] is set to `true`.
 */
class Trigger_Trigger extends Actor {
    /**
     *
     * @param opts Trigger options
     */
    constructor(opts) {
        super({ x: opts.pos.x, y: opts.pos.y, width: opts.width, height: opts.height });
        /**
         * Action to fire when triggered by collision
         */
        this.action = () => {
            return;
        };
        /**
         * Filter to add additional granularity to action dispatch, if a filter is specified the action will only fire when
         * filter return true for the collided actor.
         */
        this.filter = () => true;
        /**
         * Number of times to repeat before killing the trigger,
         */
        this.repeat = -1;
        opts = extend({}, triggerDefaults, opts);
        this.filter = opts.filter || this.filter;
        this.repeat = opts.repeat || this.repeat;
        this.action = opts.action || this.action;
        if (opts.target) {
            this.target = opts.target;
        }
        this.graphics.visible = opts.visible;
        this.body.collisionType = CollisionType.Passive;
        this.eventDispatcher = new EventDispatcher(this);
        this.events.on('collisionstart', (evt) => {
            if (this.filter(evt.other)) {
                this.emit('enter', new EnterTriggerEvent(this, evt.other));
                this._dispatchAction();
                // remove trigger if its done, -1 repeat forever
                if (this.repeat === 0) {
                    this.kill();
                }
            }
        });
        this.events.on('collisionend', (evt) => {
            if (this.filter(evt.other)) {
                this.emit('exit', new ExitTriggerEvent(this, evt.other));
            }
        });
    }
    set target(target) {
        this._target = target;
        this.filter = (actor) => actor === target;
    }
    get target() {
        return this._target;
    }
    _initialize(engine) {
        super._initialize(engine);
    }
    _dispatchAction() {
        if (this.repeat !== 0) {
            this.action.call(this);
            this.repeat--;
        }
    }
    /* istanbul ignore next */
    debugDraw(ctx) {
        super.debugDraw(ctx);
        // Meant to draw debug information about actors
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        const bb = this.collider.bounds;
        const wp = this.getGlobalPos();
        bb.left = bb.left - wp.x;
        bb.right = bb.right - wp.x;
        bb.top = bb.top - wp.y;
        bb.bottom = bb.bottom - wp.y;
        ctx.fillStyle = Color.Violet.toString();
        ctx.strokeStyle = Color.Violet.toString();
        ctx.fillText('Trigger', 10, 10);
        bb.debugDraw(ctx);
        ctx.restore();
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/System.ts
/**
 * Enum that determines whether to run the system in the update or draw phase
 */
var SystemType;
(function (SystemType) {
    SystemType["Update"] = "update";
    SystemType["Draw"] = "draw";
})(SystemType || (SystemType = {}));
/**
 * An Excalibur [[System]] that updates entities of certain types.
 * Systems are scene specific
 *
 * Excalibur Systems currently require at least 1 Component type to operated
 *
 * Multiple types are declared as a type union
 * For example:
 *
 * ```typescript
 * class MySystem extends System<ComponentA | ComponentB> {
 *   public readonly types = ['a', 'b'] as const;
 *   public readonly systemType = SystemType.Update;
 *   public update(entities: Entity<ComponentA | ComponentB>) {
 *      ...
 *   }
 * }
 * ```
 */
class System {
    constructor() {
        /**
         * System can execute in priority order, by default all systems are priority 0. Lower values indicated higher priority.
         * For a system to execute before all other a lower priority value (-1 for example) must be set.
         * For a system to exectue after all other a higher priority value (10 for example) must be set.
         */
        this.priority = 0;
    }
    /**
     * Systems observe when entities match their types or no longer match their types, override
     * @param _entityAddedOrRemoved
     */
    notify(_entityAddedOrRemoved) {
        // Override me
    }
}
/**
 * An [[Entity]] with [[Component]] types that matches a [[System]] types exists in the current scene.
 */
class AddedEntity {
    constructor(data) {
        this.data = data;
        this.type = 'Entity Added';
    }
}
/**
 * Type guard to check for AddedEntity messages
 * @param x
 */
function isAddedSystemEntity(x) {
    return !!x && x.type === 'Entity Added';
}
/**
 * An [[Entity]] with [[Component]] types that no longer matches a [[System]] types exists in the current scene.
 */
class RemovedEntity {
    constructor(data) {
        this.data = data;
        this.type = 'Entity Removed';
    }
}
/**
 * type guard to check for the RemovedEntity message
 */
function isRemoveSystemEntity(x) {
    return !!x && x.type === 'Entity Removed';
}

;// CONCATENATED MODULE: ./EntityComponentSystem/EntityManager.ts


// Add/Remove entitys and components
class EntityManager {
    constructor(_world) {
        this._world = _world;
        this.entities = [];
        this._entityIndex = {};
        this._entitiesToRemove = [];
    }
    /**
     * Runs the entity lifecycle
     * @param _context
     */
    updateEntities(_context, elapsed) {
        for (const entity of this.entities) {
            // TODO is this right?
            entity.update(_context.engine, elapsed);
            if (!entity.active) {
                this.removeEntity(entity);
            }
        }
    }
    findEntitiesForRemoval() {
        for (const entity of this.entities) {
            if (!entity.active) {
                this.removeEntity(entity);
            }
        }
    }
    /**
     * EntityManager observes changes on entities
     * @param message
     */
    notify(message) {
        if (isAddedComponent(message)) {
            // we don't need the component, it's already on the entity
            this._world.queryManager.addEntity(message.data.entity);
        }
        if (isRemovedComponent(message)) {
            this._world.queryManager.removeComponent(message.data.entity, message.data.component);
        }
    }
    /**
     * Adds an entity to be tracked by the EntityManager
     * @param entity
     */
    addEntity(entity) {
        entity.active = true;
        if (entity && !this._entityIndex[entity.id]) {
            this._entityIndex[entity.id] = entity;
            this.entities.push(entity);
            this._world.queryManager.addEntity(entity);
            entity.componentAdded$.register(this);
            entity.componentRemoved$.register(this);
            // if entity has children
            entity.children.forEach((c) => this.addEntity(c));
            entity.childrenAdded$.register({
                notify: (e) => {
                    this.addEntity(e);
                }
            });
            entity.childrenRemoved$.register({
                notify: (e) => {
                    this.removeEntity(e, false);
                }
            });
        }
    }
    removeEntity(idOrEntity, deferred = true) {
        var _a;
        let id = 0;
        if (idOrEntity instanceof Entity) {
            id = idOrEntity.id;
        }
        else {
            id = idOrEntity;
        }
        const entity = this._entityIndex[id];
        if (entity && entity.active) {
            entity.kill();
        }
        if (entity && deferred) {
            this._entitiesToRemove.push(entity);
            return;
        }
        delete this._entityIndex[id];
        if (entity) {
            removeItemFromArray(entity, this.entities);
            this._world.queryManager.removeEntity(entity);
            entity.componentAdded$.unregister(this);
            entity.componentRemoved$.unregister(this);
            // if entity has children
            entity.children.forEach((c) => this.removeEntity(c, deferred));
            entity.childrenAdded$.clear();
            entity.childrenRemoved$.clear();
            // stats
            if ((_a = this._world.context) === null || _a === void 0 ? void 0 : _a.engine) {
                this._world.context.engine.stats.currFrame.actors.killed++;
            }
        }
    }
    processEntityRemovals() {
        for (const entity of this._entitiesToRemove) {
            if (entity.active) {
                continue;
            }
            this.removeEntity(entity, false);
        }
    }
    processComponentRemovals() {
        for (const entity of this.entities) {
            entity.processComponentRemoval();
        }
    }
    getById(id) {
        return this._entityIndex[id];
    }
    getByName(name) {
        return this.entities.filter(e => e.name === name);
    }
    clear() {
        for (const entity of this.entities) {
            this.removeEntity(entity);
        }
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/Util.ts
const buildTypeKey = (types) => {
    const key = [...types].sort((a, b) => a.localeCompare(b)).join('+');
    return key;
};

;// CONCATENATED MODULE: ./EntityComponentSystem/Query.ts





/**
 * Represents query for entities that match a list of types that is cached and observable
 *
 * Queries can be strongly typed by supplying a type union in the optional type parameter
 * ```typescript
 * const queryAB = new ex.Query<ComponentTypeA | ComponentTypeB>(['A', 'B']);
 * ```
 */
class Query extends Observable {
    constructor(types) {
        super();
        this._entities = [];
        if (types[0] instanceof Function) {
            this.types = types.map(T => (new T).type);
        }
        else {
            this.types = types;
        }
    }
    get key() {
        if (this._key) {
            return this._key;
        }
        return (this._key = buildTypeKey(this.types));
    }
    /**
     * Returns a list of entities that match the query
     *
     * @param sort Optional sorting function to sort entities returned from the query
     */
    getEntities(sort) {
        if (sort) {
            this._entities.sort(sort);
        }
        return this._entities;
    }
    /**
     * Add an entity to the query, will only be added if the entity matches the query types
     * @param entity
     */
    addEntity(entity) {
        if (!contains(this._entities, entity) && this.matches(entity)) {
            this._entities.push(entity);
            this.notifyAll(new AddedEntity(entity));
        }
    }
    /**
     * If the entity is part of the query it will be removed regardless of types
     * @param entity
     */
    removeEntity(entity) {
        if (removeItemFromArray(entity, this._entities)) {
            this.notifyAll(new RemovedEntity(entity));
        }
    }
    /**
     * Removes all entities and observers from the query
     */
    clear() {
        this._entities.length = 0;
        for (const observer of this.observers) {
            this.unregister(observer);
        }
    }
    matches(typesOrEntity) {
        let types = [];
        if (typesOrEntity instanceof Entity) {
            types = typesOrEntity.types;
        }
        else {
            types = typesOrEntity;
        }
        let matches = true;
        for (const type of this.types) {
            matches = matches && types.indexOf(type) > -1;
            if (!matches) {
                return false;
            }
        }
        return matches;
    }
    contain(type) {
        return this.types.indexOf(type) > -1;
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/QueryManager.ts


/**
 * The query manager is responsible for updating all queries when entities/components change
 */
class QueryManager {
    constructor(_world) {
        this._world = _world;
        this._queries = {};
    }
    /**
     * Adds a query to the manager and populates with any entities that match
     * @param query
     */
    _addQuery(query) {
        this._queries[buildTypeKey(query.types)] = query;
        for (const entity of this._world.entityManager.entities) {
            query.addEntity(entity);
        }
    }
    /**
     * Removes the query if there are no observers left
     * @param query
     */
    maybeRemoveQuery(query) {
        if (query.observers.length === 0) {
            query.clear();
            delete this._queries[buildTypeKey(query.types)];
        }
    }
    /**
     * Adds the entity to any matching query in the query manage
     * @param entity
     */
    addEntity(entity) {
        for (const queryType in this._queries) {
            if (this._queries[queryType]) {
                this._queries[queryType].addEntity(entity);
            }
        }
    }
    /**
     * Removes an entity from queries if the removed component disqualifies it
     * @param entity
     * @param component
     */
    removeComponent(entity, component) {
        for (const queryType in this._queries) {
            // If the component being removed from an entity is a part of a query,
            // it is now disqualified from that query, remove it
            if (this._queries[queryType].contain(component.type)) {
                this._queries[queryType].removeEntity(entity);
            }
        }
    }
    /**
     * Removes an entity from all queries it is currently a part of
     * @param entity
     */
    removeEntity(entity) {
        for (const queryType in this._queries) {
            this._queries[queryType].removeEntity(entity);
        }
    }
    /**
     * Creates a populated query and returns, if the query already exists that will be returned instead of a new instance
     * @param types
     */
    createQuery(types) {
        const maybeExistingQuery = this.getQuery(types);
        if (maybeExistingQuery) {
            return maybeExistingQuery;
        }
        const query = new Query(types);
        this._addQuery(query);
        return query;
    }
    /**
     * Retrieves an existing query by types if it exists otherwise returns null
     * @param types
     */
    getQuery(types) {
        const key = buildTypeKey(types);
        if (this._queries[key]) {
            return this._queries[key];
        }
        return null;
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/SystemManager.ts

/**
 * The SystemManager is responsible for keeping track of all systems in a scene.
 * Systems are scene specific
 */
class SystemManager {
    constructor(_world) {
        this._world = _world;
        /**
         * List of systems, to add a new system call [[SystemManager.addSystem]]
         */
        this.systems = [];
        this.initialized = false;
    }
    /**
     * Get a system registered in the manager by type
     * @param systemType
     * @returns
     */
    get(systemType) {
        return this.systems.find((s) => s instanceof systemType);
    }
    /**
     * Adds a system to the manager, it will now be updated every frame
     * @param system
     */
    addSystem(system) {
        // validate system has types
        if (!system.types || system.types.length === 0) {
            throw new Error(`Attempted to add a System without any types`);
        }
        const query = this._world.queryManager.createQuery(system.types);
        this.systems.push(system);
        this.systems.sort((a, b) => a.priority - b.priority);
        query.register(system);
        if (this.initialized && system.initialize) {
            system.initialize(this._world.context);
        }
    }
    /**
     * Removes a system from the manager, it will no longer be updated
     * @param system
     */
    removeSystem(system) {
        removeItemFromArray(system, this.systems);
        const query = this._world.queryManager.getQuery(system.types);
        if (query) {
            query.unregister(system);
            this._world.queryManager.maybeRemoveQuery(query);
        }
    }
    /**
     * Updates all systems
     * @param type whether this is an update or draw system
     * @param context context reference
     * @param delta time in milliseconds
     */
    updateSystems(type, context, delta) {
        if (!this.initialized) {
            this.initialized = true;
            for (const s of this.systems) {
                if (s.initialize) {
                    s.initialize(this._world.context);
                }
            }
        }
        const systems = this.systems.filter((s) => s.systemType === type);
        for (const s of systems) {
            if (s.preupdate) {
                s.preupdate(context, delta);
            }
        }
        for (const s of systems) {
            // Get entities that match the system types, pre-sort
            const entities = this._world.queryManager.getQuery(s.types).getEntities(s.sort);
            // Initialize entities if needed
            if (context instanceof Scene) {
                for (const entity of entities) {
                    entity._initialize(context === null || context === void 0 ? void 0 : context.engine);
                }
            }
            s.update(entities, delta);
        }
        for (const s of systems) {
            if (s.postupdate) {
                s.postupdate(context, delta);
            }
        }
    }
    clear() {
        for (const system of this.systems) {
            this.removeSystem(system);
        }
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/World.ts





/**
 * The World is a self-contained entity component system for a particular context.
 */
class World {
    /**
     * The context type is passed to the system updates
     * @param context
     */
    constructor(context) {
        this.context = context;
        this.queryManager = new QueryManager(this);
        this.entityManager = new EntityManager(this);
        this.systemManager = new SystemManager(this);
    }
    /**
     * Update systems by type and time elapsed in milliseconds
     */
    update(type, delta) {
        if (type === SystemType.Update) {
            this.entityManager.updateEntities(this.context, delta);
        }
        this.systemManager.updateSystems(type, this.context, delta);
        this.entityManager.findEntitiesForRemoval();
        this.entityManager.processComponentRemovals();
        this.entityManager.processEntityRemovals();
    }
    add(entityOrSystem) {
        if (entityOrSystem instanceof Entity) {
            this.entityManager.addEntity(entityOrSystem);
        }
        if (entityOrSystem instanceof System) {
            this.systemManager.addSystem(entityOrSystem);
        }
    }
    remove(entityOrSystem, deferred = true) {
        if (entityOrSystem instanceof Entity) {
            this.entityManager.removeEntity(entityOrSystem, deferred);
        }
        if (entityOrSystem instanceof System) {
            this.systemManager.removeSystem(entityOrSystem);
        }
    }
    clearEntities() {
        this.entityManager.clear();
    }
    clearSystems() {
        this.systemManager.clear();
    }
}

;// CONCATENATED MODULE: ./Collision/Integrator.ts
class EulerIntegrator {
    static integrate(transform, motion, totalAcc, elapsedMs) {
        const seconds = elapsedMs / 1000;
        motion.vel.addEqual(totalAcc.scale(seconds));
        transform.pos.addEqual(motion.vel.scale(seconds)).addEqual(totalAcc.scale(0.5 * seconds * seconds));
        motion.angularVelocity += motion.torque * (1.0 / motion.inertia) * seconds;
        transform.rotation += motion.angularVelocity * seconds;
        transform.scale.addEqual(motion.scaleFactor.scale(seconds));
    }
}

;// CONCATENATED MODULE: ./Collision/MotionSystem.ts







class MotionSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.transform', 'ex.motion'];
        this.systemType = SystemType.Update;
        this.priority = -1;
    }
    update(_entities, elapsedMs) {
        let transform;
        let motion;
        for (const entity of _entities) {
            transform = entity.get(TransformComponent);
            motion = entity.get(MotionComponent);
            const optionalBody = entity.get(BodyComponent);
            if (optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.sleeping) {
                continue;
            }
            const totalAcc = motion.acc.clone();
            if ((optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.collisionType) === CollisionType.Active && (optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.useGravity)) {
                totalAcc.addEqual(Physics.gravity);
            }
            optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.captureOldTransform();
            // Update transform and motion based on Euler linear algebra
            EulerIntegrator.integrate(transform, motion, totalAcc, elapsedMs);
        }
    }
    debugDraw(_ctx) {
        // pass
    }
}

;// CONCATENATED MODULE: ./Collision/Solver/Solver.ts
/**
 * A collision solver figures out how to position colliders such that they are no longer overlapping
 *
 * Solvers are executed in the order
 *
 * 1. preSolve
 * 2. solveVelocity
 * 3. solvePosition
 * 4. postSolve
 * @inheritdoc
 */
class CollisionSolver {
    /**
     * Solves overlapping contact in
     *
     * Solvers are executed in the order
     * 1. preSolve
     * 2. solveVelocity
     * 3. solvePosition
     * 4. postSolve
     * @param contacts
     */
    solve(contacts) {
        // Events and init
        this.preSolve(contacts);
        // Remove any canceled contacts
        contacts = contacts.filter(c => !c.isCanceled());
        // Solve velocity first
        this.solveVelocity(contacts);
        // Solve position last because non-overlap is the most important
        this.solvePosition(contacts);
        // Events and any contact house-keeping the solver needs
        this.postSolve(contacts);
        return contacts;
    }
}

;// CONCATENATED MODULE: ./Collision/Solver/ArcadeSolver.ts





/**
 * ArcadeSolver is the default in Excalibur. It solves collisions so that there is no overlap between contacts,
 * and negates velocity along the collision normal.
 *
 * This is usually the type of collisions used for 2D games that don't need a more realistic collision simulation.
 *
 */
class ArcadeSolver extends CollisionSolver {
    preSolve(contacts) {
        for (const contact of contacts) {
            const side = Side.fromDirection(contact.mtv);
            const mtv = contact.mtv.negate();
            // Publish collision events on both participants
            contact.colliderA.events.emit('precollision', new PreCollisionEvent(contact.colliderA, contact.colliderB, side, mtv));
            contact.colliderB.events.emit('precollision', new PreCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), mtv.negate()));
        }
    }
    postSolve(contacts) {
        var _a, _b;
        for (const contact of contacts) {
            const colliderA = contact.colliderA;
            const colliderB = contact.colliderB;
            const bodyA = (_a = colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
            const bodyB = (_b = colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
            if (bodyA && bodyB) {
                if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
                    continue;
                }
            }
            const side = Side.fromDirection(contact.mtv);
            const mtv = contact.mtv.negate();
            // Publish collision events on both participants
            contact.colliderA.events.emit('postcollision', new PostCollisionEvent(contact.colliderA, contact.colliderB, side, mtv));
            contact.colliderB.events.emit('postcollision', new PostCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), mtv.negate()));
        }
    }
    solvePosition(contacts) {
        var _a, _b;
        for (const contact of contacts) {
            let mtv = contact.mtv;
            const colliderA = contact.colliderA;
            const colliderB = contact.colliderB;
            const bodyA = (_a = colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
            const bodyB = (_b = colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
            if (bodyA && bodyB) {
                if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
                    continue;
                }
                if (bodyA.collisionType === CollisionType.Active && bodyB.collisionType === CollisionType.Active) {
                    // split overlaps if both are Active
                    mtv = mtv.scale(0.5);
                }
                // Resolve overlaps
                if (bodyA.collisionType === CollisionType.Active) {
                    bodyA.pos.x -= mtv.x;
                    bodyA.pos.y -= mtv.y;
                }
                if (bodyB.collisionType === CollisionType.Active) {
                    bodyB.pos.x += mtv.x;
                    bodyB.pos.y += mtv.y;
                }
            }
        }
    }
    solveVelocity(contacts) {
        var _a, _b;
        for (const contact of contacts) {
            const colliderA = contact.colliderA;
            const colliderB = contact.colliderB;
            const bodyA = (_a = colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
            const bodyB = (_b = colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
            if (bodyA && bodyB) {
                if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
                    continue;
                }
                const normal = contact.normal;
                const opposite = normal.negate();
                // Cancel out velocity opposite direction of collision normal
                if (bodyA.collisionType === CollisionType.Active) {
                    const velAdj = normal.scale(normal.dot(bodyA.vel.negate()));
                    bodyA.vel = bodyA.vel.add(velAdj);
                }
                if (bodyB.collisionType === CollisionType.Active) {
                    const velAdj = opposite.scale(opposite.dot(bodyB.vel.negate()));
                    bodyB.vel = bodyB.vel.add(velAdj);
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./Collision/Solver/ContactConstraintPoint.ts


/**
 * Holds information about contact points, meant to be reused over multiple frames of contact
 */
class ContactConstraintPoint {
    constructor(point, local, contact) {
        this.point = point;
        this.local = local;
        this.contact = contact;
        /**
         * Impulse accumulated over time in normal direction
         */
        this.normalImpulse = 0;
        /**
         * Impulse accumulated over time in the tangent direction
         */
        this.tangentImpulse = 0;
        /**
         * Effective mass seen in the normal direction
         */
        this.normalMass = 0;
        /**
         * Effective mass seen in the tangent direction
         */
        this.tangentMass = 0;
        /**
         * Direction from center of mass of bodyA to contact point
         */
        this.aToContact = new Vector(0, 0);
        /**
         * Direction from center of mass of bodyB to contact point
         */
        this.bToContact = new Vector(0, 0);
        this.update();
    }
    /**
     * Updates the contact information
     */
    update() {
        var _a, _b;
        const bodyA = (_a = this.contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
        const bodyB = (_b = this.contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
        if (bodyA && bodyB) {
            const normal = this.contact.normal;
            const tangent = this.contact.tangent;
            this.aToContact = this.point.sub(bodyA.pos);
            this.bToContact = this.point.sub(bodyB.pos);
            const aToContactNormal = this.aToContact.cross(normal);
            const bToContactNormal = this.bToContact.cross(normal);
            this.normalMass =
                bodyA.inverseMass +
                    bodyB.inverseMass +
                    bodyA.inverseInertia * aToContactNormal * aToContactNormal +
                    bodyB.inverseInertia * bToContactNormal * bToContactNormal;
            const aToContactTangent = this.aToContact.cross(tangent);
            const bToContactTangent = this.bToContact.cross(tangent);
            this.tangentMass =
                bodyA.inverseMass +
                    bodyB.inverseMass +
                    bodyA.inverseInertia * aToContactTangent * aToContactTangent +
                    bodyB.inverseInertia * bToContactTangent * bToContactTangent;
        }
        return this;
    }
    /**
     * Returns the relative velocity betwen bodyA and bodyB
     */
    getRelativeVelocity() {
        var _a, _b;
        const bodyA = (_a = this.contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
        const bodyB = (_b = this.contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
        if (bodyA && bodyB) {
            // Relative velocity in linear terms
            // Angular to linear velocity formula -> omega = velocity/radius so omega x radius = velocity
            const velA = bodyA.vel.add(Vector.cross(bodyA.angularVelocity, this.aToContact));
            const velB = bodyB.vel.add(Vector.cross(bodyB.angularVelocity, this.bToContact));
            return velB.sub(velA);
        }
        return Vector.Zero;
    }
}

;// CONCATENATED MODULE: ./Collision/Solver/RealisticSolver.ts









class RealisticSolver extends CollisionSolver {
    constructor() {
        super(...arguments);
        this.lastFrameContacts = new Map();
        // map contact id to contact points
        this.idToContactConstraint = new Map();
    }
    getContactConstraints(id) {
        var _a;
        return (_a = this.idToContactConstraint.get(id)) !== null && _a !== void 0 ? _a : [];
    }
    preSolve(contacts) {
        var _a, _b, _c;
        for (const contact of contacts) {
            // Publish collision events on both participants
            const side = Side.fromDirection(contact.mtv);
            contact.colliderA.events.emit('precollision', new PreCollisionEvent(contact.colliderA, contact.colliderB, side, contact.mtv));
            contact.colliderA.events.emit('beforecollisionresolve', new CollisionPreSolveEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact));
            contact.colliderB.events.emit('precollision', new PreCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate()));
            contact.colliderB.events.emit('beforecollisionresolve', new CollisionPreSolveEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate(), contact));
            // Match awake state for sleeping
            contact.matchAwake();
        }
        // Keep track of contacts that done
        const finishedContactIds = Array.from(this.idToContactConstraint.keys());
        for (const contact of contacts) {
            // Remove all current contacts that are not done
            const index = finishedContactIds.indexOf(contact.id);
            if (index > -1) {
                finishedContactIds.splice(index, 1);
            }
            const contactPoints = (_a = this.idToContactConstraint.get(contact.id)) !== null && _a !== void 0 ? _a : [];
            let pointIndex = 0;
            const bodyA = contact.colliderA.owner.get(BodyComponent);
            const bodyB = contact.colliderB.owner.get(BodyComponent);
            if (bodyA && bodyB) {
                for (const point of contact.points) {
                    const normal = contact.normal;
                    const tangent = contact.tangent;
                    const aToContact = point.sub(bodyA.pos);
                    const bToContact = point.sub(bodyB.pos);
                    const aToContactNormal = aToContact.cross(normal);
                    const bToContactNormal = bToContact.cross(normal);
                    const normalMass = bodyA.inverseMass +
                        bodyB.inverseMass +
                        bodyA.inverseInertia * aToContactNormal * aToContactNormal +
                        bodyB.inverseInertia * bToContactNormal * bToContactNormal;
                    const aToContactTangent = aToContact.cross(tangent);
                    const bToContactTangent = bToContact.cross(tangent);
                    const tangentMass = bodyA.inverseMass +
                        bodyB.inverseMass +
                        bodyA.inverseInertia * aToContactTangent * aToContactTangent +
                        bodyB.inverseInertia * bToContactTangent * bToContactTangent;
                    // Preserve normal/tangent impulse by re-using the contact point if it's close
                    if (contactPoints[pointIndex] && ((_c = (_b = contactPoints[pointIndex]) === null || _b === void 0 ? void 0 : _b.point) === null || _c === void 0 ? void 0 : _c.squareDistance(point)) < 4) {
                        contactPoints[pointIndex].point = point;
                        contactPoints[pointIndex].local = contact.localPoints[pointIndex];
                    }
                    else {
                        // new contact if it's not close or doesn't exist
                        contactPoints[pointIndex] = new ContactConstraintPoint(point, contact.localPoints[pointIndex], contact);
                    }
                    // Update contact point calculations
                    contactPoints[pointIndex].aToContact = aToContact;
                    contactPoints[pointIndex].bToContact = bToContact;
                    contactPoints[pointIndex].normalMass = normalMass;
                    contactPoints[pointIndex].tangentMass = tangentMass;
                    pointIndex++;
                }
            }
            this.idToContactConstraint.set(contact.id, contactPoints);
        }
        // Clean up any contacts that did not occur last frame
        for (const id of finishedContactIds) {
            this.idToContactConstraint.delete(id);
        }
        // Warm contacts with accumulated impulse
        // Useful for tall stacks
        if (Physics.warmStart) {
            this.warmStart(contacts);
        }
        else {
            for (const contact of contacts) {
                const contactPoints = this.getContactConstraints(contact.id);
                for (const point of contactPoints) {
                    point.normalImpulse = 0;
                    point.tangentImpulse = 0;
                }
            }
        }
    }
    postSolve(contacts) {
        for (const contact of contacts) {
            const bodyA = contact.colliderA.owner.get(BodyComponent);
            const bodyB = contact.colliderB.owner.get(BodyComponent);
            if (bodyA && bodyB) {
                // Skip post solve for active+passive collisions
                if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
                    continue;
                }
                // Update motion values for sleeping
                bodyA.updateMotion();
                bodyB.updateMotion();
            }
            // Publish collision events on both participants
            const side = Side.fromDirection(contact.mtv);
            contact.colliderA.events.emit('postcollision', new PostCollisionEvent(contact.colliderA, contact.colliderB, side, contact.mtv));
            contact.colliderA.events.emit('aftercollisionresolve', new CollisionPostSolveEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact));
            contact.colliderB.events.emit('postcollision', new PostCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate()));
            contact.colliderB.events.emit('aftercollisionresolve', new CollisionPostSolveEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate(), contact));
        }
        // Store contacts
        this.lastFrameContacts.clear();
        for (const c of contacts) {
            this.lastFrameContacts.set(c.id, c);
        }
    }
    /**
     * Warm up body's based on previous frame contact points
     * @param contacts
     */
    warmStart(contacts) {
        var _a, _b, _c;
        for (const contact of contacts) {
            const bodyA = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
            const bodyB = (_b = contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
            if (bodyA && bodyB) {
                const contactPoints = (_c = this.idToContactConstraint.get(contact.id)) !== null && _c !== void 0 ? _c : [];
                for (const point of contactPoints) {
                    if (Physics.warmStart) {
                        const normalImpulse = contact.normal.scale(point.normalImpulse);
                        const tangentImpulse = contact.tangent.scale(point.tangentImpulse);
                        const impulse = normalImpulse.add(tangentImpulse);
                        bodyA.applyImpulse(point.point, impulse.negate());
                        bodyB.applyImpulse(point.point, impulse);
                    }
                    else {
                        point.normalImpulse = 0;
                        point.tangentImpulse = 0;
                    }
                }
            }
        }
    }
    /**
     * Iteratively solve the position overlap constraint
     * @param contacts
     */
    solvePosition(contacts) {
        var _a, _b, _c;
        for (let i = 0; i < Physics.positionIterations; i++) {
            for (const contact of contacts) {
                const bodyA = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
                const bodyB = (_b = contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
                if (bodyA && bodyB) {
                    // Skip solving active+passive
                    if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
                        continue;
                    }
                    const constraints = (_c = this.idToContactConstraint.get(contact.id)) !== null && _c !== void 0 ? _c : [];
                    for (const point of constraints) {
                        const normal = contact.normal;
                        const separation = CollisionJumpTable.FindContactSeparation(contact, point.local);
                        const steeringConstant = Physics.steeringFactor; //0.2;
                        const maxCorrection = -5;
                        const slop = Physics.slop; //1;
                        // Clamp to avoid over-correction
                        // Remember that we are shooting for 0 overlap in the end
                        const steeringForce = clamp(steeringConstant * (separation + slop), maxCorrection, 0);
                        const impulse = normal.scale(-steeringForce / point.normalMass);
                        // This is a pseudo impulse, meaning we aren't doing a real impulse calculation
                        // We adjust position and rotation instead of doing the velocity
                        if (bodyA.collisionType === CollisionType.Active) {
                            bodyA.pos = bodyA.pos.add(impulse.negate().scale(bodyA.inverseMass));
                            bodyA.rotation -= point.aToContact.cross(impulse) * bodyA.inverseInertia;
                        }
                        if (bodyB.collisionType === CollisionType.Active) {
                            bodyB.pos = bodyB.pos.add(impulse.scale(bodyB.inverseMass));
                            bodyB.rotation += point.bToContact.cross(impulse) * bodyB.inverseInertia;
                        }
                    }
                }
            }
        }
    }
    solveVelocity(contacts) {
        var _a, _b, _c;
        for (let i = 0; i < Physics.velocityIterations; i++) {
            for (const contact of contacts) {
                const bodyA = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
                const bodyB = (_b = contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
                if (bodyA && bodyB) {
                    // Skip solving active+passive
                    if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
                        continue;
                    }
                    const restitution = bodyA.bounciness * bodyB.bounciness;
                    const friction = Math.min(bodyA.friction, bodyB.friction);
                    const constraints = (_c = this.idToContactConstraint.get(contact.id)) !== null && _c !== void 0 ? _c : [];
                    for (const point of constraints) {
                        const relativeVelocity = point.getRelativeVelocity();
                        // Negate velocity in tangent direction to simulate friction
                        const tangentVelocity = -relativeVelocity.dot(contact.tangent);
                        let impulseDelta = tangentVelocity / point.tangentMass;
                        // Clamping based in Erin Catto's GDC 2006 talk
                        // Correct clamping https://github.com/erincatto/box2d-lite/blob/master/docs/GDC2006_Catto_Erin_PhysicsTutorial.pdf
                        // Accumulated fiction impulse is always between -uMaxFriction < dT < uMaxFriction
                        // But deltas can vary
                        const maxFriction = friction * point.normalImpulse;
                        const newImpulse = clamp(point.tangentImpulse + impulseDelta, -maxFriction, maxFriction);
                        impulseDelta = newImpulse - point.tangentImpulse;
                        point.tangentImpulse = newImpulse;
                        const impulse = contact.tangent.scale(impulseDelta);
                        bodyA.applyImpulse(point.point, impulse.negate());
                        bodyB.applyImpulse(point.point, impulse);
                    }
                    for (const point of constraints) {
                        // Need to recalc relative velocity because the previous step could have changed vel
                        const relativeVelocity = point.getRelativeVelocity();
                        // Compute impulse in normal direction
                        const normalVelocity = relativeVelocity.dot(contact.normal);
                        // See https://en.wikipedia.org/wiki/Collision_response
                        let impulseDelta = (-(1 + restitution) * normalVelocity) / point.normalMass;
                        // Clamping based in Erin Catto's GDC 2014 talk
                        // Accumulated impulse stored in the contact is always positive (dV > 0)
                        // But deltas can be negative
                        const newImpulse = Math.max(point.normalImpulse + impulseDelta, 0);
                        impulseDelta = newImpulse - point.normalImpulse;
                        point.normalImpulse = newImpulse;
                        const impulse = contact.normal.scale(impulseDelta);
                        bodyA.applyImpulse(point.point, impulse.negate());
                        bodyB.applyImpulse(point.point, impulse);
                    }
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./Collision/CollisionSystem.ts








class CollisionSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.transform', 'ex.motion', 'ex.collider'];
        this.systemType = SystemType.Update;
        this.priority = -1;
        this._realisticSolver = new RealisticSolver();
        this._arcadeSolver = new ArcadeSolver();
        this._processor = new DynamicTreeCollisionProcessor();
        this._lastFrameContacts = new Map();
        this._currentFrameContacts = new Map();
        this._trackCollider = (c) => this._processor.track(c);
        this._untrackCollider = (c) => this._processor.untrack(c);
    }
    notify(message) {
        if (isAddedSystemEntity(message)) {
            const colliderComponent = message.data.get(ColliderComponent);
            colliderComponent.$colliderAdded.subscribe(this._trackCollider);
            colliderComponent.$colliderRemoved.subscribe(this._untrackCollider);
            const collider = colliderComponent.get();
            if (collider) {
                this._processor.track(collider);
            }
        }
        else {
            const colliderComponent = message.data.get(ColliderComponent);
            const collider = colliderComponent.get();
            if (colliderComponent && collider) {
                this._processor.untrack(collider);
            }
        }
    }
    initialize(scene) {
        this._engine = scene.engine;
    }
    update(_entities, elapsedMs) {
        var _a;
        if (!Physics.enabled) {
            return;
        }
        // Collect up all the colliders
        let colliders = [];
        for (const entity of _entities) {
            const colliderComp = entity.get(ColliderComponent);
            const collider = colliderComp === null || colliderComp === void 0 ? void 0 : colliderComp.get();
            if (colliderComp && ((_a = colliderComp.owner) === null || _a === void 0 ? void 0 : _a.active) && collider) {
                colliderComp.update();
                if (collider instanceof CompositeCollider) {
                    colliders = colliders.concat(collider.getColliders());
                }
                else {
                    colliders.push(collider);
                }
            }
        }
        // Update the spatial partitioning data structures
        // TODO if collider invalid it will break the processor
        // TODO rename "update" to something more specific
        this._processor.update(colliders);
        // Run broadphase on all colliders and locates potential collisions
        const pairs = this._processor.broadphase(colliders, elapsedMs);
        this._currentFrameContacts.clear();
        // Given possible pairs find actual contacts
        let contacts = this._processor.narrowphase(pairs, this._engine.debug.stats.currFrame);
        const solver = this.getSolver();
        // Solve, this resolves the position/velocity so entities arent overlapping
        contacts = solver.solve(contacts);
        // Record contacts
        contacts.forEach((c) => this._currentFrameContacts.set(c.id, c));
        // Emit contact start/end events
        this.runContactStartEnd();
        // reset the last frame cache
        this._lastFrameContacts.clear();
        // Keep track of collisions contacts that have started or ended
        this._lastFrameContacts = new Map(this._currentFrameContacts);
    }
    getSolver() {
        return Physics.collisionResolutionStrategy === CollisionResolutionStrategy.Realistic ? this._realisticSolver : this._arcadeSolver;
    }
    debug(ex) {
        this._processor.debug(ex);
    }
    runContactStartEnd() {
        for (const [id, c] of this._currentFrameContacts) {
            // find all new contacts
            if (!this._lastFrameContacts.has(id)) {
                const colliderA = c.colliderA;
                const colliderB = c.colliderB;
                colliderA.events.emit('collisionstart', new CollisionStartEvent(colliderA, colliderB, c));
                colliderA.events.emit('contactstart', new ContactStartEvent(colliderA, colliderB, c));
                colliderB.events.emit('collisionstart', new CollisionStartEvent(colliderB, colliderA, c));
                colliderB.events.emit('contactstart', new ContactStartEvent(colliderB, colliderA, c));
            }
        }
        // find all contacts taht have ceased
        for (const [id, c] of this._lastFrameContacts) {
            if (!this._currentFrameContacts.has(id)) {
                const colliderA = c.colliderA;
                const colliderB = c.colliderB;
                colliderA.events.emit('collisionend', new CollisionEndEvent(colliderA, colliderB));
                colliderA.events.emit('contactend', new ContactEndEvent(colliderA, colliderB));
                colliderB.events.emit('collisionend', new CollisionEndEvent(colliderB, colliderA));
                colliderB.events.emit('contactend', new ContactEndEvent(colliderB, colliderA));
            }
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/Animation.ts






var AnimationDirection;
(function (AnimationDirection) {
    /**
     * Animation is playing forwards
     */
    AnimationDirection["Forward"] = "forward";
    /**
     * Animation is play backwards
     */
    AnimationDirection["Backward"] = "backward";
})(AnimationDirection || (AnimationDirection = {}));
var AnimationStrategy;
(function (AnimationStrategy) {
    /**
     * Animation ends without displaying anything
     */
    AnimationStrategy["End"] = "end";
    /**
     * Animation loops to the first frame after the last frame
     */
    AnimationStrategy["Loop"] = "loop";
    /**
     * Animation plays to the last frame, then backwards to the first frame, then repeats
     */
    AnimationStrategy["PingPong"] = "pingpong";
    /**
     * Animation ends stopping on the last frame
     */
    AnimationStrategy["Freeze"] = "freeze";
})(AnimationStrategy || (AnimationStrategy = {}));
/**
 * Create an Animation given a list of [[Frame|frames]] in [[AnimationOptions]]
 *
 * To create an Animation from a [[SpriteSheet]], use [[Animation.fromSpriteSheet]]
 */
class Animation extends Graphic {
    constructor(options) {
        var _a, _b;
        super(options);
        this.events = new EventDispatcher(this); // TODO replace with new Emitter
        this.frames = [];
        this.strategy = AnimationStrategy.Loop;
        this.frameDuration = 100;
        this.timeScale = 1;
        this._idempotencyToken = -1;
        this._firstTick = true;
        this._currentFrame = 0;
        this._timeLeftInFrame = 0;
        this._direction = 1; // TODO only used in ping-pong
        this._done = false;
        this._playing = true;
        this._reversed = false;
        this.frames = options.frames;
        this.strategy = (_a = options.strategy) !== null && _a !== void 0 ? _a : this.strategy;
        this.frameDuration = options.totalDuration ? options.totalDuration / this.frames.length : (_b = options.frameDuration) !== null && _b !== void 0 ? _b : this.frameDuration;
        if (options.reverse) {
            this.reverse();
        }
        this.goToFrame(0);
    }
    clone() {
        return new Animation(Object.assign({ frames: this.frames.map((f) => (Object.assign({}, f))), frameDuration: this.frameDuration, reverse: this._reversed, strategy: this.strategy }, this.cloneGraphicOptions()));
    }
    /**
     * Create an Animation from a [[SpriteSheet]], a list of indices into the sprite sheet, a duration per frame
     * and optional [[AnimationStrategy]]
     *
     * Example:
     * ```typescript
     * const spriteSheet = SpriteSheet.fromImageSource({...});
     *
     * const anim = Animation.fromSpriteSheet(spriteSheet, range(0, 5), 200, AnimationStrategy.Loop);
     * ```
     *
     * @param spriteSheet
     * @param frameIndices
     * @param durationPerFrameMs
     * @param strategy
     */
    static fromSpriteSheet(spriteSheet, frameIndices, durationPerFrameMs, strategy = AnimationStrategy.Loop) {
        const maxIndex = spriteSheet.sprites.length - 1;
        const invalidIndices = frameIndices.filter((index) => index < 0 || index > maxIndex);
        if (invalidIndices.length) {
            Animation._LOGGER.warn(`Indices into SpriteSheet were provided that don\'t exist: ${invalidIndices.join(',')} no frame will be shown`);
        }
        return new Animation({
            frames: spriteSheet.sprites
                .filter((_, index) => frameIndices.indexOf(index) > -1)
                .map((f) => ({
                graphic: f,
                duration: durationPerFrameMs
            })),
            strategy: strategy
        });
    }
    /**
     * Converts an animation to a legacy animation
     * @deprecated
     * @param engine
     * @param animation
     * @returns LegacyDrawing.Animation
     */
    static toLegacyAnimation(engine, animation) {
        const legacySprites = animation.frames.map(f => Sprite.toLegacySprite(f.graphic));
        return new Animation_Animation({
            sprites: legacySprites,
            loop: animation.strategy === AnimationStrategy.Loop,
            freezeFrame: animation.strategy === AnimationStrategy.Freeze ? legacySprites.length - 1 : undefined,
            speed: animation.frameDuration,
            engine: engine
        });
    }
    /**
     * Returns the current Frame of the animation
     */
    get currentFrame() {
        if (this._currentFrame >= 0 && this._currentFrame < this.frames.length) {
            return this.frames[this._currentFrame];
        }
        return null;
    }
    /**
     * Returns the current frame index of the animation
     */
    get currentFrameIndex() {
        return this._currentFrame;
    }
    /**
     * Returns `true` if the animation is playing
     */
    get isPlaying() {
        return this._playing;
    }
    /**
     * Reverses the play direction of the Animation, this preserves the current frame
     */
    reverse() {
        // Don't mutate with the original frame list, create a copy
        this.frames = this.frames.slice().reverse();
        this._reversed = !this._reversed;
    }
    /**
     * Returns the current play direction of the animation
     */
    get direction() {
        // Keep logically consistent with ping-pong direction
        // If ping-pong is forward = 1 and reversed is true then we are logically reversed
        const reversed = (this._reversed && this._direction === 1) ? true : false;
        return reversed ? AnimationDirection.Backward : AnimationDirection.Forward;
    }
    /**
     * Plays or resumes the animation from the current frame
     */
    play() {
        this._playing = true;
    }
    /**
     * Pauses the animation on the current frame
     */
    pause() {
        this._playing = false;
        this._firstTick = true; // firstTick must be set to emit the proper frame event
    }
    /**
     * Reset the animation back to the beginning, including if the animation were done
     */
    reset() {
        this._done = false;
        this._firstTick = true;
        this._currentFrame = 0;
    }
    /**
     * Returns `true` if the animation can end
     */
    get canFinish() {
        switch (this.strategy) {
            case AnimationStrategy.End:
            case AnimationStrategy.Freeze: {
                return true;
            }
            default: {
                return false;
            }
        }
    }
    /**
     * Returns `true` if the animation is done, for looping type animations
     * `ex.AnimationStrategy.PingPong` and `ex.AnimationStrategy.Loop` this will always return `false`
     *
     * See the `ex.Animation.canFinish()` method to know if an animation type can end
     */
    get done() {
        return this._done;
    }
    /**
     * Jump the animation immediately to a specific frame if it exists
     * @param frameNumber
     */
    goToFrame(frameNumber) {
        var _a, _b;
        this._currentFrame = frameNumber;
        this._timeLeftInFrame = this.frameDuration;
        const maybeFrame = this.frames[this._currentFrame];
        if (maybeFrame && !this._done) {
            this._timeLeftInFrame = (maybeFrame === null || maybeFrame === void 0 ? void 0 : maybeFrame.duration) || this.frameDuration;
            this.width = (_a = maybeFrame.graphic) === null || _a === void 0 ? void 0 : _a.width;
            this.height = (_b = maybeFrame.graphic) === null || _b === void 0 ? void 0 : _b.height;
            this.events.emit('frame', maybeFrame);
        }
    }
    _nextFrame() {
        const currentFrame = this._currentFrame;
        if (this._done) {
            return currentFrame;
        }
        let next = -1;
        switch (this.strategy) {
            case AnimationStrategy.Loop: {
                next = (currentFrame + 1) % this.frames.length;
                if (next === 0) {
                    this.events.emit('loop', this);
                }
                break;
            }
            case AnimationStrategy.End: {
                next = currentFrame + 1;
                if (next >= this.frames.length) {
                    this._done = true;
                    this._currentFrame = this.frames.length;
                    this.events.emit('end', this);
                }
                break;
            }
            case AnimationStrategy.Freeze: {
                next = clamp(currentFrame + 1, 0, this.frames.length - 1);
                if (next >= this.frames.length - 1) {
                    this._done = true;
                    this.events.emit('end', this);
                }
                break;
            }
            case AnimationStrategy.PingPong: {
                if (currentFrame + this._direction >= this.frames.length) {
                    this._direction = -1;
                    this.events.emit('loop', this);
                }
                if (currentFrame + this._direction < 0) {
                    this._direction = 1;
                    this.events.emit('loop', this);
                }
                next = currentFrame + (this._direction % this.frames.length);
                break;
            }
        }
        return next;
    }
    /**
     * Called internally by Excalibur to update the state of the animation potential update the current frame
     * @param elapsedMilliseconds Milliseconds elapsed
     * @param idempotencyToken Prevents double ticking in a frame by passing a unique token to the frame
     */
    tick(elapsedMilliseconds, idempotencyToken = 0) {
        if (this._idempotencyToken === idempotencyToken) {
            return;
        }
        this._idempotencyToken = idempotencyToken;
        if (!this._playing) {
            return;
        }
        // if it's the first frame emit frame event
        if (this._firstTick) {
            this._firstTick = false;
            this.events.emit('frame', this.currentFrame);
        }
        this._timeLeftInFrame -= elapsedMilliseconds * this.timeScale;
        if (this._timeLeftInFrame <= 0) {
            this.goToFrame(this._nextFrame());
        }
        this._updateDimensions();
    }
    _updateDimensions() {
        var _a, _b;
        if (this.currentFrame) {
            this.width = (_a = this.currentFrame.graphic) === null || _a === void 0 ? void 0 : _a.width;
            this.height = (_b = this.currentFrame.graphic) === null || _b === void 0 ? void 0 : _b.height;
        }
    }
    _drawImage(ctx, x, y) {
        if (this.currentFrame) {
            this.currentFrame.graphic.draw(ctx, x, y);
        }
    }
}
Animation._LOGGER = Logger.getInstance();

;// CONCATENATED MODULE: ./Graphics/GraphicsGroup.ts



class GraphicsGroup extends Graphic {
    constructor(options) {
        super(options);
        this.members = [];
        this.members = options.members;
        this._updateDimensions();
    }
    clone() {
        return new GraphicsGroup(Object.assign({ members: [...this.members] }, this.cloneGraphicOptions()));
    }
    _updateDimensions() {
        let bb = new BoundingBox();
        for (const { graphic, pos } of this.members) {
            bb = graphic.localBounds.translate(pos).combine(bb);
        }
        this.width = bb.width;
        this.height = bb.height;
        return bb;
    }
    get localBounds() {
        let bb = new BoundingBox();
        for (const { graphic, pos } of this.members) {
            bb = graphic.localBounds.translate(pos).combine(bb);
        }
        return bb;
    }
    _isAnimationOrGroup(graphic) {
        return graphic instanceof Animation || graphic instanceof GraphicsGroup;
    }
    tick(elapsedMilliseconds, idempotencyToken) {
        for (const member of this.members) {
            const maybeAnimation = member.graphic;
            if (this._isAnimationOrGroup(maybeAnimation)) {
                maybeAnimation.tick(elapsedMilliseconds, idempotencyToken);
            }
        }
    }
    reset() {
        for (const member of this.members) {
            const maybeAnimation = member.graphic;
            if (this._isAnimationOrGroup(maybeAnimation)) {
                maybeAnimation.reset();
            }
        }
    }
    _preDraw(ex, x, y) {
        this._updateDimensions();
        super._preDraw(ex, x, y);
    }
    _drawImage(ex, x, y) {
        for (const member of this.members) {
            ex.save();
            ex.translate(x, y);
            member.graphic.draw(ex, member.pos.x, member.pos.y);
            if (this.showDebug) {
                /* istanbul ignore next */
                ex.debug.drawRect(0, 0, this.width, this.height);
            }
            ex.restore();
        }
    }
}

;// CONCATENATED MODULE: ./Particles.ts














/**
 * An enum that represents the types of emitter nozzles
 */
var EmitterType;
(function (EmitterType) {
    /**
     * Constant for the circular emitter type
     */
    EmitterType[EmitterType["Circle"] = 0] = "Circle";
    /**
     * Constant for the rectangular emitter type
     */
    EmitterType[EmitterType["Rectangle"] = 1] = "Rectangle";
})(EmitterType || (EmitterType = {}));
/**
 * @hidden
 */
class ParticleImpl extends Entity {
    constructor(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) {
        super();
        this.position = new Vector(0, 0);
        this.velocity = new Vector(0, 0);
        this.acceleration = new Vector(0, 0);
        this.particleRotationalVelocity = 0;
        this.currentRotation = 0;
        this.focus = null;
        this.focusAccel = 0;
        this.opacity = 1;
        this.beginColor = Color.White;
        this.endColor = Color.White;
        // Life is counted in ms
        this.life = 300;
        this.fadeFlag = false;
        // Color transitions
        this._rRate = 1;
        this._gRate = 1;
        this._bRate = 1;
        this._aRate = 0;
        this._currentColor = Color.White;
        this.emitter = null;
        this.particleSize = 5;
        this.particleSprite = null;
        this.sizeRate = 0;
        this.elapsedMultiplier = 0;
        this.visible = true;
        this.isOffscreen = false;
        let emitter = emitterOrConfig;
        if (emitter && !(emitterOrConfig instanceof ParticleEmitter)) {
            const config = emitterOrConfig;
            emitter = config.emitter;
            life = config.life;
            opacity = config.opacity;
            endColor = config.endColor;
            beginColor = config.beginColor;
            position = config.position;
            velocity = config.velocity;
            acceleration = config.acceleration;
            startSize = config.startSize;
            endSize = config.endSize;
        }
        this.emitter = emitter;
        this.life = life || this.life;
        this.opacity = opacity || this.opacity;
        this.endColor = endColor || this.endColor.clone();
        this.beginColor = beginColor || this.beginColor.clone();
        this._currentColor = this.beginColor.clone();
        this.position = (position || this.position).add(this.emitter.pos);
        this.velocity = velocity || this.velocity;
        this.acceleration = acceleration || this.acceleration;
        this._rRate = (this.endColor.r - this.beginColor.r) / this.life;
        this._gRate = (this.endColor.g - this.beginColor.g) / this.life;
        this._bRate = (this.endColor.b - this.beginColor.b) / this.life;
        this._aRate = this.opacity / this.life;
        this.startSize = startSize || 0;
        this.endSize = endSize || 0;
        if (this.endSize > 0 && this.startSize > 0) {
            this.sizeRate = (this.endSize - this.startSize) / this.life;
            this.particleSize = this.startSize;
        }
        this.addComponent((this.transform = new TransformComponent()));
        this.addComponent(new CanvasDrawComponent((ctx) => this.draw(ctx)));
        this.addComponent((this.graphics = new GraphicsComponent()));
        this.transform.pos = this.position;
        this.transform.rotation = this.currentRotation;
        this.transform.scale = vec(1, 1); // TODO wut
        if (this.particleSprite) {
            this.graphics.opacity = this.opacity;
            this.graphics.use(Sprite.fromLegacySprite(this.particleSprite));
        }
        else {
            this.graphics.onPostDraw = (ctx) => {
                ctx.save();
                this.graphics.opacity = this.opacity;
                const tmpColor = this._currentColor.clone();
                tmpColor.a = 1;
                ctx.debug.drawPoint(vec(0, 0), { color: tmpColor, size: this.particleSize });
                ctx.restore();
            };
        }
    }
    kill() {
        this.emitter.removeParticle(this);
    }
    update(_engine, delta) {
        this.life = this.life - delta;
        this.elapsedMultiplier = this.elapsedMultiplier + delta;
        if (this.life < 0) {
            this.kill();
        }
        if (this.fadeFlag) {
            this.opacity = clamp(this._aRate * this.life, 0.0001, 1);
        }
        if (this.startSize > 0 && this.endSize > 0) {
            this.particleSize = clamp(this.sizeRate * delta + this.particleSize, Math.min(this.startSize, this.endSize), Math.max(this.startSize, this.endSize));
        }
        this._currentColor.r = clamp(this._currentColor.r + this._rRate * delta, 0, 255);
        this._currentColor.g = clamp(this._currentColor.g + this._gRate * delta, 0, 255);
        this._currentColor.b = clamp(this._currentColor.b + this._bRate * delta, 0, 255);
        this._currentColor.a = clamp(this.opacity, 0.0001, 1);
        if (this.focus) {
            const accel = this.focus
                .sub(this.position)
                .normalize()
                .scale(this.focusAccel)
                .scale(delta / 1000);
            this.velocity = this.velocity.add(accel);
        }
        else {
            this.velocity = this.velocity.add(this.acceleration.scale(delta / 1000));
        }
        this.position = this.position.add(this.velocity.scale(delta / 1000));
        if (this.particleRotationalVelocity) {
            this.currentRotation = (this.currentRotation + (this.particleRotationalVelocity * delta) / 1000) % (2 * Math.PI);
        }
        this.transform.pos = this.position;
        this.transform.rotation = this.currentRotation;
        this.transform.scale = vec(1, 1); // todo wut
        this.graphics.opacity = this.opacity;
    }
    draw(ctx) {
        if (this.particleSprite) {
            this.particleSprite.opacity(this.opacity);
            this.particleSprite.draw(ctx, 0, 0);
            return;
        }
        ctx.save();
        this._currentColor.a = clamp(this.opacity, 0.0001, 1);
        ctx.fillStyle = this._currentColor.toString();
        ctx.beginPath();
        ctx.arc(0, 0, this.particleSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();
        ctx.restore();
    }
}
/**
 * Particle is used in a [[ParticleEmitter]]
 */
class Particle extends Configurable(ParticleImpl) {
    constructor(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) {
        super(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize);
    }
}
/**
 * Using a particle emitter is a great way to create interesting effects
 * in your game, like smoke, fire, water, explosions, etc. `ParticleEmitter`
 * extend [[Actor]] allowing you to use all of the features that come with.
 */
class ParticleEmitter extends Actor {
    /**
     * @param config particle emitter options bag
     */
    constructor(config) {
        var _a, _b;
        super({ width: (_a = config.width) !== null && _a !== void 0 ? _a : 0, height: (_b = config.height) !== null && _b !== void 0 ? _b : 0 });
        this._particlesToEmit = 0;
        this.numParticles = 0;
        /**
         * Gets or sets the isEmitting flag
         */
        this.isEmitting = true;
        /**
         * Gets or sets the backing particle collection
         */
        this.particles = [];
        /**
         * Gets or sets the backing deadParticle collection
         */
        this.deadParticles = [];
        /**
         * Gets or sets the minimum particle velocity
         */
        this.minVel = 0;
        /**
         * Gets or sets the maximum particle velocity
         */
        this.maxVel = 0;
        /**
         * Gets or sets the acceleration vector for all particles
         */
        this.acceleration = new Vector(0, 0);
        /**
         * Gets or sets the minimum angle in radians
         */
        this.minAngle = 0;
        /**
         * Gets or sets the maximum angle in radians
         */
        this.maxAngle = 0;
        /**
         * Gets or sets the emission rate for particles (particles/sec)
         */
        this.emitRate = 1; //particles/sec
        /**
         * Gets or sets the life of each particle in milliseconds
         */
        this.particleLife = 2000;
        /**
         * Gets or sets the fade flag which causes particles to gradually fade out over the course of their life.
         */
        this.fadeFlag = false;
        /**
         * Gets or sets the optional focus where all particles should accelerate towards
         */
        this.focus = null;
        /**
         * Gets or sets the acceleration for focusing particles if a focus has been specified
         */
        this.focusAccel = null;
        /**
         * Gets or sets the optional starting size for the particles
         */
        this.startSize = null;
        /**
         * Gets or sets the optional ending size for the particles
         */
        this.endSize = null;
        /**
         * Gets or sets the minimum size of all particles
         */
        this.minSize = 5;
        /**
         * Gets or sets the maximum size of all particles
         */
        this.maxSize = 5;
        /**
         * Gets or sets the beginning color of all particles
         */
        this.beginColor = Color.White;
        /**
         * Gets or sets the ending color of all particles
         */
        this.endColor = Color.White;
        this._og = null;
        this._sprite = null;
        /**
         * Gets or sets the emitter type for the particle emitter
         */
        this.emitterType = EmitterType.Rectangle;
        /**
         * Gets or sets the emitter radius, only takes effect when the [[emitterType]] is [[EmitterType.Circle]]
         */
        this.radius = 0;
        /**
         * Gets or sets the particle rotational speed velocity
         */
        this.particleRotationalVelocity = 0;
        /**
         * Indicates whether particles should start with a random rotation
         */
        this.randomRotation = false;
        const { x, y, pos, isEmitting, minVel, maxVel, acceleration, minAngle, maxAngle, emitRate, particleLife, opacity, fadeFlag, focus, focusAccel, startSize, endSize, minSize, maxSize, beginColor, endColor, particleSprite, emitterType, radius, particleRotationalVelocity, randomRotation, random } = Object.assign({}, config);
        this.pos = pos !== null && pos !== void 0 ? pos : vec(x !== null && x !== void 0 ? x : 0, y !== null && y !== void 0 ? y : 0);
        this.isEmitting = isEmitting !== null && isEmitting !== void 0 ? isEmitting : this.isEmitting;
        this.minVel = minVel !== null && minVel !== void 0 ? minVel : this.minVel;
        this.maxVel = maxVel !== null && maxVel !== void 0 ? maxVel : this.maxVel;
        this.acceleration = acceleration !== null && acceleration !== void 0 ? acceleration : this.acceleration;
        this.minAngle = minAngle !== null && minAngle !== void 0 ? minAngle : this.minAngle;
        this.maxAngle = maxAngle !== null && maxAngle !== void 0 ? maxAngle : this.maxAngle;
        this.emitRate = emitRate !== null && emitRate !== void 0 ? emitRate : this.emitRate;
        this.particleLife = particleLife !== null && particleLife !== void 0 ? particleLife : this.particleLife;
        this.opacity = opacity !== null && opacity !== void 0 ? opacity : this.opacity;
        this.fadeFlag = fadeFlag !== null && fadeFlag !== void 0 ? fadeFlag : this.fadeFlag;
        this.focus = focus !== null && focus !== void 0 ? focus : this.focus;
        this.focusAccel = focusAccel !== null && focusAccel !== void 0 ? focusAccel : this.focusAccel;
        this.startSize = startSize !== null && startSize !== void 0 ? startSize : this.startSize;
        this.endSize = endSize !== null && endSize !== void 0 ? endSize : this.endSize;
        this.minSize = minSize !== null && minSize !== void 0 ? minSize : this.minSize;
        this.maxSize = maxSize !== null && maxSize !== void 0 ? maxSize : this.maxSize;
        this.beginColor = beginColor !== null && beginColor !== void 0 ? beginColor : this.beginColor;
        this.endColor = endColor !== null && endColor !== void 0 ? endColor : this.endColor;
        this.particleSprite = particleSprite !== null && particleSprite !== void 0 ? particleSprite : this.particleSprite;
        this.emitterType = emitterType !== null && emitterType !== void 0 ? emitterType : this.emitterType;
        this.radius = radius !== null && radius !== void 0 ? radius : this.radius;
        this.particleRotationalVelocity = particleRotationalVelocity !== null && particleRotationalVelocity !== void 0 ? particleRotationalVelocity : this.particleRotationalVelocity;
        this.randomRotation = randomRotation !== null && randomRotation !== void 0 ? randomRotation : this.randomRotation;
        this.body.collisionType = CollisionType.PreventCollision;
        this.random = random !== null && random !== void 0 ? random : new Random();
        // Remove offscreen culling from particle emitters
        for (let i = 0; i < this.traits.length; i++) {
            if (this.traits[i] instanceof OffscreenCulling) {
                this.traits.splice(i, 1);
            }
        }
    }
    /**
     * Gets the opacity of each particle from 0 to 1.0
     */
    get opacity() {
        return super.graphics.opacity;
    }
    /**
     * Gets the opacity of each particle from 0 to 1.0
     */
    set opacity(opacity) {
        super.graphics.opacity = opacity;
    }
    /**
     * Gets or sets the sprite that a particle should use
     */
    get particleSprite() {
        return this._og;
    }
    set particleSprite(val) {
        this._og = val;
        if (val) {
            this._sprite = Sprite.fromLegacySprite(val);
        }
    }
    removeParticle(particle) {
        this.deadParticles.push(particle);
    }
    /**
     * Causes the emitter to emit particles
     * @param particleCount  Number of particles to emit right now
     */
    emitParticles(particleCount) {
        var _a;
        for (let i = 0; i < particleCount; i++) {
            const p = this._createParticle();
            this.particles.push(p);
            if ((_a = this === null || this === void 0 ? void 0 : this.scene) === null || _a === void 0 ? void 0 : _a.world) {
                this.scene.world.add(p);
            }
        }
    }
    clearParticles() {
        this.particles.length = 0;
    }
    // Creates a new particle given the constraints of the emitter
    _createParticle() {
        // todo implement emitter constraints;
        let ranX = 0;
        let ranY = 0;
        const angle = randomInRange(this.minAngle, this.maxAngle, this.random);
        const vel = randomInRange(this.minVel, this.maxVel, this.random);
        const size = this.startSize || randomInRange(this.minSize, this.maxSize, this.random);
        const dx = vel * Math.cos(angle);
        const dy = vel * Math.sin(angle);
        if (this.emitterType === EmitterType.Rectangle) {
            ranX = randomInRange(0, this.width, this.random);
            ranY = randomInRange(0, this.height, this.random);
        }
        else if (this.emitterType === EmitterType.Circle) {
            const radius = randomInRange(0, this.radius, this.random);
            ranX = radius * Math.cos(angle);
            ranY = radius * Math.sin(angle);
        }
        const p = new Particle(this, this.particleLife, this.opacity, this.beginColor, this.endColor, new Vector(ranX, ranY), new Vector(dx, dy), this.acceleration, this.startSize, this.endSize);
        p.fadeFlag = this.fadeFlag;
        p.particleSize = size;
        if (this.particleSprite) {
            p.particleSprite = this.particleSprite;
            p.graphics.opacity = this.opacity;
            p.graphics.use(this._sprite);
        }
        p.particleRotationalVelocity = this.particleRotationalVelocity;
        if (this.randomRotation) {
            p.currentRotation = randomInRange(0, Math.PI * 2, this.random);
        }
        if (this.focus) {
            p.focus = this.focus.add(new Vector(this.pos.x, this.pos.y));
            p.focusAccel = this.focusAccel;
        }
        return p;
    }
    update(engine, delta) {
        var _a;
        super.update(engine, delta);
        if (this.isEmitting) {
            this._particlesToEmit += this.emitRate * (delta / 1000);
            if (this._particlesToEmit > 1.0) {
                this.emitParticles(Math.floor(this._particlesToEmit));
                this._particlesToEmit = this._particlesToEmit - Math.floor(this._particlesToEmit);
            }
        }
        // deferred removal
        for (let i = 0; i < this.deadParticles.length; i++) {
            removeItemFromArray(this.deadParticles[i], this.particles);
            if ((_a = this === null || this === void 0 ? void 0 : this.scene) === null || _a === void 0 ? void 0 : _a.world) {
                this.scene.world.remove(this.deadParticles[i], false);
            }
        }
        this.deadParticles.length = 0;
    }
    draw(ctx) {
        // todo is there a more efficient to draw
        // possibly use a webgl offscreen canvas and shaders to do particles?
        this.particles.forEach((p) => p.draw(ctx));
    }
    debugDraw(ctx) {
        super.debugDraw(ctx);
        ctx.fillStyle = Color.Black.toString();
        ctx.fillText('Particles: ' + this.particles.length, this.pos.x, this.pos.y + 20);
        if (this.focus) {
            ctx.fillRect(this.focus.x + this.pos.x, this.focus.y + this.pos.y, 3, 3);
            line(ctx, Color.Yellow, this.focus.x + this.pos.x, this.focus.y + this.pos.y, this.center.x, this.center.y);
            ctx.fillText('Focus', this.focus.x + this.pos.x, this.focus.y + this.pos.y);
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/GraphicsSystem.ts








class GraphicsSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.transform', 'ex.graphics'];
        this.systemType = SystemType.Draw;
        this.priority = 0;
        this._token = 0;
    }
    initialize(scene) {
        this._graphicsContext = scene.engine.graphicsContext;
        this._camera = scene.camera;
        this._engine = scene.engine;
    }
    sort(a, b) {
        return a.get(TransformComponent).z - b.get(TransformComponent).z;
    }
    update(entities, delta) {
        this._clearScreen();
        this._token++;
        let transform;
        let graphics;
        for (const entity of entities) {
            transform = entity.get(TransformComponent);
            graphics = entity.get(GraphicsComponent);
            // Figure out if entities are offscreen
            const entityOffscreen = this._isOffscreen(transform, graphics);
            if (entityOffscreen && !entity.hasTag('offscreen')) {
                entity.eventDispatcher.emit('exitviewport', new ExitViewPortEvent(entity));
                entity.addComponent(new TagComponent('offscreen'));
            }
            if (!entityOffscreen && entity.hasTag('offscreen')) {
                entity.eventDispatcher.emit('enterviewport', new EnterViewPortEvent(entity));
                entity.removeComponent('offscreen');
            }
            // Skip entities that have graphics offscreen
            if (entityOffscreen) {
                continue;
            }
            // This optionally sets our camera based on the entity coord plan (world vs. screen)
            this._pushCameraTransform(transform);
            this._graphicsContext.save();
            // Tick any graphics state (but only once) for animations and graphics groups
            graphics.update(delta, this._token);
            // Position the entity
            this._applyTransform(entity);
            // Optionally run the onPreDraw graphics lifecycle draw
            if (graphics.onPreDraw) {
                graphics.onPreDraw(this._graphicsContext, delta);
            }
            // TODO remove this hack on the particle redo
            const particleOpacity = (entity instanceof Particle) ? entity.opacity : 1;
            this._graphicsContext.opacity = graphics.opacity * particleOpacity;
            // Draw the graphics component
            this._drawGraphicsComponent(graphics);
            // Optionally run the onPostDraw graphics lifecycle draw
            if (graphics.onPostDraw) {
                graphics.onPostDraw(this._graphicsContext, delta);
            }
            this._graphicsContext.restore();
            // Reset the transform back to the original
            this._popCameraTransform(transform);
        }
        this._graphicsContext.flush();
        this._engine.stats.currFrame.graphics.drawnImages = GraphicsDiagnostics.DrawnImagesCount;
        this._engine.stats.currFrame.graphics.drawCalls = GraphicsDiagnostics.DrawCallCount;
    }
    _clearScreen() {
        this._graphicsContext.clear();
    }
    _isOffscreen(transform, graphics) {
        if (transform.coordPlane === CoordPlane.World) {
            const graphicsOffscreen = !this._camera.viewport.intersect(graphics.localBounds.transform(transform.getGlobalMatrix()));
            return graphicsOffscreen;
        }
        else {
            // TODO sceen coordinates
            return false;
        }
    }
    _drawGraphicsComponent(graphicsComponent) {
        var _a, _b;
        if (graphicsComponent.visible) {
            // this should be moved to the graphics system
            for (const layer of graphicsComponent.layers.get()) {
                for (const { graphic, options } of layer.graphics) {
                    let anchor = graphicsComponent.anchor;
                    let offset = graphicsComponent.offset;
                    if (options === null || options === void 0 ? void 0 : options.anchor) {
                        anchor = options.anchor;
                    }
                    if (options === null || options === void 0 ? void 0 : options.offset) {
                        offset = options.offset;
                    }
                    // See https://github.com/excaliburjs/Excalibur/pull/619 for discussion on this formula
                    const offsetX = -graphic.width * anchor.x + offset.x;
                    const offsetY = -graphic.height * anchor.y + offset.y;
                    graphic === null || graphic === void 0 ? void 0 : graphic.draw(this._graphicsContext, offsetX + layer.offset.x, offsetY + layer.offset.y);
                    if (((_a = this._engine) === null || _a === void 0 ? void 0 : _a.isDebug) && this._engine.debug.graphics.showBounds) {
                        const offset = vec(offsetX + layer.offset.x, offsetY + layer.offset.y);
                        if (graphic instanceof GraphicsGroup) {
                            for (const g of graphic.members) {
                                (_b = g.graphic) === null || _b === void 0 ? void 0 : _b.localBounds.translate(offset.add(g.pos)).draw(this._graphicsContext, this._engine.debug.graphics.boundsColor);
                            }
                        }
                        else {
                            /* istanbul ignore next */
                            graphic === null || graphic === void 0 ? void 0 : graphic.localBounds.translate(offset).draw(this._graphicsContext, this._engine.debug.graphics.boundsColor);
                        }
                    }
                }
            }
        }
    }
    /**
     * This applies the current entity transform to the graphics context
     * @param entity
     */
    _applyTransform(entity) {
        const ancestors = entity.getAncestors();
        for (const ancestor of ancestors) {
            const transform = ancestor === null || ancestor === void 0 ? void 0 : ancestor.get(TransformComponent);
            if (transform) {
                this._graphicsContext.translate(transform.pos.x, transform.pos.y);
                this._graphicsContext.scale(transform.scale.x, transform.scale.y);
                this._graphicsContext.rotate(transform.rotation);
            }
        }
    }
    /**
     * Applies the current camera transform if in world coordinates
     * @param transform
     */
    _pushCameraTransform(transform) {
        // Establish camera offset per entity
        if (transform.coordPlane === CoordPlane.World) {
            this._graphicsContext.save();
            if (this._camera) {
                this._camera.draw(this._graphicsContext);
            }
        }
    }
    /**
     * Resets the current camera transform if in world coordinates
     * @param transform
     */
    _popCameraTransform(transform) {
        if (transform.coordPlane === CoordPlane.World) {
            // Apply camera world offset
            this._graphicsContext.restore();
        }
    }
}

;// CONCATENATED MODULE: ./Drawing/CanvasDrawingSystem.ts




/**
 * Draws anything with a transform and a "draw" method
 * @deprecated Shim for canvas drawing, will be removed v0.26.0
 */
class CanvasDrawingSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.transform', 'ex.canvas'];
        this.systemType = SystemType.Draw;
        this.priority = -1;
    }
    initialize(scene) {
        this._ctx = scene.engine.ctx;
        this._engine = scene.engine;
        this._camera = scene.camera;
    }
    sort(a, b) {
        return a.get(TransformComponent).z - b.get(TransformComponent).z;
    }
    update(entities, delta) {
        var _a, _b, _c;
        this._clearScreen();
        let transform;
        let canvasdraw;
        const length = entities.length;
        for (let i = 0; i < length; i++) {
            const visible = (_c = (_b = (_a = entities[i]) === null || _a === void 0 ? void 0 : _a.graphics) === null || _b === void 0 ? void 0 : _b.visible) !== null && _c !== void 0 ? _c : true;
            const offscreen = entities[i].isOffScreen;
            if (visible && !offscreen) {
                transform = entities[i].get(TransformComponent);
                canvasdraw = entities[i].get(CanvasDrawComponent);
                this._ctx.save();
                this._pushCameraTransform(transform);
                this._ctx.save();
                this._applyTransform(entities[i]);
                canvasdraw.draw(this._ctx, delta);
                this._ctx.restore();
                this._popCameraTransform(transform);
                this._ctx.restore();
            }
            if (this._engine.isDebug) {
                this._ctx.save();
                this._pushCameraTransform(transform);
                this._ctx.strokeStyle = 'yellow';
                entities[i].debugDraw(this._ctx);
                this._popCameraTransform(transform);
                this._ctx.restore();
            }
        }
        if (this._engine.isDebug) {
            this._ctx.save();
            this._camera.draw(this._ctx);
            this._camera.debugDraw(this._ctx);
            this._ctx.restore();
        }
        this._engine.stats.currFrame.graphics.drawnImages = GraphicsDiagnostics.DrawnImagesCount;
        this._engine.stats.currFrame.graphics.drawCalls = GraphicsDiagnostics.DrawCallCount;
    }
    _applyTransform(entity) {
        const ancestors = entity.getAncestors();
        for (const ancestor of ancestors) {
            const transform = ancestor === null || ancestor === void 0 ? void 0 : ancestor.get(TransformComponent);
            if (transform) {
                this._ctx.translate(transform.pos.x, transform.pos.y);
                this._ctx.rotate(transform.rotation);
                this._ctx.scale(transform.scale.x, transform.scale.y);
            }
        }
    }
    _clearScreen() {
        this._ctx.clearRect(0, 0, this._ctx.canvas.width, this._ctx.canvas.height);
        this._ctx.fillStyle = this._engine.backgroundColor.toString();
        this._ctx.fillRect(0, 0, this._ctx.canvas.width, this._ctx.canvas.height);
    }
    _pushCameraTransform(transform) {
        if (transform.coordPlane === CoordPlane.World) {
            // Apply camera transform to place entity in world space
            this._ctx.save();
            if (this._camera) {
                this._camera.draw(this._ctx);
            }
        }
    }
    _popCameraTransform(transform) {
        if (transform.coordPlane === CoordPlane.World) {
            // Restore back to screen space from world space if we were drawing an entity there
            this._ctx.restore();
        }
    }
}

;// CONCATENATED MODULE: ./Debug/DebugSystem.ts






class DebugSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.transform'];
        this.systemType = SystemType.Draw;
        this.priority = 999; // lowest priority
    }
    initialize(scene) {
        this._graphicsContext = scene.engine.graphicsContext;
        this._camera = scene.camera;
        this._engine = scene.engine;
        this._collisionSystem = scene.world.systemManager.get(CollisionSystem);
    }
    update(entities, _delta) {
        var _a, _b;
        if (!this._engine.isDebug) {
            return;
        }
        const filterSettings = this._engine.debug.filter;
        let id;
        let name;
        const entitySettings = this._engine.debug.entity;
        let tx;
        const txSettings = this._engine.debug.transform;
        let motion;
        const motionSettings = this._engine.debug.motion;
        let colliderComp;
        const colliderSettings = this._engine.debug.collider;
        const physicsSettings = this._engine.debug.physics;
        let graphics;
        const graphicsSettings = this._engine.debug.graphics;
        let body;
        const bodySettings = this._engine.debug.body;
        const cameraSettings = this._engine.debug.camera;
        for (const entity of entities) {
            if (entity.hasTag('offscreen')) {
                // skip offscreen entities
                continue;
            }
            if (entity instanceof Particle) {
                // Particles crush the renderer :(
                continue;
            }
            if (filterSettings.useFilter) {
                const allIds = filterSettings.ids.length === 0;
                const idMatch = allIds || filterSettings.ids.includes(entity.id);
                if (!idMatch) {
                    continue;
                }
                const allNames = filterSettings.nameQuery === '';
                const nameMatch = allNames || entity.name.includes(filterSettings.nameQuery);
                if (!nameMatch) {
                    continue;
                }
            }
            let cursor = Vector.Zero;
            const lineHeight = vec(0, 16);
            id = entity.id;
            name = entity.name;
            tx = entity.get(TransformComponent);
            // This optionally sets our camera based on the entity coord plan (world vs. screen)
            this._pushCameraTransform(tx);
            this._graphicsContext.save();
            this._applyTransform(entity);
            if (tx) {
                if (txSettings.showAll || txSettings.showPosition) {
                    this._graphicsContext.debug.drawPoint(Vector.Zero, { size: 2, color: txSettings.positionColor });
                    this._graphicsContext.debug.drawText(`pos${tx.pos.toString(2)}`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (entitySettings.showAll || entitySettings.showId) {
                    this._graphicsContext.debug.drawText(`id(${id}) ${tx.parent ? 'child of id(' + ((_b = (_a = tx.parent) === null || _a === void 0 ? void 0 : _a.owner) === null || _b === void 0 ? void 0 : _b.id) + ')' : ''}`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (entitySettings.showAll || entitySettings.showName) {
                    this._graphicsContext.debug.drawText(`name(${name})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (txSettings.showAll || txSettings.showRotation) {
                    this._graphicsContext.drawLine(Vector.Zero, Vector.fromAngle(tx.rotation).scale(50).add(Vector.Zero), txSettings.rotationColor, 2);
                    this._graphicsContext.debug.drawText(`rot deg(${toDegrees(tx.rotation).toFixed(2)})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (txSettings.showAll || txSettings.showScale) {
                    this._graphicsContext.drawLine(Vector.Zero, tx.scale.add(Vector.Zero), txSettings.scaleColor, 2);
                }
            }
            graphics = entity.get(GraphicsComponent);
            if (graphics) {
                if (graphicsSettings.showAll || graphicsSettings.showBounds) {
                    const bounds = graphics.localBounds;
                    bounds.draw(this._graphicsContext, graphicsSettings.boundsColor);
                }
            }
            body = entity.get(BodyComponent);
            if (body) {
                if (bodySettings.showAll || bodySettings.showCollisionGroup) {
                    this._graphicsContext.debug.drawText(`collision group(${body.group.name})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (bodySettings.showAll || bodySettings.showCollisionType) {
                    this._graphicsContext.debug.drawText(`collision type(${body.collisionType})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (bodySettings.showAll || bodySettings.showMass) {
                    this._graphicsContext.debug.drawText(`mass(${body.mass})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (bodySettings.showAll || bodySettings.showMotion) {
                    this._graphicsContext.debug.drawText(`motion(${body.sleepMotion})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (bodySettings.showAll || bodySettings.showSleeping) {
                    this._graphicsContext.debug.drawText(`sleeping(${body.canSleep ? body.sleeping : 'cant sleep'})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
            }
            this._graphicsContext.restore();
            motion = entity.get(MotionComponent);
            if (motion) {
                if (motionSettings.showAll || motionSettings.showVelocity) {
                    this._graphicsContext.debug.drawText(`vel${motion.vel.toString(2)}`, cursor.add(tx.globalPos));
                    this._graphicsContext.drawLine(tx.globalPos, tx.globalPos.add(motion.vel), motionSettings.velocityColor, 2);
                    cursor = cursor.add(lineHeight);
                }
                if (motionSettings.showAll || motionSettings.showAcceleration) {
                    this._graphicsContext.drawLine(tx.globalPos, tx.globalPos.add(motion.acc), motionSettings.accelerationColor, 2);
                }
            }
            // Colliders live in world space already so after the restore()
            colliderComp = entity.get(ColliderComponent);
            if (colliderComp) {
                const collider = colliderComp.get();
                if ((colliderSettings.showAll || colliderSettings.showGeometry) && collider) {
                    collider.debug(this._graphicsContext, colliderSettings.geometryColor);
                }
                if (colliderSettings.showAll || colliderSettings.showBounds) {
                    if (collider instanceof CompositeCollider) {
                        const colliders = collider.getColliders();
                        for (const collider of colliders) {
                            const bounds = collider.bounds;
                            const pos = vec(bounds.left, bounds.top);
                            this._graphicsContext.debug.drawRect(pos.x, pos.y, bounds.width, bounds.height, { color: colliderSettings.boundsColor });
                            if (colliderSettings.showAll || colliderSettings.showOwner) {
                                this._graphicsContext.debug.drawText(`owner id(${collider.owner.id})`, pos);
                            }
                        }
                        colliderComp.bounds.draw(this._graphicsContext, colliderSettings.boundsColor);
                    }
                    else if (collider) {
                        const bounds = colliderComp.bounds;
                        const pos = vec(bounds.left, bounds.top);
                        this._graphicsContext.debug.drawRect(pos.x, pos.y, bounds.width, bounds.height, { color: colliderSettings.boundsColor });
                        if (colliderSettings.showAll || colliderSettings.showOwner) {
                            this._graphicsContext.debug.drawText(`owner id(${colliderComp.owner.id})`, pos);
                        }
                    }
                }
            }
            this._popCameraTransform(tx);
        }
        this._graphicsContext.save();
        this._camera.draw(this._graphicsContext);
        if (physicsSettings.showAll || physicsSettings.showBroadphaseSpacePartitionDebug) {
            this._collisionSystem.debug(this._graphicsContext);
        }
        if (physicsSettings.showAll || physicsSettings.showCollisionContacts || physicsSettings.showCollisionNormals) {
            for (const [_, contact] of this._engine.debug.stats.currFrame.physics.contacts) {
                if (physicsSettings.showAll || physicsSettings.showCollisionContacts) {
                    for (const point of contact.points) {
                        this._graphicsContext.debug.drawPoint(point, { size: 5, color: physicsSettings.collisionContactColor });
                    }
                }
                if (physicsSettings.showAll || physicsSettings.showCollisionNormals) {
                    for (const point of contact.points) {
                        this._graphicsContext.debug.drawLine(point, contact.normal.scale(30).add(point), {
                            color: physicsSettings.collisionNormalColor
                        });
                    }
                }
            }
        }
        this._graphicsContext.restore();
        if (cameraSettings) {
            this._graphicsContext.save();
            this._camera.draw(this._graphicsContext);
            if (cameraSettings.showAll || cameraSettings.showFocus) {
                this._graphicsContext.drawCircle(this._camera.pos, 4, cameraSettings.focusColor);
            }
            if (cameraSettings.showAll || cameraSettings.showZoom) {
                this._graphicsContext.debug.drawText(`zoom(${this._camera.zoom})`, this._camera.pos);
            }
            this._graphicsContext.restore();
        }
        this._graphicsContext.flush();
    }
    /**
     * This applies the current entity transform to the graphics context
     * @param entity
     */
    _applyTransform(entity) {
        const ancestors = entity.getAncestors();
        for (const ancestor of ancestors) {
            const transform = ancestor === null || ancestor === void 0 ? void 0 : ancestor.get(TransformComponent);
            if (transform) {
                this._graphicsContext.translate(transform.pos.x, transform.pos.y);
                this._graphicsContext.scale(transform.scale.x, transform.scale.y);
                this._graphicsContext.rotate(transform.rotation);
            }
        }
    }
    /**
     * Applies the current camera transform if in world coordinates
     * @param transform
     */
    _pushCameraTransform(transform) {
        // Establish camera offset per entity
        if (transform.coordPlane === CoordPlane.World) {
            this._graphicsContext.save();
            if (this._camera) {
                this._camera.draw(this._graphicsContext);
            }
        }
    }
    /**
     * Resets the current camera transform if in world coordinates
     * @param transform
     */
    _popCameraTransform(transform) {
        if (transform.coordPlane === CoordPlane.World) {
            // Apply camera world offset
            this._graphicsContext.restore();
        }
    }
}

;// CONCATENATED MODULE: ./Actions/ActionsSystem.ts


class ActionsSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.actions'];
        this.systemType = SystemType.Update;
        this.priority = -1;
    }
    update(entities, delta) {
        let actions;
        for (const entity of entities) {
            actions = entity.get(ActionsComponent);
            actions.update(delta);
        }
    }
}

;// CONCATENATED MODULE: ./Scene.ts
var Scene_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};






















/**
 * [[Actor|Actors]] are composed together into groupings called Scenes in
 * Excalibur. The metaphor models the same idea behind real world
 * actors in a scene. Only actors in scenes will be updated and drawn.
 *
 * Typical usages of a scene include: levels, menus, loading screens, etc.
 */
class Scene extends Class {
    constructor() {
        super();
        this._logger = Logger.getInstance();
        /**
         * Gets or sets the current camera for the scene
         */
        this.camera = new Camera();
        /**
         * The ECS world for the scene
         */
        this.world = new World(this);
        this._isInitialized = false;
        this._timers = [];
        this._cancelQueue = [];
        // TODO how to people do there own systems
        // Initialize systems
        this.world.add(new ActionsSystem());
        this.world.add(new MotionSystem());
        this.world.add(new CollisionSystem());
        if (Flags.isEnabled(Legacy.LegacyDrawing)) {
            this.world.add(new CanvasDrawingSystem());
        }
        else {
            this.world.add(new GraphicsSystem());
        }
        this.world.add(new DebugSystem());
    }
    /**
     * The actors in the current scene
     */
    get actors() {
        return this.world.entityManager.entities.filter((e) => {
            return e instanceof Actor;
        });
    }
    /**
     * The entities in the current scene
     */
    get entities() {
        return this.world.entityManager.entities;
    }
    /**
     * The triggers in the current scene
     */
    get triggers() {
        return this.world.entityManager.entities.filter((e) => {
            return e instanceof Trigger_Trigger;
        });
    }
    /**
     * The [[TileMap]]s in the scene, if any
     */
    get tileMaps() {
        return this.world.entityManager.entities.filter((e) => {
            return e instanceof TileMap;
        });
    }
    /**
     * The [[ScreenElement]]s in a scene, if any; these are drawn last
     * @deprecated Use [[Scene.actors]]
     */
    get screenElements() {
        return this.actors.filter((a) => a instanceof ScreenElement_ScreenElement);
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    once(eventName, handler) {
        super.once(eventName, handler);
    }
    off(eventName, handler) {
        super.off(eventName, handler);
    }
    /**
     * This is called before the first update of the [[Scene]]. Initializes scene members like the camera. This method is meant to be
     * overridden. This is where initialization of child actors should take place.
     */
    onInitialize(_engine) {
        // will be overridden
    }
    /**
     * This is called when the scene is made active and started. It is meant to be overridden,
     * this is where you should setup any DOM UI or event handlers needed for the scene.
     */
    onActivate(_oldScene, _newScene) {
        // will be overridden
    }
    /**
     * This is called when the scene is made transitioned away from and stopped. It is meant to be overridden,
     * this is where you should cleanup any DOM UI or event handlers needed for the scene.
     */
    onDeactivate(_oldScene, _newScene) {
        // will be overridden
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before a scene is updated.
     */
    onPreUpdate(_engine, _delta) {
        // will be overridden
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after a scene is updated.
     */
    onPostUpdate(_engine, _delta) {
        // will be overridden
    }
    /**
     * Safe to override onPreDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreDraw` is called directly before a scene is drawn.
     */
    onPreDraw(_ctx, _delta) {
        // will be overridden
    }
    /**
     * Safe to override onPostDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostDraw` is called directly after a scene is drawn.
     */
    onPostDraw(_ctx, _delta) {
        // will be overridden
    }
    /**
     * Initializes actors in the scene
     */
    _initializeChildren() {
        for (const child of this.entities) {
            child._initialize(this.engine);
        }
    }
    /**
     * Gets whether or not the [[Scene]] has been initialized
     */
    get isInitialized() {
        return this._isInitialized;
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Initializes the scene before the first update, meant to be called by engine not by users of
     * Excalibur
     * @internal
     */
    _initialize(engine) {
        if (!this.isInitialized) {
            this.engine = engine;
            // Initialize camera first
            this.camera._initialize(engine);
            // This order is important! we want to be sure any custom init that add actors
            // fire before the actor init
            this.onInitialize.call(this, engine);
            this._initializeChildren();
            this._logger.debug('Scene.onInitialize', this, engine);
            this.eventDispatcher.emit('initialize', new InitializeEvent(engine, this));
            this._isInitialized = true;
        }
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Activates the scene with the base behavior, then calls the overridable `onActivate` implementation.
     * @internal
     */
    _activate(oldScene, newScene) {
        this._logger.debug('Scene.onActivate', this);
        this.onActivate(oldScene, newScene);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Deactivates the scene with the base behavior, then calls the overridable `onDeactivate` implementation.
     * @internal
     */
    _deactivate(oldScene, newScene) {
        this._logger.debug('Scene.onDeactivate', this);
        this.onDeactivate(oldScene, newScene);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event
     * @internal
     */
    _preupdate(_engine, delta) {
        this.emit('preupdate', new PreUpdateEvent(_engine, delta, this));
        this.onPreUpdate(_engine, delta);
    }
    /**
     *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event
     * @internal
     */
    _postupdate(_engine, delta) {
        this.emit('postupdate', new PostUpdateEvent(_engine, delta, this));
        this.onPostUpdate(_engine, delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _predraw handler for [[onPreDraw]] lifecycle event
     *
     * @internal
     */
    _predraw(_ctx, _delta) {
        this.emit('predraw', new PreDrawEvent(_ctx, _delta, this));
        this.onPreDraw(_ctx, _delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _postdraw handler for [[onPostDraw]] lifecycle event
     *
     * @internal
     */
    _postdraw(_ctx, _delta) {
        this.emit('postdraw', new PostDrawEvent(_ctx, _delta, this));
        this.onPostDraw(_ctx, _delta);
    }
    /**
     * Updates all the actors and timers in the scene. Called by the [[Engine]].
     * @param engine  Reference to the current Engine
     * @param delta   The number of milliseconds since the last update
     */
    update(engine, delta) {
        this._preupdate(engine, delta);
        if (this.camera) {
            this.camera.update(engine, delta);
        }
        // TODO differed entity removal for timers
        let i, len;
        // Remove timers in the cancel queue before updating them
        for (i = 0, len = this._cancelQueue.length; i < len; i++) {
            this.removeTimer(this._cancelQueue[i]);
        }
        this._cancelQueue.length = 0;
        // Cycle through timers updating timers
        for (const timer of this._timers) {
            timer.update(delta);
        }
        this.world.update(SystemType.Update, delta);
        this._collectActorStats(engine);
        engine.input.pointers.dispatchPointerEvents();
        this._postupdate(engine, delta);
    }
    /**
     * Draws all the actors in the Scene. Called by the [[Engine]].
     * @param ctx    The current rendering context
     * @param delta  The number of milliseconds since the last draw
     */
    draw(ctx, delta) {
        var _a;
        this._predraw(ctx, delta);
        this.world.update(SystemType.Draw, delta);
        if ((_a = this.engine) === null || _a === void 0 ? void 0 : _a.isDebug) {
            this.debugDraw(ctx);
        }
        this._postdraw(ctx, delta);
    }
    /**
     * Draws all the actors' debug information in the Scene. Called by the [[Engine]].
     * @param ctx  The current rendering context
     * @deprecated
     */
    /* istanbul ignore next */
    debugDraw(ctx) {
        this.emit('predebugdraw', new PreDebugDrawEvent(ctx, this));
        // pass
        this.emit('postdebugdraw', new PostDebugDrawEvent(ctx, this));
    }
    /**
     * Checks whether an actor is contained in this scene or not
     */
    contains(actor) {
        return this.actors.indexOf(actor) > -1;
    }
    add(entity) {
        this.emit('entityadded', { target: entity });
        this.world.add(entity);
        entity.scene = this;
        if (entity instanceof Timer) {
            if (!contains(this._timers, entity)) {
                this.addTimer(entity);
            }
            return;
        }
    }
    remove(entity) {
        if (entity instanceof Entity) {
            this.emit('entityremoved', { target: entity });
            this.world.remove(entity);
        }
        if (entity instanceof Timer) {
            this.removeTimer(entity);
        }
    }
    /**
     * Adds (any) actor to act as a piece of UI, meaning it is always positioned
     * in screen coordinates. UI actors do not participate in collisions.
     * @todo Should this be `ScreenElement` only?
     * @deprecated Use [[Scene.add]]
     */
    addScreenElement(actor) {
        this.add(actor);
    }
    /**
     * Removes an actor as a piece of UI
     * @deprecated Use [[Scene.remove]]
     */
    removeScreenElement(actor) {
        this.remove(actor);
    }
    /**
     * Adds a [[TileMap]] to the scene, once this is done the TileMap will be drawn and updated.
     * @deprecated Use [[Scene.add]]
     */
    addTileMap(tileMap) {
        this.world.add(tileMap);
    }
    /**
     * Removes a [[TileMap]] from the scene, it will no longer be drawn or updated.
     * @deprecated Use [[Scene.remove]]
     */
    removeTileMap(tileMap) {
        this.world.remove(tileMap);
    }
    /**
     * Adds a [[Timer]] to the scene
     * @param timer  The timer to add
     */
    addTimer(timer) {
        this._timers.push(timer);
        timer.scene = this;
        return timer;
    }
    /**
     * Removes a [[Timer]] from the scene.
     * @warning Can be dangerous, use [[cancelTimer]] instead
     * @param timer  The timer to remove
     */
    removeTimer(timer) {
        const i = this._timers.indexOf(timer);
        if (i !== -1) {
            this._timers.splice(i, 1);
        }
        return timer;
    }
    /**
     * Cancels a [[Timer]], removing it from the scene nicely
     * @param timer  The timer to cancel
     */
    cancelTimer(timer) {
        this._cancelQueue.push(timer);
        return timer;
    }
    /**
     * Tests whether a [[Timer]] is active in the scene
     */
    isTimerActive(timer) {
        return this._timers.indexOf(timer) > -1 && !timer.complete;
    }
    isCurrentScene() {
        if (this.engine) {
            return this.engine.currentScene === this;
        }
        return false;
    }
    _collectActorStats(engine) {
        const screenElements = this.actors.filter((a) => a instanceof ScreenElement_ScreenElement);
        for (const _ui of screenElements) {
            engine.stats.currFrame.actors.ui++;
        }
        for (const actor of this.actors) {
            engine.stats.currFrame.actors.alive++;
            for (const child of actor.children) {
                if (isScreenElement(child)) {
                    // TODO not true
                    engine.stats.currFrame.actors.ui++;
                }
                else {
                    engine.stats.currFrame.actors.alive++;
                }
            }
        }
    }
}
Scene_decorate([
    obsolete({
        message: 'Will be removed in excalibur v0.26.0',
        alternateMethod: 'ScreenElements now are normal actors with a Transform Coordinate Plane of Screen'
    })
], Scene.prototype, "screenElements", null);
Scene_decorate([
    obsolete({ message: 'Will be removed in excalibur v0.26.0', alternateMethod: 'Use Scene.add' })
], Scene.prototype, "addScreenElement", null);
Scene_decorate([
    obsolete({ message: 'Will be removed in excalibur v0.26.0', alternateMethod: 'Use Scene.remove' })
], Scene.prototype, "removeScreenElement", null);
Scene_decorate([
    obsolete({ message: 'Will be removed in excalibur v0.26.0', alternateMethod: 'Use Scene.add' })
], Scene.prototype, "addTileMap", null);
Scene_decorate([
    obsolete({ message: 'Will be removed in excalibur v0.26.0', alternateMethod: 'Use Scene.remove' })
], Scene.prototype, "removeTileMap", null);

;// CONCATENATED MODULE: ./PostProcessing/ColorBlindCorrector.ts

var ColorBlindness;
(function (ColorBlindness) {
    ColorBlindness[ColorBlindness["Protanope"] = 0] = "Protanope";
    ColorBlindness[ColorBlindness["Deuteranope"] = 1] = "Deuteranope";
    ColorBlindness[ColorBlindness["Tritanope"] = 2] = "Tritanope";
})(ColorBlindness || (ColorBlindness = {}));
/**
 * This post processor can correct colors and simulate color blindness.
 * It is possible to use this on every game, but the game's performance
 * will suffer measurably. It's better to use it as a helpful tool while developing your game.
 * Remember, the best practice is to design with color blindness in mind.
 */
class ColorBlindCorrector {
    constructor(engine, simulate = false, colorMode = ColorBlindness.Protanope) {
        this.engine = engine;
        this.simulate = simulate;
        this.colorMode = colorMode;
        /*eslint-disable */
        this._vertexShader = '' +
            'attribute vec2 a_position;' +
            'attribute vec2 a_texCoord;' +
            'uniform vec2 u_resolution;' +
            'varying vec2 v_texCoord;' +
            'void main() {' +
            // convert the rectangle from pixels to 0.0 to 1.0
            'vec2 zeroToOne = a_position / u_resolution;' +
            // convert from 0->1 to 0->2
            'vec2 zeroToTwo = zeroToOne * 2.0;' +
            // convert from 0->2 to -1->+1 (clipspace)
            'vec2 clipSpace = zeroToTwo - 1.0;' +
            'gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);' +
            // pass the texCoord to the fragment shader
            // The GPU will interpolate this value between points.
            'v_texCoord = a_texCoord;' +
            '}';
        this._fragmentShader = 'precision mediump float;' +
            // our texture
            'uniform sampler2D u_image;' +
            // the texCoords passed in from the vertex shader.
            'varying vec2 v_texCoord;' +
            // Color blind conversions
            /*'mat3 m[9] =' +
           '{' +
              'mat3(1.0, 0.0, 0.0,  0.0, 1.0, 0.0,  0.0, 0.0, 1.0  ),' + // normal
              'mat3(0.567, 0.433, 0.0,  0.558, 0.442, 0.0,  0.0, 0.242, 0.758),' + // protanopia
              'mat3(0.817, 0.183, 0.0,  0.333, 0.667, 0.0,  0.0, 0.125,0.875),' + // protanomaly
              'mat3(0.625, 0.375, 0.0,  0.7, 0.3, 0.0,  0.0, 0.3,0.7  ),' + // deuteranopia
              'mat3(0.8, 0.2, 0.0,  0.258, 0.742, 0.0,  0.0, 0.142,0.858),' + // deuteranomaly
              'mat3(0.95, 0.05, 0.0,  0.0, 0.433, 0.567,  0.0, 0.475,0.525),' + // tritanopia
              'mat3(0.967, 0.033, 0.0,  0.0, 0.733, 0.267,  0.0, 0.183,0.817),' + // tritanomaly
              'mat3(0.299, 0.587, 0.114,  0.299, 0.587, 0.114,  0.299, 0.587,0.114),' + // achromatopsia
              'mat3(0.618, 0.320, 0.062,  0.163, 0.775, 0.062,  0.163, 0.320,0.516)' +  // achromatomaly
           '};' +*/
            'void main() {' +
            'vec4 o =  texture2D(u_image, v_texCoord);' +
            // RGB to LMS matrix conversion
            'float L = (17.8824 * o.r) + (43.5161 * o.g) + (4.11935 * o.b);' +
            'float M = (3.45565 * o.r) + (27.1554 * o.g) + (3.86714 * o.b);' +
            'float S = (0.0299566 * o.r) + (0.184309 * o.g) + (1.46709 * o.b);' +
            // Simulate color blindness
            '//MODE CODE//' +
            /* Deuteranope for testing
              'float l = 1.0 * L + 0.0 * M + 0.0 * S;' +
                    'float m = 0.494207 * L + 0.0 * M + 1.24827 * S;' +
                    'float s = 0.0 * L + 0.0 * M + 1.0 * S;' +*/
            // LMS to RGB matrix conversion
            'vec4 error;' +
            'error.r = (0.0809444479 * l) + (-0.130504409 * m) + (0.116721066 * s);' +
            'error.g = (-0.0102485335 * l) + (0.0540193266 * m) + (-0.113614708 * s);' +
            'error.b = (-0.000365296938 * l) + (-0.00412161469 * m) + (0.693511405 * s);' +
            'error.a = 1.0;' +
            'vec4 diff = o - error;' +
            'vec4 correction;' +
            'correction.r = 0.0;' +
            'correction.g =  (diff.r * 0.7) + (diff.g * 1.0);' +
            'correction.b =  (diff.r * 0.7) + (diff.b * 1.0);' +
            'correction = o + correction;' +
            'correction.a = o.a;' +
            '//SIMULATE//' +
            '}';
        this._internalCanvas = document.createElement('canvas');
        this._internalCanvas.width = engine.drawWidth;
        this._internalCanvas.height = engine.drawHeight;
        // eslint-disable-next-line
        this._gl = this._internalCanvas.getContext('webgl', { preserveDrawingBuffer: true });
        this._program = this._gl.createProgram();
        const fragmentShader = this._getShader('Fragment', this._getFragmentShaderByMode(colorMode));
        const vertextShader = this._getShader('Vertex', this._vertexShader);
        this._gl.attachShader(this._program, vertextShader);
        this._gl.attachShader(this._program, fragmentShader);
        this._gl.linkProgram(this._program);
        if (!this._gl.getProgramParameter(this._program, this._gl.LINK_STATUS)) {
            Logger.getInstance().error('Unable to link shader program!');
        }
        this._gl.useProgram(this._program);
    }
    _getFragmentShaderByMode(colorMode) {
        let code = '';
        if (colorMode === ColorBlindness.Protanope) {
            code =
                'float l = 0.0 * L + 2.02344 * M + -2.52581 * S;' +
                    'float m = 0.0 * L + 1.0 * M + 0.0 * S;' +
                    'float s = 0.0 * L + 0.0 * M + 1.0 * S;';
        }
        else if (colorMode === ColorBlindness.Deuteranope) {
            code =
                'float l = 1.0 * L + 0.0 * M + 0.0 * S;' +
                    'float m = 0.494207 * L + 0.0 * M + 1.24827 * S;' +
                    'float s = 0.0 * L + 0.0 * M + 1.0 * S;';
        }
        else if (colorMode === ColorBlindness.Tritanope) {
            code =
                'float l = 1.0 * L + 0.0 * M + 0.0 * S;' +
                    'float m = 0.0 * L + 1.0 * M + 0.0 * S;' +
                    'float s = -0.395913 * L + 0.801109 * M + 0.0 * S;';
        }
        if (this.simulate) {
            this._fragmentShader = this._fragmentShader.replace('//SIMULATE//', 'gl_FragColor = error.rgba;');
        }
        else {
            this._fragmentShader = this._fragmentShader.replace('//SIMULATE//', 'gl_FragColor = correction.rgba;');
        }
        return this._fragmentShader.replace('//MODE CODE//', code);
    }
    _setRectangle(x, y, width, height) {
        const x1 = x;
        const x2 = x + width;
        const y1 = y;
        const y2 = y + height;
        this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array([x1, y1, x2, y1, x1, y2, x1, y2, x2, y1, x2, y2]), this._gl.STATIC_DRAW);
    }
    _getShader(type, program) {
        let shader;
        if (type === 'Fragment') {
            shader = this._gl.createShader(this._gl.FRAGMENT_SHADER);
        }
        else if (type === 'Vertex') {
            shader = this._gl.createShader(this._gl.VERTEX_SHADER);
        }
        else {
            Logger.getInstance().error('Error unknown shader type', type);
        }
        this._gl.shaderSource(shader, program);
        this._gl.compileShader(shader);
        if (!this._gl.getShaderParameter(shader, this._gl.COMPILE_STATUS)) {
            Logger.getInstance().error('Unable to compile shader!', this._gl.getShaderInfoLog(shader));
            return null;
        }
        return shader;
    }
    process(image, out) {
        // look up where the vertex data needs to go.
        const positionLocation = this._gl.getAttribLocation(this._program, 'a_position');
        const texCoordLocation = this._gl.getAttribLocation(this._program, 'a_texCoord');
        const texCoordBuffer = this._gl.createBuffer();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, texCoordBuffer);
        this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), this._gl.STATIC_DRAW);
        this._gl.enableVertexAttribArray(texCoordLocation);
        this._gl.vertexAttribPointer(texCoordLocation, 2, this._gl.FLOAT, false, 0, 0);
        // Create a texture.
        const texture = this._gl.createTexture();
        this._gl.bindTexture(this._gl.TEXTURE_2D, texture);
        // Set the parameters so we can render any size image.
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST);
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST);
        // Flip the texture when unpacking into the gl context, gl reads textures in the opposite order as everything else :/
        this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, 1);
        // Upload the image into the texture.
        this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, image);
        // lookup uniforms
        const resolutionLocation = this._gl.getUniformLocation(this._program, 'u_resolution');
        // set the resolution
        this._gl.uniform2f(resolutionLocation, this._internalCanvas.width, this._internalCanvas.height);
        // Create a buffer for the position of the rectangle corners.
        const positionBuffer = this._gl.createBuffer();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, positionBuffer);
        this._gl.enableVertexAttribArray(positionLocation);
        this._gl.vertexAttribPointer(positionLocation, 2, this._gl.FLOAT, false, 0, 0);
        // Set a rectangle the same size as the image.
        this._setRectangle(0, 0, image.width, image.height);
        // Draw the rectangle.
        this._gl.drawArrays(this._gl.TRIANGLES, 0, 6);
        // Grab transformed image from internal canvas
        const pixelData = new Uint8Array(image.width * image.height * 4);
        this._gl.readPixels(0, 0, image.width, image.height, this._gl.RGBA, this._gl.UNSIGNED_BYTE, pixelData);
        image.data.set(pixelData);
        out.putImageData(image, 0, 0);
    }
}

;// CONCATENATED MODULE: ./Debug/DebugFlags.ts

class ColorBlindFlags {
    constructor(engine) {
        this._engine = engine;
    }
    correct(colorBlindness) {
        this._engine.postProcessors.push(new ColorBlindCorrector(this._engine, false, colorBlindness));
    }
    simulate(colorBlindness) {
        this._engine.postProcessors.push(new ColorBlindCorrector(this._engine, true, colorBlindness));
    }
}

;// CONCATENATED MODULE: ./Debug/Debug.ts


/**
 * Debug statistics and flags for Excalibur. If polling these values, it would be
 * best to do so on the `postupdate` event for [[Engine]], after all values have been
 * updated during a frame.
 */
class Debug {
    constructor(engine) {
        /**
         * Performance statistics
         */
        this.stats = {
            /**
             * Current frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.
             * Best accessed on [[postframe]] event. See [[FrameStats]]
             */
            currFrame: new FrameStats(),
            /**
             * Previous frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.
             * Best accessed on [[preframe]] event. Best inspected on engine event `preframe`. See [[FrameStats]]
             */
            prevFrame: new FrameStats()
        };
        /**
         * Filter debug context to named entities or entity ids
         */
        this.filter = {
            /**
             * Toggle filter on or off (default off) must be on for DebugDraw to use filters
             */
            useFilter: false,
            /**
             * Query for entities by name, if the entity name contains `nameQuery` it will be included
             */
            nameQuery: '',
            /**
             * Query for Entity ids, if the id matches it will be included
             */
            ids: []
        };
        /**
         * Entity debug settings
         */
        this.entity = {
            showAll: false,
            showId: true,
            showName: false
        };
        /**
         * Transform component debug settings
         */
        this.transform = {
            showAll: false,
            showPosition: false,
            positionColor: Color.Yellow,
            showScale: false,
            scaleColor: Color.Green,
            showRotation: false,
            rotationColor: Color.Blue
        };
        /**
         * Graphics component debug settings
         */
        this.graphics = {
            showAll: false,
            showBounds: true,
            boundsColor: Color.Yellow
        };
        /**
         * Collider component debug settings
         */
        this.collider = {
            showAll: false,
            showBounds: true,
            boundsColor: Color.Blue,
            showOwner: false,
            showGeometry: true,
            geometryColor: Color.Green
        };
        /**
         * Physics simulation debug settings
         */
        this.physics = {
            showAll: false,
            showBroadphaseSpacePartitionDebug: false,
            showCollisionNormals: false,
            collisionNormalColor: Color.Cyan,
            showCollisionContacts: true,
            collisionContactColor: Color.Red
        };
        /**
         * Motion component debug settings
         */
        this.motion = {
            showAll: false,
            showVelocity: false,
            velocityColor: Color.Yellow,
            showAcceleration: false,
            accelerationColor: Color.Red
        };
        /**
         * Body component debug settings
         */
        this.body = {
            showAll: false,
            showCollisionGroup: false,
            showCollisionType: false,
            showSleeping: false,
            showMotion: false,
            showMass: false
        };
        /**
         * Camera debug settings
         */
        this.camera = {
            showAll: false,
            showFocus: false,
            focusColor: Color.Red,
            showZoom: false
        };
        this._engine = engine;
        this.colorBlindMode = new ColorBlindFlags(this._engine);
    }
}
/**
 * Implementation of a frame's stats. Meant to have values copied via [[FrameStats.reset]], avoid
 * creating instances of this every frame.
 */
class FrameStats {
    constructor() {
        this._id = 0;
        this._delta = 0;
        this._fps = 0;
        this._actorStats = {
            alive: 0,
            killed: 0,
            ui: 0,
            get remaining() {
                return this.alive - this.killed;
            },
            get total() {
                return this.remaining + this.ui;
            }
        };
        this._durationStats = {
            update: 0,
            draw: 0,
            get total() {
                return this.update + this.draw;
            }
        };
        this._physicsStats = new PhysicsStats();
        this._graphicsStats = {
            drawCalls: 0,
            drawnImages: 0
        };
    }
    /**
     * Zero out values or clone other IFrameStat stats. Allows instance reuse.
     *
     * @param [otherStats] Optional stats to clone
     */
    reset(otherStats) {
        if (otherStats) {
            this.id = otherStats.id;
            this.delta = otherStats.delta;
            this.fps = otherStats.fps;
            this.actors.alive = otherStats.actors.alive;
            this.actors.killed = otherStats.actors.killed;
            this.actors.ui = otherStats.actors.ui;
            this.duration.update = otherStats.duration.update;
            this.duration.draw = otherStats.duration.draw;
            this._physicsStats.reset(otherStats.physics);
            this.graphics.drawCalls = otherStats.graphics.drawCalls;
            this.graphics.drawnImages = otherStats.graphics.drawnImages;
        }
        else {
            this.id = this.delta = this.fps = 0;
            this.actors.alive = this.actors.killed = this.actors.ui = 0;
            this.duration.update = this.duration.draw = 0;
            this._physicsStats.reset();
            this.graphics.drawnImages = this.graphics.drawCalls = 0;
        }
    }
    /**
     * Provides a clone of this instance.
     */
    clone() {
        const fs = new FrameStats();
        fs.reset(this);
        return fs;
    }
    /**
     * Gets the frame's id
     */
    get id() {
        return this._id;
    }
    /**
     * Sets the frame's id
     */
    set id(value) {
        this._id = value;
    }
    /**
     * Gets the frame's delta (time since last frame)
     */
    get delta() {
        return this._delta;
    }
    /**
     * Sets the frame's delta (time since last frame). Internal use only.
     * @internal
     */
    set delta(value) {
        this._delta = value;
    }
    /**
     * Gets the frame's frames-per-second (FPS)
     */
    get fps() {
        return this._fps;
    }
    /**
     * Sets the frame's frames-per-second (FPS). Internal use only.
     * @internal
     */
    set fps(value) {
        this._fps = value;
    }
    /**
     * Gets the frame's actor statistics
     */
    get actors() {
        return this._actorStats;
    }
    /**
     * Gets the frame's duration statistics
     */
    get duration() {
        return this._durationStats;
    }
    /**
     * Gets the frame's physics statistics
     */
    get physics() {
        return this._physicsStats;
    }
    /**
     * Gets the frame's graphics statistics
     */
    get graphics() {
        return this._graphicsStats;
    }
}
class PhysicsStats {
    constructor() {
        this._pairs = 0;
        this._collisions = 0;
        this._contacts = new Map();
        this._fastBodies = 0;
        this._fastBodyCollisions = 0;
        this._broadphase = 0;
        this._narrowphase = 0;
    }
    /**
     * Zero out values or clone other IPhysicsStats stats. Allows instance reuse.
     *
     * @param [otherStats] Optional stats to clone
     */
    reset(otherStats) {
        if (otherStats) {
            this.pairs = otherStats.pairs;
            this.collisions = otherStats.collisions;
            this.contacts = otherStats.contacts;
            this.fastBodies = otherStats.fastBodies;
            this.fastBodyCollisions = otherStats.fastBodyCollisions;
            this.broadphase = otherStats.broadphase;
            this.narrowphase = otherStats.narrowphase;
        }
        else {
            this.pairs = this.collisions = this.fastBodies = 0;
            this.fastBodyCollisions = this.broadphase = this.narrowphase = 0;
            this.contacts.clear();
        }
    }
    /**
     * Provides a clone of this instance.
     */
    clone() {
        const ps = new PhysicsStats();
        ps.reset(this);
        return ps;
    }
    get pairs() {
        return this._pairs;
    }
    set pairs(value) {
        this._pairs = value;
    }
    get collisions() {
        return this._collisions;
    }
    set collisions(value) {
        this._collisions = value;
    }
    get contacts() {
        return this._contacts;
    }
    set contacts(contacts) {
        this._contacts = contacts;
    }
    get fastBodies() {
        return this._fastBodies;
    }
    set fastBodies(value) {
        this._fastBodies = value;
    }
    get fastBodyCollisions() {
        return this._fastBodyCollisions;
    }
    set fastBodyCollisions(value) {
        this._fastBodyCollisions = value;
    }
    get broadphase() {
        return this._broadphase;
    }
    set broadphase(value) {
        this._broadphase = value;
    }
    get narrowphase() {
        return this._narrowphase;
    }
    set narrowphase(value) {
        this._narrowphase = value;
    }
}

;// CONCATENATED MODULE: ./Input/Keyboard.ts



/**
 * Enum representing physical input key codes
 */
var Keys;
(function (Keys) {
    // NUMPAD
    Keys["Num0"] = "Numpad0";
    Keys["Num1"] = "Numpad1";
    Keys["Num2"] = "Numpad2";
    Keys["Num3"] = "Numpad3";
    Keys["Num4"] = "Numpad4";
    Keys["Num5"] = "Numpad5";
    Keys["Num6"] = "Numpad6";
    Keys["Num7"] = "Numpad7";
    Keys["Num8"] = "Numpad8";
    Keys["Num9"] = "Numpad9";
    Keys["NumAdd"] = "NumpadAdd";
    Keys["NumSubtract"] = "NumpadSubtract";
    Keys["NumMultiply"] = "NumpadMultiply";
    Keys["NumDivide"] = "NumpadDivide";
    // NumComma = 'NumpadComma', // not x-browser
    Keys["NumDecimal"] = "NumpadDecimal";
    Keys["Numpad0"] = "Numpad0";
    Keys["Numpad1"] = "Numpad1";
    Keys["Numpad2"] = "Numpad2";
    Keys["Numpad3"] = "Numpad3";
    Keys["Numpad4"] = "Numpad4";
    Keys["Numpad5"] = "Numpad5";
    Keys["Numpad6"] = "Numpad6";
    Keys["Numpad7"] = "Numpad7";
    Keys["Numpad8"] = "Numpad8";
    Keys["Numpad9"] = "Numpad9";
    Keys["NumpadAdd"] = "NumpadAdd";
    Keys["NumpadSubtract"] = "NumpadSubtract";
    Keys["NumpadMultiply"] = "NumpadMultiply";
    Keys["NumpadDivide"] = "NumpadDivide";
    // NumpadComma = 'NumpadComma', // not x-browser
    Keys["NumpadDecimal"] = "NumpadDecimal";
    // MODIFIERS
    Keys["NumLock"] = "NumLock";
    Keys["ShiftLeft"] = "ShiftLeft";
    Keys["ShiftRight"] = "ShiftRight";
    Keys["AltLeft"] = "AltLeft";
    Keys["AltRight"] = "AltRight";
    // NUMBERS
    Keys["Key0"] = "Digit0";
    Keys["Key1"] = "Digit1";
    Keys["Key2"] = "Digit2";
    Keys["Key3"] = "Digit3";
    Keys["Key4"] = "Digit4";
    Keys["Key5"] = "Digit5";
    Keys["Key6"] = "Digit6";
    Keys["Key7"] = "Digit7";
    Keys["Key8"] = "Digit8";
    Keys["Key9"] = "Digit9";
    Keys["Digit0"] = "Digit0";
    Keys["Digit1"] = "Digit1";
    Keys["Digit2"] = "Digit2";
    Keys["Digit3"] = "Digit3";
    Keys["Digit4"] = "Digit4";
    Keys["Digit5"] = "Digit5";
    Keys["Digit6"] = "Digit6";
    Keys["Digit7"] = "Digit7";
    Keys["Digit8"] = "Digit8";
    Keys["Digit9"] = "Digit9";
    // LETTERS
    Keys["A"] = "KeyA";
    Keys["B"] = "KeyB";
    Keys["C"] = "KeyC";
    Keys["D"] = "KeyD";
    Keys["E"] = "KeyE";
    Keys["F"] = "KeyF";
    Keys["G"] = "KeyG";
    Keys["H"] = "KeyH";
    Keys["I"] = "KeyI";
    Keys["J"] = "KeyJ";
    Keys["K"] = "KeyK";
    Keys["L"] = "KeyL";
    Keys["M"] = "KeyM";
    Keys["N"] = "KeyN";
    Keys["O"] = "KeyO";
    Keys["P"] = "KeyP";
    Keys["Q"] = "KeyQ";
    Keys["R"] = "KeyR";
    Keys["S"] = "KeyS";
    Keys["T"] = "KeyT";
    Keys["U"] = "KeyU";
    Keys["V"] = "KeyV";
    Keys["W"] = "KeyW";
    Keys["X"] = "KeyX";
    Keys["Y"] = "KeyY";
    Keys["Z"] = "KeyZ";
    Keys["KeyA"] = "KeyA";
    Keys["KeyB"] = "KeyB";
    Keys["KeyC"] = "KeyC";
    Keys["KeyD"] = "KeyD";
    Keys["KeyE"] = "KeyE";
    Keys["KeyF"] = "KeyF";
    Keys["KeyG"] = "KeyG";
    Keys["KeyH"] = "KeyH";
    Keys["KeyI"] = "KeyI";
    Keys["KeyJ"] = "KeyJ";
    Keys["KeyK"] = "KeyK";
    Keys["KeyL"] = "KeyL";
    Keys["KeyM"] = "KeyM";
    Keys["KeyN"] = "KeyN";
    Keys["KeyO"] = "KeyO";
    Keys["KeyP"] = "KeyP";
    Keys["KeyQ"] = "KeyQ";
    Keys["KeyR"] = "KeyR";
    Keys["KeyS"] = "KeyS";
    Keys["KeyT"] = "KeyT";
    Keys["KeyU"] = "KeyU";
    Keys["KeyV"] = "KeyV";
    Keys["KeyW"] = "KeyW";
    Keys["KeyX"] = "KeyX";
    Keys["KeyY"] = "KeyY";
    Keys["KeyZ"] = "KeyZ";
    // SYMBOLS
    Keys["Semicolon"] = "Semicolon";
    Keys["Quote"] = "Quote";
    Keys["Comma"] = "Comma";
    Keys["Minus"] = "Minus";
    Keys["Period"] = "Period";
    Keys["Slash"] = "Slash";
    Keys["Equal"] = "Equal";
    Keys["BracketLeft"] = "BracketLeft";
    Keys["Backslash"] = "Backslash";
    Keys["BracketRight"] = "BracketRight";
    Keys["Backquote"] = "Backquote";
    // DIRECTIONS
    Keys["Up"] = "ArrowUp";
    Keys["Down"] = "ArrowDown";
    Keys["Left"] = "ArrowLeft";
    Keys["Right"] = "ArrowRight";
    Keys["ArrowUp"] = "ArrowUp";
    Keys["ArrowDown"] = "ArrowDown";
    Keys["ArrowLeft"] = "ArrowLeft";
    Keys["ArrowRight"] = "ArrowRight";
    // OTHER
    Keys["Space"] = "Space";
    Keys["Esc"] = "Escape";
    Keys["Escape"] = "Escape";
})(Keys || (Keys = {}));
/**
 * Event thrown on a game object for a key event
 */
class KeyEvent extends GameEvent {
    /**
     * @param key  The key responsible for throwing the event
     * @param value The key's typed value the browser detected
     * @param originalEvent The original keyboard event that Excalibur handled
     */
    constructor(key, value, originalEvent) {
        super();
        this.key = key;
        this.value = value;
        this.originalEvent = originalEvent;
    }
}
/**
 * Provides keyboard support for Excalibur.
 */
class Keyboard extends Class {
    constructor() {
        super();
        this._keys = [];
        this._keysUp = [];
        this._keysDown = [];
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    /**
     * Initialize Keyboard event listeners
     */
    init(global) {
        if (!global) {
            try {
                // Try and listen to events on top window frame if within an iframe.
                //
                // See https://github.com/excaliburjs/Excalibur/issues/1294
                //
                // Attempt to add an event listener, which triggers a DOMException on
                // cross-origin iframes
                const noop = () => {
                    return;
                };
                window.top.addEventListener('blur', noop);
                window.top.removeEventListener('blur', noop);
                // this will be the same as window if not embedded within an iframe
                global = window.top;
            }
            catch (_a) {
                // fallback to current frame
                global = window;
                Logger.getInstance().warn('Failed to bind to keyboard events to top frame. ' +
                    'If you are trying to embed Excalibur in a cross-origin iframe, keyboard events will not fire.');
            }
        }
        global.addEventListener('blur', () => {
            this._keys.length = 0; // empties array efficiently
        });
        // key up is on window because canvas cannot have focus
        global.addEventListener('keyup', (ev) => {
            const code = ev.code;
            const key = this._keys.indexOf(code);
            this._keys.splice(key, 1);
            this._keysUp.push(code);
            const keyEvent = new KeyEvent(code, ev.key, ev);
            // alias the old api, we may want to deprecate this in the future
            this.eventDispatcher.emit('up', keyEvent);
            this.eventDispatcher.emit('release', keyEvent);
        });
        // key down is on window because canvas cannot have focus
        global.addEventListener('keydown', (ev) => {
            const code = ev.code;
            if (this._keys.indexOf(code) === -1) {
                this._keys.push(code);
                this._keysDown.push(code);
                const keyEvent = new KeyEvent(code, ev.key, ev);
                this.eventDispatcher.emit('down', keyEvent);
                this.eventDispatcher.emit('press', keyEvent);
            }
        });
    }
    update() {
        // Reset keysDown and keysUp after update is complete
        this._keysDown.length = 0;
        this._keysUp.length = 0;
        // Emit synthetic "hold" event
        for (let i = 0; i < this._keys.length; i++) {
            this.eventDispatcher.emit('hold', new KeyEvent(this._keys[i]));
        }
    }
    /**
     * Gets list of keys being pressed down
     */
    getKeys() {
        return this._keys;
    }
    /**
     * Tests if a certain key was just pressed this frame. This is cleared at the end of the update frame.
     * @param key Test whether a key was just pressed
     */
    wasPressed(key) {
        return this._keysDown.indexOf(key) > -1;
    }
    /**
     * Tests if a certain key is held down. This is persisted between frames.
     * @param key  Test whether a key is held down
     */
    isHeld(key) {
        return this._keys.indexOf(key) > -1;
    }
    /**
     * Tests if a certain key was just released this frame. This is cleared at the end of the update frame.
     * @param key  Test whether a key was just released
     */
    wasReleased(key) {
        return this._keysUp.indexOf(key) > -1;
    }
}

;// CONCATENATED MODULE: ./Input/Pointer.ts




/**
 * The type of pointer for a [[PointerEvent]].
 */
var PointerType;
(function (PointerType) {
    PointerType["Touch"] = "Touch";
    PointerType["Mouse"] = "Mouse";
    PointerType["Pen"] = "Pen";
    PointerType["Unknown"] = "Unknown";
})(PointerType || (PointerType = {}));
/**
 * Determines the scope of handling mouse/touch events. See [[Pointers]] for more information.
 */
var PointerScope;
(function (PointerScope) {
    /**
     * Handle events on the `canvas` element only. Events originating outside the
     * `canvas` will not be handled.
     */
    PointerScope["Canvas"] = "Canvas";
    /**
     * Handles events on the entire document. All events will be handled by Excalibur.
     */
    PointerScope["Document"] = "Document";
})(PointerScope || (PointerScope = {}));
/**
 * Captures and dispatches PointerEvents
 */
class Pointer extends Class {
    constructor() {
        super();
        this.id = Pointer._MAX_ID++;
        this._isDown = false;
        this._wasDown = false;
        this._actorsUnderPointer = { length: 0 };
        this._actors = [];
        this._actorsLastFrame = [];
        this._actorsNoLongerUnderPointer = [];
        this._actorSortingFcn = (a, b) => {
            if (a.z === b.z) {
                return b.id - a.id;
            }
            return b.z - a.z;
        };
        /**
         * The last position on the document this pointer was at. Can be `null` if pointer was never active.
         */
        this.lastPagePos = null;
        /**
         * The last position on the screen this pointer was at. Can be `null` if pointer was never active.
         */
        this.lastScreenPos = null;
        /**
         * The last position in the game world coordinates this pointer was at. Can be `null` if pointer was never active.
         */
        this.lastWorldPos = null;
        /**
         * Returns the currently dragging target or null if it isn't exist
         */
        this.dragTarget = null;
        this.on('move', this._onPointerMove);
        this.on('down', this._onPointerDown);
        this.on('up', this._onPointerUp);
    }
    /**
     * Whether the Pointer is currently dragging.
     */
    get isDragging() {
        return this._isDown;
    }
    /**
     * Whether the Pointer just started dragging.
     */
    get isDragStart() {
        return !this._wasDown && this._isDown;
    }
    /**
     * Whether the Pointer just ended dragging.
     */
    get isDragEnd() {
        return this._wasDown && !this._isDown;
    }
    /**
     * Returns true if pointer has any actors under
     */
    get hasActorsUnderPointer() {
        return !!this._actorsUnderPointer.length;
    }
    on(event, handler) {
        super.on(event, handler);
    }
    once(event, handler) {
        super.once(event, handler);
    }
    off(event, handler) {
        super.off(event, handler);
    }
    /**
     * Update the state of current pointer, meant to be called a the end of frame
     */
    update() {
        if (this._wasDown && !this._isDown) {
            this._wasDown = false;
        }
        else if (!this._wasDown && this._isDown) {
            this._wasDown = true;
        }
        this._actorsLastFrame = [...this._actors];
        this._actorsNoLongerUnderPointer = [];
    }
    /**
     * Adds an Actor to actorsUnderPointer object.
     * @param actor An Actor to be added;
     */
    addActorUnderPointer(actor) {
        if (!this.isActorAliveUnderPointer(actor)) {
            this._actorsUnderPointer[actor.id] = actor;
            this._actorsUnderPointer.length += 1;
            this._actors.push(actor);
        }
        // Actors are processed in z-order highest z to lowest
        // ties are broken by id highest id (newest) to lowest id (oldest)
        this._actors.sort(this._actorSortingFcn);
    }
    /**
     * Removes an Actor from actorsUnderPointer object.
     * @param actor An Actor to be removed;
     */
    removeActorUnderPointer(actor) {
        if (this.isActorAliveUnderPointer(actor)) {
            delete this._actorsUnderPointer[actor.id];
            this._actorsUnderPointer.length -= 1;
            removeItemFromArray(actor, this._actors);
            this._actorsNoLongerUnderPointer.push(actor);
        }
    }
    /**
     * Returns all actors under this pointer this frame
     */
    getActorsUnderPointer() {
        return this._actors;
    }
    /**
     * Returns all actors that are no longer under the pointer this frame
     */
    getActorsUnderPointerLastFrame() {
        return this._actorsLastFrame;
    }
    /**
     * Returns all actors relevant for events to pointer this frame
     */
    getActorsForEvents() {
        return this._actors
            .concat(this._actorsLastFrame)
            .filter((actor, i, self) => {
            return self.indexOf(actor) === i; // de-dup
        })
            .sort(this._actorSortingFcn); // sort by z
    }
    /**
     * Checks if Pointer location has a specific Actor bounds contained underneath.
     * @param actor An Actor for check;
     */
    checkActorUnderPointer(actor) {
        if (this.lastWorldPos) {
            return actor.contains(this.lastWorldPos.x, this.lastWorldPos.y, !isScreenElement(actor));
        }
        return false;
    }
    /**
     * Checks if an actor was under the pointer last frame
     * @param actor
     */
    wasActorUnderPointer(actor) {
        return this._actorsLastFrame.indexOf(actor) > -1;
    }
    /**
     * Checks if Pointer has a specific Actor in ActorsUnderPointer list.
     * @param actor An Actor for check;
     */
    isActorAliveUnderPointer(actor) {
        return !!(!actor.isKilled() && actor.scene && this._actorsUnderPointer.hasOwnProperty(actor.id.toString()));
    }
    _onPointerMove(ev) {
        this.lastPagePos = new Vector(ev.pagePos.x, ev.pagePos.y);
        this.lastScreenPos = new Vector(ev.screenPos.x, ev.screenPos.y);
        this.lastWorldPos = new Vector(ev.worldPos.x, ev.worldPos.y);
    }
    _onPointerDown(ev) {
        this.lastPagePos = new Vector(ev.pagePos.x, ev.pagePos.y);
        this.lastScreenPos = new Vector(ev.screenPos.x, ev.screenPos.y);
        this.lastWorldPos = new Vector(ev.worldPos.x, ev.worldPos.y);
        this._isDown = true;
    }
    _onPointerUp(_ev) {
        this._isDown = false;
        this.dragTarget = null;
    }
}
Pointer._MAX_ID = 0;

;// CONCATENATED MODULE: ./Input/PointerEvents.ts

/**
 * Native browser button enumeration
 */
var NativePointerButton;
(function (NativePointerButton) {
    NativePointerButton[NativePointerButton["NoButton"] = -1] = "NoButton";
    NativePointerButton[NativePointerButton["Left"] = 0] = "Left";
    NativePointerButton[NativePointerButton["Middle"] = 1] = "Middle";
    NativePointerButton[NativePointerButton["Right"] = 2] = "Right";
    NativePointerButton[NativePointerButton["Unknown"] = 3] = "Unknown";
})(NativePointerButton || (NativePointerButton = {}));
/**
 * The mouse button being pressed.
 */
var PointerButton;
(function (PointerButton) {
    PointerButton["Left"] = "Left";
    PointerButton["Middle"] = "Middle";
    PointerButton["Right"] = "Right";
    PointerButton["Unknown"] = "Unknown";
    PointerButton["NoButton"] = "NoButton";
})(PointerButton || (PointerButton = {}));
var WheelDeltaMode;
(function (WheelDeltaMode) {
    WheelDeltaMode["Pixel"] = "Pixel";
    WheelDeltaMode["Line"] = "Line";
    WheelDeltaMode["Page"] = "Page";
})(WheelDeltaMode || (WheelDeltaMode = {}));
/**
 * Pointer events
 *
 * Represents a mouse, touch, or stylus event. See [[Pointers]] for more information on
 * handling pointer input.
 *
 * For mouse-based events, you can inspect [[PointerEvent.button]] to see what button was pressed.
 */
class PointerEvent extends GameEvent {
    /**
     * @param coordinates         The [[GlobalCoordinates]] of the event
     * @param pointer             The [[Pointer]] of the event
     * @param index               The index of the pointer (zero-based)
     * @param pointerType         The type of pointer
     * @param button              The button pressed (if [[PointerType.Mouse]])
     * @param ev                  The raw DOM event being handled
     */
    constructor(coordinates, pointer, index, pointerType, button, ev) {
        super();
        this.coordinates = coordinates;
        this.pointer = pointer;
        this.index = index;
        this.pointerType = pointerType;
        this.button = button;
        this.ev = ev;
        this._canceled = false;
    }
    get name() {
        return this._name;
    }
    /** The world coordinates of the event. */
    get worldPos() {
        return this.coordinates.worldPos.clone();
    }
    /** The page coordinates of the event. */
    get pagePos() {
        return this.coordinates.pagePos.clone();
    }
    /** The screen coordinates of the event. */
    get screenPos() {
        return this.coordinates.screenPos.clone();
    }
    get pos() {
        return this.coordinates.worldPos.clone();
    }
    /**
     * Cancels pointer event propogation, event will not be transmitted to any other actors
     */
    cancel() {
        this._canceled = true;
    }
    /**
     *
     * @returns If the event is canceled it will no longer be transmitted to any other actors
     */
    isCanceled() {
        return this._canceled;
    }
    propagate(actor) {
        this.doAction(actor);
        if (this.bubbles && !this.isCanceled() && actor.parent) {
            this.propagate(actor.parent); // TODO not true
        }
    }
    /**
     * Action, that calls when event happens
     */
    doAction(actor) {
        if (actor) {
            this._onActionStart(actor);
            actor.emit(this._name, this);
            this._onActionEnd(actor);
        }
    }
    _onActionStart(_actor) {
        // to be rewritten
    }
    _onActionEnd(_actor) {
        // to be rewritten
    }
}
class PointerEventFactory {
    constructor(_pointerEventType) {
        this._pointerEventType = _pointerEventType;
    }
    /**
     * Create specific PointerEvent
     */
    create(coordinates, pointer, index, pointerType, button, ev) {
        return new this._pointerEventType(coordinates, pointer, index, pointerType, button, ev);
    }
}
class PointerDragEvent extends PointerEvent {
}
class PointerUpEvent extends PointerEvent {
    constructor() {
        super(...arguments);
        this._name = 'pointerup';
    }
    _onActionEnd(actor) {
        const pointer = this.pointer;
        if (pointer.isDragEnd && actor.capturePointer.captureDragEvents) {
            actor.eventDispatcher.emit('pointerdragend', this);
        }
    }
}
class PointerDownEvent extends PointerEvent {
    constructor() {
        super(...arguments);
        this._name = 'pointerdown';
    }
    _onActionEnd(actor) {
        if (this.pointer.isDragStart && actor.capturePointer.captureDragEvents) {
            actor.eventDispatcher.emit('pointerdragstart', this);
        }
    }
}
class PointerMoveEvent extends PointerEvent {
    constructor() {
        super(...arguments);
        this._name = 'pointermove';
        // private _onActorEnter(actor: Actor) {
        //   const pe = createPointerEventByName('enter', this.coordinates, this.pointer, this.index, this.pointerType, this.button, this.ev);
        //   pe.propagate(actor);
        //   this.pointer.addActorUnderPointer(actor);
        //   if (this.pointer.isDragging) {
        //     this.pointer.dragTarget = actor;
        //   }
        // }
        // private _onActorLeave(actor: Actor) {
        //   const pe = createPointerEventByName('leave', this.coordinates, this.pointer, this.index, this.pointerType, this.button, this.ev);
        //   pe.propagate(actor);
        //   this.pointer.removeActorUnderPointer(actor);
        // }
    }
    propagate(actor) {
        // If the actor was under the pointer last frame, but not this one it left
        // if (this.pointer.wasActorUnderPointer(actor) && !this.pointer.isActorUnderPointer(actor)) {
        //   this._onActorLeave(actor);
        //   return;
        // }
        if (this.pointer.isActorAliveUnderPointer(actor)) {
            this.doAction(actor);
            if (this.bubbles && !this.isCanceled() && actor.parent) {
                this.propagate(actor.parent); // TODO not true
            }
        }
    }
    _onActionStart(actor) {
        if (!actor.capturePointer.captureMoveEvents) {
            return;
        }
        // In the case this is new
        // if (this.pointer.checkActorUnderPointer(actor) && !this.pointer.wasActorUnderPointer(actor)) {
        //   this._onActorEnter(actor);
        // }
        if (this.pointer.isDragging && actor.capturePointer.captureDragEvents) {
            actor.eventDispatcher.emit('pointerdragmove', this);
        }
    }
}
class PointerEnterEvent extends PointerEvent {
    constructor() {
        super(...arguments);
        this._name = 'pointerenter';
    }
    _onActionStart(actor) {
        if (!actor.capturePointer.captureMoveEvents) {
            return;
        }
    }
    _onActionEnd(actor) {
        const pointer = this.pointer;
        if (pointer.isDragging && actor.capturePointer.captureDragEvents) {
            actor.eventDispatcher.emit('pointerdragenter', this);
        }
    }
}
class PointerLeaveEvent extends PointerEvent {
    constructor() {
        super(...arguments);
        this._name = 'pointerleave';
    }
    _onActionStart(actor) {
        if (!actor.capturePointer.captureMoveEvents) {
            return;
        }
    }
    _onActionEnd(actor) {
        const pointer = this.pointer;
        if (pointer.isDragging && actor.capturePointer.captureDragEvents) {
            actor.eventDispatcher.emit('pointerdragleave', this);
        }
    }
}
class PointerCancelEvent extends PointerEvent {
    constructor() {
        super(...arguments);
        this._name = 'pointercancel';
    }
}
/**
 * Wheel Events
 *
 * Represents a mouse wheel event. See [[Pointers]] for more information on
 * handling point input.
 */
class WheelEvent extends GameEvent {
    /**
     * @param x            The `x` coordinate of the event (in world coordinates)
     * @param y            The `y` coordinate of the event (in world coordinates)
     * @param pageX        The `x` coordinate of the event (in document coordinates)
     * @param pageY        The `y` coordinate of the event (in document coordinates)
     * @param screenX      The `x` coordinate of the event (in screen coordinates)
     * @param screenY      The `y` coordinate of the event (in screen coordinates)
     * @param index        The index of the pointer (zero-based)
     * @param deltaX       The type of pointer
     * @param deltaY       The type of pointer
     * @param deltaZ       The type of pointer
     * @param deltaMode    The type of movement [[WheelDeltaMode]]
     * @param ev           The raw DOM event being handled
     */
    constructor(x, y, pageX, pageY, screenX, screenY, index, deltaX, deltaY, deltaZ, deltaMode, ev) {
        super();
        this.x = x;
        this.y = y;
        this.pageX = pageX;
        this.pageY = pageY;
        this.screenX = screenX;
        this.screenY = screenY;
        this.index = index;
        this.deltaX = deltaX;
        this.deltaY = deltaY;
        this.deltaZ = deltaZ;
        this.deltaMode = deltaMode;
        this.ev = ev;
        this._isCanceled = false;
    }
    /**
     * Cancels pointer event propogation, event will not be transmitted to any other actors
     */
    cancel() {
        this._isCanceled = true;
    }
    /**
     *
     * @returns If the event is canceled it will no longer be transmitted to any other actors
     */
    isCanceled() {
        return this._isCanceled;
    }
}
/**
 *
 */
function createPointerEventByName(eventName, coordinates, pointer, index, pointerType, button, ev) {
    let factory;
    switch (eventName) {
        case 'up':
            factory = new PointerEventFactory(PointerUpEvent);
            break;
        case 'down':
            factory = new PointerEventFactory(PointerDownEvent);
            break;
        case 'move':
            factory = new PointerEventFactory(PointerMoveEvent);
            break;
        case 'cancel':
            factory = new PointerEventFactory(PointerCancelEvent);
            break;
        case 'enter':
            factory = new PointerEventFactory(PointerEnterEvent);
            break;
        case 'leave':
            factory = new PointerEventFactory(PointerLeaveEvent);
            break;
    }
    return factory.create(coordinates, pointer, index, pointerType, button, ev);
}

;// CONCATENATED MODULE: ./Math/global-coordinates.ts

class GlobalCoordinates {
    constructor(worldPos, pagePos, screenPos) {
        this.worldPos = worldPos;
        this.pagePos = pagePos;
        this.screenPos = screenPos;
    }
    static fromPagePosition(xOrPos, yOrEngine, engineOrUndefined) {
        let pageX;
        let pageY;
        let pagePos;
        let engine;
        if (arguments.length === 3) {
            pageX = xOrPos;
            pageY = yOrEngine;
            pagePos = new Vector(pageX, pageY);
            engine = engineOrUndefined;
        }
        else {
            pagePos = xOrPos;
            pageX = pagePos.x;
            pageY = pagePos.y;
            engine = yOrEngine;
        }
        const screenPos = engine.screen.pageToScreenCoordinates(pagePos);
        const worldPos = engine.screen.screenToWorldCoordinates(screenPos);
        return new GlobalCoordinates(worldPos, pagePos, screenPos);
    }
}

;// CONCATENATED MODULE: ./Input/Pointers.ts








/**
 * A constant used to normalize wheel events across different browsers
 *
 * This normalization factor is pulled from https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Listening_to_this_event_across_browser
 */
const ScrollWheelNormalizationFactor = -1 / 40;
/**
 * Handles pointer events (mouse, touch, stylus, etc.) and normalizes to
 * [W3C Pointer Events](http://www.w3.org/TR/pointerevents/).
 */
class Pointers extends Class {
    constructor(engine) {
        super();
        this._pointerDown = [];
        this._pointerUp = [];
        this._pointerMove = [];
        this._pointerCancel = [];
        this._wheel = [];
        this._pointers = [];
        this._activePointers = [];
        this._engine = engine;
        this._pointers.push(new Pointer());
        this._activePointers = [-1];
        this.primary = this._pointers[0];
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    /**
     * Initializes pointer event listeners
     */
    init(target) {
        target = target || this._engine.canvas;
        // Touch Events
        target.addEventListener('touchstart', this._handleTouchEvent('down', this._pointerDown));
        target.addEventListener('touchend', this._handleTouchEvent('up', this._pointerUp));
        target.addEventListener('touchmove', this._handleTouchEvent('move', this._pointerMove));
        target.addEventListener('touchcancel', this._handleTouchEvent('cancel', this._pointerCancel));
        // W3C Pointer Events
        // Current: IE11, IE10
        if (window.PointerEvent) {
            // IE11
            this._engine.canvas.style.touchAction = 'none';
            target.addEventListener('pointerdown', this._handlePointerEvent('down', this._pointerDown));
            target.addEventListener('pointerup', this._handlePointerEvent('up', this._pointerUp));
            target.addEventListener('pointermove', this._handlePointerEvent('move', this._pointerMove));
            target.addEventListener('pointercancel', this._handlePointerEvent('cancel', this._pointerCancel));
        }
        else if (window.MSPointerEvent) {
            // IE10
            this._engine.canvas.style.msTouchAction = 'none';
            target.addEventListener('MSPointerDown', this._handlePointerEvent('down', this._pointerDown));
            target.addEventListener('MSPointerUp', this._handlePointerEvent('up', this._pointerUp));
            target.addEventListener('MSPointerMove', this._handlePointerEvent('move', this._pointerMove));
            target.addEventListener('MSPointerCancel', this._handlePointerEvent('cancel', this._pointerCancel));
        }
        else {
            // Mouse Events
            target.addEventListener('mousedown', this._handleMouseEvent('down', this._pointerDown));
            target.addEventListener('mouseup', this._handleMouseEvent('up', this._pointerUp));
            target.addEventListener('mousemove', this._handleMouseEvent('move', this._pointerMove));
        }
        // MDN MouseWheelEvent
        const wheelOptions = {
            passive: !(this._engine.pageScrollPreventionMode === ScrollPreventionMode.All ||
                this._engine.pageScrollPreventionMode === ScrollPreventionMode.Canvas)
        };
        if ('onwheel' in document.createElement('div')) {
            // Modern Browsers
            target.addEventListener('wheel', this._handleWheelEvent('wheel', this._wheel), wheelOptions);
        }
        else if (document.onmousewheel !== undefined) {
            // Webkit and IE
            target.addEventListener('mousewheel', this._handleWheelEvent('wheel', this._wheel), wheelOptions);
        }
        else {
            // Remaining browser and older Firefox
            target.addEventListener('MozMousePixelScroll', this._handleWheelEvent('wheel', this._wheel), wheelOptions);
        }
    }
    /**
     * Synthesize a pointer event that looks like a real browser event to excalibur
     * @param eventName
     * @param pos
     */
    triggerEvent(eventName, pos, button = NativePointerButton.Left, pointerType = 'mouse', pointerId = 0) {
        let x = 0;
        let y = 0;
        let coords;
        if (pos instanceof GlobalCoordinates) {
            x = pos.pagePos.x;
            y = pos.pagePos.y;
            coords = pos;
        }
        else {
            x = pos.x;
            y = pos.y;
            coords = new GlobalCoordinates(pos.clone(), pos.clone(), pos.clone());
        }
        const eventish = {
            pageX: x,
            pageY: y,
            pointerId: pointerId,
            pointerType: pointerType,
            button: button,
            preventDefault: () => {
                /* do nothing */
            }
        };
        switch (eventName) {
            case 'move':
                this._handlePointerEvent(eventName, this._pointerMove, coords)(eventish);
                break;
            case 'down':
                this._handlePointerEvent(eventName, this._pointerDown, coords)(eventish);
                break;
            case 'up':
                this._handlePointerEvent(eventName, this._pointerUp, coords)(eventish);
                break;
            case 'cancel':
                this._handlePointerEvent(eventName, this._pointerCancel, coords)(eventish);
                break;
        }
        for (const actor of this._engine.currentScene.actors) {
            const capturePointer = actor.traits.filter((t) => t instanceof CapturePointer)[0];
            if (capturePointer) {
                capturePointer.update(actor, this._engine, 1);
            }
        }
        this.dispatchPointerEvents();
        this.update();
    }
    /**
     * Update all pointer events and pointers, meant to be called at the end of frame
     */
    update() {
        this._pointerUp.length = 0;
        this._pointerDown.length = 0;
        this._pointerMove.length = 0;
        this._pointerCancel.length = 0;
        this._wheel.length = 0;
        for (let i = 0; i < this._pointers.length; i++) {
            this._pointers[i].update();
        }
    }
    /**
     * Safely gets a Pointer at a specific index and initializes one if it doesn't yet exist
     * @param index  The pointer index to retrieve
     */
    at(index) {
        if (index >= this._pointers.length) {
            // Ensure there is a pointer to retrieve
            for (let i = this._pointers.length - 1, max = index; i < max; i++) {
                this._pointers.push(new Pointer());
                this._activePointers.push(-1);
            }
        }
        return this._pointers[index];
    }
    /**
     * Get number of pointers being watched
     */
    count() {
        return this._pointers.length;
    }
    checkAndUpdateActorUnderPointer(actor) {
        for (const pointer of this._pointers) {
            if (pointer.checkActorUnderPointer(actor)) {
                pointer.addActorUnderPointer(actor);
            }
            else {
                pointer.removeActorUnderPointer(actor);
            }
        }
    }
    _dispatchWithBubble(events) {
        for (const evt of events) {
            for (const actor of evt.pointer.getActorsForEvents()) {
                if (!evt.isCanceled()) {
                    evt.propagate(actor);
                }
                if (!evt.bubbles || evt.isCanceled()) {
                    // if the event stops bubbling part way stop processing
                    break;
                }
            }
        }
    }
    _dispatchPointerLeaveEvents() {
        const lastMoveEventPerPointerPerActor = {};
        const pointerLeave = [];
        for (const evt of this._pointerMove) {
            for (const actor of evt.pointer.getActorsForEvents()) {
                // If the actor was under the pointer last frame, but not this this frame, pointer left
                if (!lastMoveEventPerPointerPerActor[evt.pointer.id + '+' + actor.id] &&
                    evt.pointer.wasActorUnderPointer(actor) &&
                    !evt.pointer.isActorAliveUnderPointer(actor) &&
                    !evt.isCanceled()) {
                    lastMoveEventPerPointerPerActor[evt.pointer.id + '+' + actor.id] = evt;
                    const pe = createPointerEventByName('leave', new GlobalCoordinates(evt.worldPos, evt.pagePos, evt.screenPos), evt.pointer, evt.index, evt.pointerType, evt.button, evt.ev);
                    pe.propagate(actor);
                    pointerLeave.push(pe);
                }
            }
        }
        return pointerLeave;
    }
    _dispatchPointerEnterEvents() {
        const lastMoveEventPerPointer = {};
        const pointerEnter = [];
        for (const evt of this._pointerMove) {
            for (const actor of evt.pointer.getActorsForEvents()) {
                // If the actor was not under the pointer last frame, but it is this frame, pointer entered
                if (!lastMoveEventPerPointer[evt.pointer.id] &&
                    !evt.pointer.wasActorUnderPointer(actor) &&
                    evt.pointer.isActorAliveUnderPointer(actor) &&
                    !evt.isCanceled()) {
                    lastMoveEventPerPointer[evt.pointer.id] = evt;
                    const pe = createPointerEventByName('enter', new GlobalCoordinates(evt.worldPos, evt.pagePos, evt.screenPos), evt.pointer, evt.index, evt.pointerType, evt.button, evt.ev);
                    pe.propagate(actor);
                    pointerEnter.push(pe);
                    // if pointer is dragging set the drag target
                    if (evt.pointer.isDragging) {
                        evt.pointer.dragTarget = actor;
                    }
                }
            }
        }
        return pointerEnter;
    }
    dispatchPointerEvents() {
        this._dispatchWithBubble(this._pointerDown);
        this._dispatchWithBubble(this._pointerUp);
        this._dispatchWithBubble(this._pointerMove);
        this._dispatchPointerLeaveEvents();
        this._dispatchPointerEnterEvents();
        this._dispatchWithBubble(this._pointerCancel);
        // TODO some duplication here
        for (const evt of this._wheel) {
            for (const actor of this._pointers[evt.index].getActorsUnderPointer()) {
                this._propagateWheelPointerEvent(actor, evt);
                if (!evt.bubbles || evt.isCanceled()) {
                    // if the event stops bubbling part way stop processing
                    break;
                }
            }
        }
    }
    _propagateWheelPointerEvent(actor, wheelEvent) {
        actor.emit('pointerwheel', wheelEvent);
        // Recurse and propagate
        if (wheelEvent.bubbles && !wheelEvent.isCanceled() && actor.parent) {
            this._propagateWheelPointerEvent(actor.parent, wheelEvent); // TODO not true
        }
    }
    _handleMouseEvent(eventName, eventArr) {
        return (e) => {
            e.preventDefault();
            const pointer = this.at(0);
            const coordinates = GlobalCoordinates.fromPagePosition(e.pageX, e.pageY, this._engine);
            const pe = createPointerEventByName(eventName, coordinates, pointer, 0, PointerType.Mouse, this._nativeButtonToPointerButton(e.button), e);
            eventArr.push(pe);
            pointer.eventDispatcher.emit(eventName, pe);
        };
    }
    _handleTouchEvent(eventName, eventArr) {
        return (e) => {
            e.preventDefault();
            for (let i = 0, len = e.changedTouches.length; i < len; i++) {
                const index = this._pointers.length > 1 ? this._getPointerIndex(e.changedTouches[i].identifier) : 0;
                if (index === -1) {
                    continue;
                }
                const pointer = this.at(index);
                const coordinates = GlobalCoordinates.fromPagePosition(e.changedTouches[i].pageX, e.changedTouches[i].pageY, this._engine);
                const pe = createPointerEventByName(eventName, coordinates, pointer, index, PointerType.Touch, PointerButton.Unknown, e);
                eventArr.push(pe);
                pointer.eventDispatcher.emit(eventName, pe);
                this.emit(eventName, pe);
                // only with multi-pointer
                if (this._pointers.length > 1) {
                    if (eventName === 'up') {
                        // remove pointer ID from pool when pointer is lifted
                        this._activePointers[index] = -1;
                    }
                    else if (eventName === 'down') {
                        // set pointer ID to given index
                        this._activePointers[index] = e.changedTouches[i].identifier;
                    }
                }
            }
        };
    }
    _handlePointerEvent(eventName, eventArr, coords) {
        return (e) => {
            e.preventDefault();
            // get the index for this pointer ID if multi-pointer is asked for
            const index = this._pointers.length > 1 ? this._getPointerIndex(e.pointerId) : 0;
            if (index === -1) {
                return;
            }
            const pointer = this.at(index);
            const coordinates = coords || GlobalCoordinates.fromPagePosition(e.pageX, e.pageY, this._engine);
            const pe = createPointerEventByName(eventName, coordinates, pointer, index, this._stringToPointerType(e.pointerType), this._nativeButtonToPointerButton(e.button), e);
            eventArr.push(pe);
            pointer.eventDispatcher.emit(eventName, pe);
            this.emit(eventName, pe);
            // only with multi-pointer
            if (this._pointers.length > 1) {
                if (eventName === 'up') {
                    // remove pointer ID from pool when pointer is lifted
                    this._activePointers[index] = -1;
                }
                else if (eventName === 'down') {
                    // set pointer ID to given index
                    this._activePointers[index] = e.pointerId;
                }
            }
        };
    }
    _handleWheelEvent(eventName, eventArr) {
        return (e) => {
            // Should we prevent page scroll because of this event
            if (this._engine.pageScrollPreventionMode === ScrollPreventionMode.All ||
                (this._engine.pageScrollPreventionMode === ScrollPreventionMode.Canvas && e.target === this._engine.canvas)) {
                e.preventDefault();
            }
            const screen = this._engine.screen.pageToScreenCoordinates(vec(e.pageX, e.pageY));
            const world = this._engine.screen.screenToWorldCoordinates(screen);
            // deltaX, deltaY, and deltaZ are the standard modern properties
            // wheelDeltaX, wheelDeltaY, are legacy properties in webkit browsers and older IE
            // e.detail is only used in opera
            const deltaX = e.deltaX || e.wheelDeltaX * ScrollWheelNormalizationFactor || 0;
            const deltaY = e.deltaY || e.wheelDeltaY * ScrollWheelNormalizationFactor || e.wheelDelta * ScrollWheelNormalizationFactor || e.detail || 0;
            const deltaZ = e.deltaZ || 0;
            let deltaMode = WheelDeltaMode.Pixel;
            if (e.deltaMode) {
                if (e.deltaMode === 1) {
                    deltaMode = WheelDeltaMode.Line;
                }
                else if (e.deltaMode === 2) {
                    deltaMode = WheelDeltaMode.Page;
                }
            }
            const we = new WheelEvent(world.x, world.y, e.pageX, e.pageY, screen.x, screen.y, 0, deltaX, deltaY, deltaZ, deltaMode, e);
            eventArr.push(we);
            this.at(0).eventDispatcher.emit(eventName, we);
            this.emit(eventName, we);
        };
    }
    /**
     * Gets the index of the pointer specified for the given pointer ID or finds the next empty pointer slot available.
     * This is required because IE10/11 uses incrementing pointer IDs so we need to store a mapping of ID => idx
     */
    _getPointerIndex(pointerId) {
        let idx;
        if ((idx = this._activePointers.indexOf(pointerId)) > -1) {
            return idx;
        }
        for (let i = 0; i < this._activePointers.length; i++) {
            if (this._activePointers[i] === -1) {
                return i;
            }
        }
        // ignore pointer because game isn't watching
        return -1;
    }
    _nativeButtonToPointerButton(s) {
        switch (s) {
            case NativePointerButton.NoButton:
                return PointerButton.NoButton;
            case NativePointerButton.Left:
                return PointerButton.Left;
            case NativePointerButton.Middle:
                return PointerButton.Middle;
            case NativePointerButton.Right:
                return PointerButton.Right;
            case NativePointerButton.Unknown:
                return PointerButton.Unknown;
            default:
                return fail(s);
        }
    }
    _stringToPointerType(s) {
        switch (s) {
            case 'touch':
                return PointerType.Touch;
            case 'mouse':
                return PointerType.Mouse;
            case 'pen':
                return PointerType.Pen;
            default:
                return PointerType.Unknown;
        }
    }
}

;// CONCATENATED MODULE: ./Input/Gamepad.ts


/**
 * Excalibur leverages the HTML5 Gamepad API [where it is supported](http://caniuse.com/#feat=gamepad)
 * to provide controller support for your games.
 */
class Gamepads extends Class {
    constructor() {
        super();
        /**
         * Whether or not to poll for Gamepad input (default: `false`)
         */
        this.enabled = false;
        /**
         * Whether or not Gamepad API is supported
         */
        this.supported = !!navigator.getGamepads;
        this._gamePadTimeStamps = [0, 0, 0, 0];
        this._oldPads = [];
        this._pads = [];
        this._initSuccess = false;
        this._navigator = navigator;
        this._minimumConfiguration = null;
    }
    init() {
        if (!this.supported) {
            return;
        }
        if (this._initSuccess) {
            return;
        }
        // In Chrome, this will return 4 undefined items until a button is pressed
        // In FF, this will not return any items until a button is pressed
        this._oldPads = this._clonePads(this._navigator.getGamepads());
        if (this._oldPads.length && this._oldPads[0]) {
            this._initSuccess = true;
        }
    }
    /**
     * Sets the minimum gamepad configuration, for example {axis: 4, buttons: 4} means
     * this game requires at minimum 4 axis inputs and 4 buttons, this is not restrictive
     * all other controllers with more axis or buttons are valid as well. If no minimum
     * configuration is set all pads are valid.
     */
    setMinimumGamepadConfiguration(config) {
        this._enableAndUpdate(); // if config is used, implicitly enable
        this._minimumConfiguration = config;
    }
    /**
     * When implicitly enabled, set the enabled flag and run an update so information is updated
     */
    _enableAndUpdate() {
        if (!this.enabled) {
            this.enabled = true;
            this.update();
        }
    }
    /**
     * Checks a navigator gamepad against the minimum configuration if present.
     */
    _isGamepadValid(pad) {
        if (!this._minimumConfiguration) {
            return true;
        }
        if (!pad) {
            return false;
        }
        const axesLength = pad.axes.filter((value) => {
            return typeof value !== undefined;
        }).length;
        const buttonLength = pad.buttons.filter((value) => {
            return typeof value !== undefined;
        }).length;
        return axesLength >= this._minimumConfiguration.axis && buttonLength >= this._minimumConfiguration.buttons && pad.connected;
    }
    on(eventName, handler) {
        this._enableAndUpdate(); // implicitly enable
        super.on(eventName, handler);
    }
    off(eventName, handler) {
        this._enableAndUpdate(); // implicitly enable
        super.off(eventName, handler);
    }
    /**
     * Updates Gamepad state and publishes Gamepad events
     */
    update() {
        if (!this.enabled || !this.supported) {
            return;
        }
        this.init();
        const gamepads = this._navigator.getGamepads();
        for (let i = 0; i < gamepads.length; i++) {
            if (!gamepads[i]) {
                const gamepad = this.at(i);
                // If was connected, but now isn't emit the disconnect event
                if (gamepad.connected) {
                    this.eventDispatcher.emit('disconnect', new GamepadDisconnectEvent(i, gamepad));
                }
                // Reset connection status
                gamepad.connected = false;
                continue;
            }
            else {
                if (!this.at(i).connected && this._isGamepadValid(gamepads[i])) {
                    this.eventDispatcher.emit('connect', new GamepadConnectEvent(i, this.at(i)));
                }
                // Set connection status
                this.at(i).connected = true;
            }
            // Only supported in Chrome
            if (gamepads[i].timestamp && gamepads[i].timestamp === this._gamePadTimeStamps[i]) {
                continue;
            }
            this._gamePadTimeStamps[i] = gamepads[i].timestamp;
            // Add reference to navigator gamepad
            this.at(i).navigatorGamepad = gamepads[i];
            // Buttons
            let b, bi, a, ai, value;
            for (b in Buttons) {
                bi = Buttons[b];
                if (typeof bi === 'number') {
                    if (gamepads[i].buttons[bi]) {
                        value = gamepads[i].buttons[bi].value;
                        if (value !== this._oldPads[i].getButton(bi)) {
                            if (gamepads[i].buttons[bi].pressed) {
                                this.at(i).updateButton(bi, value);
                                this.at(i).eventDispatcher.emit('button', new GamepadButtonEvent(bi, value, this.at(i)));
                            }
                            else {
                                this.at(i).updateButton(bi, 0);
                            }
                        }
                    }
                }
            }
            // Axes
            for (a in Axes) {
                ai = Axes[a];
                if (typeof ai === 'number') {
                    value = gamepads[i].axes[ai];
                    if (value !== this._oldPads[i].getAxes(ai)) {
                        this.at(i).updateAxes(ai, value);
                        this.at(i).eventDispatcher.emit('axis', new GamepadAxisEvent(ai, value, this.at(i)));
                    }
                }
            }
            this._oldPads[i] = this._clonePad(gamepads[i]);
        }
    }
    /**
     * Safely retrieves a Gamepad at a specific index and creates one if it doesn't yet exist
     */
    at(index) {
        this._enableAndUpdate(); // implicitly enable gamepads when at() is called
        if (index >= this._pads.length) {
            // Ensure there is a pad to retrieve
            for (let i = this._pads.length - 1, max = index; i < max; i++) {
                this._pads.push(new Gamepad());
                this._oldPads.push(new Gamepad());
            }
        }
        return this._pads[index];
    }
    /**
     * Returns a list of all valid gamepads that meet the minimum configuration requirement.
     */
    getValidGamepads() {
        this._enableAndUpdate();
        const result = [];
        for (let i = 0; i < this._pads.length; i++) {
            if (this._isGamepadValid(this.at(i).navigatorGamepad) && this.at(i).connected) {
                result.push(this.at(i));
            }
        }
        return result;
    }
    /**
     * Gets the number of connected gamepads
     */
    count() {
        return this._pads.filter((p) => p.connected).length;
    }
    _clonePads(pads) {
        const arr = [];
        for (let i = 0, len = pads.length; i < len; i++) {
            arr.push(this._clonePad(pads[i]));
        }
        return arr;
    }
    /**
     * Fastest way to clone a known object is to do it yourself
     */
    _clonePad(pad) {
        let i, len;
        const clonedPad = new Gamepad();
        if (!pad) {
            return clonedPad;
        }
        for (i = 0, len = pad.buttons.length; i < len; i++) {
            if (pad.buttons[i]) {
                clonedPad.updateButton(i, pad.buttons[i].value);
            }
        }
        for (i = 0, len = pad.axes.length; i < len; i++) {
            clonedPad.updateAxes(i, pad.axes[i]);
        }
        return clonedPad;
    }
}
/**
 * The minimum value an axis has to move before considering it a change
 */
Gamepads.MinAxisMoveThreshold = 0.05;
/**
 * Gamepad holds state information for a connected controller. See [[Gamepads]]
 * for more information on handling controller input.
 */
class Gamepad extends Class {
    constructor() {
        super();
        this.connected = false;
        this._buttons = new Array(16);
        this._axes = new Array(4);
        for (let i = 0; i < this._buttons.length; i++) {
            this._buttons[i] = 0;
        }
        for (let i = 0; i < this._axes.length; i++) {
            this._axes[i] = 0;
        }
    }
    /**
     * Whether or not the given button is pressed
     * @param button     The button to query
     * @param threshold  The threshold over which the button is considered to be pressed
     */
    isButtonPressed(button, threshold = 1) {
        return this._buttons[button] >= threshold;
    }
    /**
     * Gets the given button value between 0 and 1
     */
    getButton(button) {
        return this._buttons[button];
    }
    /**
     * Gets the given axis value between -1 and 1. Values below
     * [[MinAxisMoveThreshold]] are considered 0.
     */
    getAxes(axes) {
        const value = this._axes[axes];
        if (Math.abs(value) < Gamepads.MinAxisMoveThreshold) {
            return 0;
        }
        else {
            return value;
        }
    }
    updateButton(buttonIndex, value) {
        this._buttons[buttonIndex] = value;
    }
    updateAxes(axesIndex, value) {
        this._axes[axesIndex] = value;
    }
}
/**
 * Gamepad Buttons enumeration
 */
var Buttons;
(function (Buttons) {
    /**
     * Face 1 button (e.g. A)
     */
    Buttons[Buttons["Face1"] = 0] = "Face1";
    /**
     * Face 2 button (e.g. B)
     */
    Buttons[Buttons["Face2"] = 1] = "Face2";
    /**
     * Face 3 button (e.g. X)
     */
    Buttons[Buttons["Face3"] = 2] = "Face3";
    /**
     * Face 4 button (e.g. Y)
     */
    Buttons[Buttons["Face4"] = 3] = "Face4";
    /**
     * Left bumper button
     */
    Buttons[Buttons["LeftBumper"] = 4] = "LeftBumper";
    /**
     * Right bumper button
     */
    Buttons[Buttons["RightBumper"] = 5] = "RightBumper";
    /**
     * Left trigger button
     */
    Buttons[Buttons["LeftTrigger"] = 6] = "LeftTrigger";
    /**
     * Right trigger button
     */
    Buttons[Buttons["RightTrigger"] = 7] = "RightTrigger";
    /**
     * Select button
     */
    Buttons[Buttons["Select"] = 8] = "Select";
    /**
     * Start button
     */
    Buttons[Buttons["Start"] = 9] = "Start";
    /**
     * Left analog stick press (e.g. L3)
     */
    Buttons[Buttons["LeftStick"] = 10] = "LeftStick";
    /**
     * Right analog stick press (e.g. R3)
     */
    Buttons[Buttons["RightStick"] = 11] = "RightStick";
    /**
     * D-pad up
     */
    Buttons[Buttons["DpadUp"] = 12] = "DpadUp";
    /**
     * D-pad down
     */
    Buttons[Buttons["DpadDown"] = 13] = "DpadDown";
    /**
     * D-pad left
     */
    Buttons[Buttons["DpadLeft"] = 14] = "DpadLeft";
    /**
     * D-pad right
     */
    Buttons[Buttons["DpadRight"] = 15] = "DpadRight";
})(Buttons || (Buttons = {}));
/**
 * Gamepad Axes enumeration
 */
var Axes;
(function (Axes) {
    /**
     * Left analogue stick X direction
     */
    Axes[Axes["LeftStickX"] = 0] = "LeftStickX";
    /**
     * Left analogue stick Y direction
     */
    Axes[Axes["LeftStickY"] = 1] = "LeftStickY";
    /**
     * Right analogue stick X direction
     */
    Axes[Axes["RightStickX"] = 2] = "RightStickX";
    /**
     * Right analogue stick Y direction
     */
    Axes[Axes["RightStickY"] = 3] = "RightStickY";
})(Axes || (Axes = {}));

;// CONCATENATED MODULE: ./Util/Browser.ts
class BrowserComponent {
    constructor(nativeComponent) {
        this.nativeComponent = nativeComponent;
        this._paused = false;
        this._nativeHandlers = {};
    }
    on(eventName, handler) {
        if (this._nativeHandlers[eventName]) {
            this.off(eventName, this._nativeHandlers[eventName]);
        }
        this._nativeHandlers[eventName] = this._decorate(handler);
        this.nativeComponent.addEventListener(eventName, this._nativeHandlers[eventName]);
    }
    off(eventName, handler) {
        if (!handler) {
            handler = this._nativeHandlers[eventName];
        }
        this.nativeComponent.removeEventListener(eventName, handler);
        this._nativeHandlers[eventName] = null;
    }
    _decorate(handler) {
        return (evt) => {
            if (!this._paused) {
                handler(evt);
            }
        };
    }
    pause() {
        this._paused = true;
    }
    resume() {
        this._paused = false;
    }
    clear() {
        for (const event in this._nativeHandlers) {
            this.off(event);
        }
    }
}
class BrowserEvents {
    constructor(_windowGlobal, _documentGlobal) {
        this._windowGlobal = _windowGlobal;
        this._documentGlobal = _documentGlobal;
        this._windowComponent = new BrowserComponent(this._windowGlobal);
        this._documentComponent = new BrowserComponent(this._documentGlobal);
    }
    get window() {
        return this._windowComponent;
    }
    get document() {
        return this._documentComponent;
    }
    pause() {
        this.window.pause();
        this.document.pause();
    }
    resume() {
        this.window.resume();
        this.document.resume();
    }
    clear() {
        this.window.clear();
        this.document.clear();
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/ExcaliburGraphicsContext2DCanvas.ts




class ExcaliburGraphicsContext2DCanvasDebug {
    constructor(_ex) {
        this._ex = _ex;
        this._debugText = new DebugText();
    }
    /**
     * Draw a debug rectangle to the context
     * @param x
     * @param y
     * @param width
     * @param height
     */
    drawRect(x, y, width, height) {
        this._ex.__ctx.save();
        this._ex.__ctx.strokeStyle = 'red';
        this._ex.__ctx.strokeRect(this._ex.snapToPixel ? ~~x : x, this._ex.snapToPixel ? ~~y : y, this._ex.snapToPixel ? ~~width : width, this._ex.snapToPixel ? ~~height : height);
        this._ex.__ctx.restore();
    }
    drawLine(start, end, lineOptions = { color: Color.Black }) {
        this._ex.__ctx.save();
        this._ex.__ctx.beginPath();
        this._ex.__ctx.strokeStyle = lineOptions.color.toString();
        this._ex.__ctx.moveTo(this._ex.snapToPixel ? ~~start.x : start.x, this._ex.snapToPixel ? ~~start.y : start.y);
        this._ex.__ctx.lineTo(this._ex.snapToPixel ? ~~end.x : end.x, this._ex.snapToPixel ? ~~end.y : end.y);
        this._ex.__ctx.lineWidth = 2;
        this._ex.__ctx.stroke();
        this._ex.__ctx.closePath();
        this._ex.__ctx.restore();
    }
    drawPoint(point, pointOptions = { color: Color.Black, size: 5 }) {
        this._ex.__ctx.save();
        this._ex.__ctx.beginPath();
        this._ex.__ctx.fillStyle = pointOptions.color.toString();
        this._ex.__ctx.arc(this._ex.snapToPixel ? ~~point.x : point.x, this._ex.snapToPixel ? ~~point.y : point.y, pointOptions.size, 0, Math.PI * 2);
        this._ex.__ctx.fill();
        this._ex.__ctx.closePath();
        this._ex.__ctx.restore();
    }
    drawText(text, pos) {
        this._debugText.write(this._ex, text, pos);
    }
}
class ExcaliburGraphicsContext2DCanvas {
    constructor(options) {
        this.backgroundColor = Color.ExcaliburBlue;
        this._state = new StateStack();
        this.snapToPixel = true;
        this.debug = new ExcaliburGraphicsContext2DCanvasDebug(this);
        const { canvasElement, enableTransparency, snapToPixel, smoothing, backgroundColor } = options;
        this.__ctx = canvasElement.getContext('2d', {
            alpha: enableTransparency !== null && enableTransparency !== void 0 ? enableTransparency : true
        });
        this.backgroundColor = backgroundColor !== null && backgroundColor !== void 0 ? backgroundColor : this.backgroundColor;
        this.snapToPixel = snapToPixel !== null && snapToPixel !== void 0 ? snapToPixel : this.snapToPixel;
        this.smoothing = smoothing !== null && smoothing !== void 0 ? smoothing : this.smoothing;
    }
    get width() {
        return this.__ctx.canvas.width;
    }
    get height() {
        return this.__ctx.canvas.height;
    }
    get opacity() {
        return this._state.current.opacity;
    }
    set opacity(value) {
        this._state.current.opacity = value;
    }
    get smoothing() {
        return this.__ctx.imageSmoothingEnabled;
    }
    set smoothing(value) {
        this.__ctx.imageSmoothingEnabled = value;
    }
    resetTransform() {
        this.__ctx.resetTransform();
    }
    updateViewport() {
        // pass
    }
    drawImage(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
        if (swidth === 0 || sheight === 0) {
            return; // zero dimension dest exit early
        }
        else if (dwidth === 0 || dheight === 0) {
            return; // zero dimension dest exit early
        }
        else if (image.width === 0 || image.height === 0) {
            return; // zero dimension source exit early
        }
        this.__ctx.globalAlpha = this.opacity;
        const args = [image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight]
            .filter((a) => a !== undefined)
            .map((a) => (typeof a === 'number' && this.snapToPixel ? ~~a : a));
        this.__ctx.drawImage.apply(this.__ctx, args);
        GraphicsDiagnostics.DrawCallCount++;
        GraphicsDiagnostics.DrawnImagesCount = 1;
    }
    drawLine(start, end, color, thickness = 1) {
        this.__ctx.save();
        this.__ctx.beginPath();
        this.__ctx.strokeStyle = color.toString();
        this.__ctx.moveTo(this.snapToPixel ? ~~start.x : start.x, this.snapToPixel ? ~~start.y : start.y);
        this.__ctx.lineTo(this.snapToPixel ? ~~end.x : end.x, this.snapToPixel ? ~~end.y : end.y);
        this.__ctx.lineWidth = thickness;
        this.__ctx.stroke();
        this.__ctx.closePath();
        this.__ctx.restore();
    }
    drawRectangle(pos, width, height, color) {
        this.__ctx.save();
        this.__ctx.fillStyle = color.toString();
        this.__ctx.fillRect(this.snapToPixel ? ~~pos.x : pos.x, this.snapToPixel ? ~~pos.y : pos.y, this.snapToPixel ? ~~width : width, this.snapToPixel ? ~~height : height);
        this.__ctx.restore();
    }
    drawCircle(pos, radius, color) {
        this.__ctx.save();
        this.__ctx.beginPath();
        this.__ctx.fillStyle = color.toString();
        this.__ctx.arc(this.snapToPixel ? ~~pos.x : pos.x, this.snapToPixel ? ~~pos.y : pos.y, radius, 0, Math.PI * 2);
        this.__ctx.fill();
        this.__ctx.closePath();
        this.__ctx.restore();
    }
    /**
     * Save the current state of the canvas to the stack (transforms and opacity)
     */
    save() {
        this.__ctx.save();
    }
    /**
     * Restore the state of the canvas from the stack
     */
    restore() {
        this.__ctx.restore();
    }
    /**
     * Translate the origin of the context by an x and y
     * @param x
     * @param y
     */
    translate(x, y) {
        this.__ctx.translate(this.snapToPixel ? ~~x : x, this.snapToPixel ? ~~y : y);
    }
    /**
     * Rotate the context about the current origin
     */
    rotate(angle) {
        this.__ctx.rotate(angle);
    }
    /**
     * Scale the context by an x and y factor
     * @param x
     * @param y
     */
    scale(x, y) {
        this.__ctx.scale(x, y);
    }
    clear() {
        // Clear frame
        this.__ctx.clearRect(0, 0, this.width, this.height);
        this.__ctx.fillStyle = this.backgroundColor.toString();
        this.__ctx.fillRect(0, 0, this.width, this.height);
        GraphicsDiagnostics.clear();
    }
    /**
     * Flushes the batched draw calls to the screen
     */
    flush() {
        // pass
    }
}

;// CONCATENATED MODULE: ./Engine.ts
var Engine_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};



polyfill();














/**
 * Enum representing the different mousewheel event bubble prevention
 */
var ScrollPreventionMode;
(function (ScrollPreventionMode) {
    /**
     * Do not prevent any page scrolling
     */
    ScrollPreventionMode[ScrollPreventionMode["None"] = 0] = "None";
    /**
     * Prevent page scroll if mouse is over the game canvas
     */
    ScrollPreventionMode[ScrollPreventionMode["Canvas"] = 1] = "Canvas";
    /**
     * Prevent all page scrolling via mouse wheel
     */
    ScrollPreventionMode[ScrollPreventionMode["All"] = 2] = "All";
})(ScrollPreventionMode || (ScrollPreventionMode = {}));
/**
 * The Excalibur Engine
 *
 * The [[Engine]] is the main driver for a game. It is responsible for
 * starting/stopping the game, maintaining state, transmitting events,
 * loading resources, and managing the scene.
 */
class Engine extends Class {
    /**
     * Creates a new game using the given [[EngineOptions]]. By default, if no options are provided,
     * the game will be rendered full screen (taking up all available browser window space).
     * You can customize the game rendering through [[EngineOptions]].
     *
     * Example:
     *
     * ```js
     * var game = new ex.Engine({
     *   width: 0, // the width of the canvas
     *   height: 0, // the height of the canvas
     *   enableCanvasTransparency: true, // the transparencySection of the canvas
     *   canvasElementId: '', // the DOM canvas element ID, if you are providing your own
     *   displayMode: ex.DisplayMode.FullScreen, // the display mode
     *   pointerScope: ex.Input.PointerScope.Document, // the scope of capturing pointer (mouse/touch) events
     *   backgroundColor: ex.Color.fromHex('#2185d0') // background color of the engine
     * });
     *
     * // call game.start, which is a Promise
     * game.start().then(function () {
     *   // ready, set, go!
     * });
     * ```
     */
    constructor(options) {
        var _a, _b, _c;
        super();
        this._hasStarted = false;
        /**
         * Gets or sets the list of post processors to apply at the end of drawing a frame (such as [[ColorBlindCorrector]])
         */
        this.postProcessors = [];
        /**
         * Contains all the scenes currently registered with Excalibur
         */
        this.scenes = {};
        /**
         * @hidden
         * @deprecated
         */
        this._animations = [];
        this._suppressPlayButton = false;
        /**
         * Indicates whether audio should be paused when the game is no longer visible.
         */
        this.pauseAudioWhenHidden = true;
        /**
         * Indicates whether the engine should draw with debug information
         */
        this._isDebug = false;
        this.debugColor = new Color(255, 255, 255);
        /**
         * Sets the Transparency for the engine.
         */
        this.enableCanvasTransparency = true;
        /**
         * The action to take when a fatal exception is thrown
         */
        this.onFatalException = (e) => {
            Logger.getInstance().fatal(e);
        };
        this._timescale = 1.0;
        this._isLoading = false;
        this._isInitialized = false;
        this._deferredGoTo = null;
        this._loadingComplete = false;
        options = Object.assign(Object.assign({}, Engine._DEFAULT_ENGINE_OPTIONS), options);
        Flags.freeze();
        // Initialize browser events facade
        this.browser = new BrowserEvents(window, document);
        // Check compatibility
        const detector = new Detector();
        if (!options.suppressMinimumBrowserFeatureDetection && !(this._compatible = detector.test())) {
            const message = document.createElement('div');
            message.innerText = 'Sorry, your browser does not support all the features needed for Excalibur';
            document.body.appendChild(message);
            detector.failedTests.forEach(function (test) {
                const testMessage = document.createElement('div');
                testMessage.innerText = 'Browser feature missing ' + test;
                document.body.appendChild(testMessage);
            });
            if (options.canvasElementId) {
                const canvas = document.getElementById(options.canvasElementId);
                if (canvas) {
                    canvas.parentElement.removeChild(canvas);
                }
            }
            return;
        }
        else {
            this._compatible = true;
        }
        // Use native console API for color fun
        // eslint-disable-next-line no-console
        if (console.log && !options.suppressConsoleBootMessage) {
            // eslint-disable-next-line no-console
            console.log(`%cPowered by Excalibur.js (v${EX_VERSION})`, 'background: #176BAA; color: white; border-radius: 5px; padding: 15px; font-size: 1.5em; line-height: 80px;');
            // eslint-disable-next-line no-console
            console.log('\n\
      /| ________________\n\
O|===|* >________________>\n\
      \\|');
            // eslint-disable-next-line no-console
            console.log('Visit', 'http://excaliburjs.com', 'for more information');
        }
        // Suppress play button
        if (options.suppressPlayButton) {
            this._suppressPlayButton = true;
        }
        this._logger = Logger.getInstance();
        // If debug is enabled, let's log browser features to the console.
        if (this._logger.defaultLevel === LogLevel.Debug) {
            detector.logBrowserFeatures();
        }
        this._logger.debug('Building engine...');
        this.canvasElementId = options.canvasElementId;
        if (options.canvasElementId) {
            this._logger.debug('Using Canvas element specified: ' + options.canvasElementId);
            this.canvas = document.getElementById(options.canvasElementId);
        }
        else if (options.canvasElement) {
            this._logger.debug('Using Canvas element specified:', options.canvasElement);
            this.canvas = options.canvasElement;
        }
        else {
            this._logger.debug('Using generated canvas element');
            this.canvas = document.createElement('canvas');
        }
        let displayMode = (_a = options.displayMode) !== null && _a !== void 0 ? _a : DisplayMode.Fixed;
        if ((options.width && options.height) || options.viewport) {
            if (options.displayMode === undefined) {
                displayMode = DisplayMode.Fixed;
            }
            this._logger.debug('Engine viewport is size ' + options.width + ' x ' + options.height);
        }
        else if (!options.displayMode) {
            this._logger.debug('Engine viewport is fit');
            displayMode = DisplayMode.FitScreen;
        }
        if (Flags.isEnabled(Legacy.Canvas)) {
            const ex2dCtx = new ExcaliburGraphicsContext2DCanvas({
                canvasElement: this.canvas,
                enableTransparency: this.enableCanvasTransparency,
                smoothing: options.antialiasing,
                backgroundColor: options.backgroundColor,
                snapToPixel: options.snapToPixel
            });
            this.graphicsContext = ex2dCtx;
            this.ctx = ex2dCtx.__ctx;
        }
        else {
            const exWebglCtx = new ExcaliburGraphicsContextWebGL({
                canvasElement: this.canvas,
                enableTransparency: this.enableCanvasTransparency,
                smoothing: options.antialiasing,
                backgroundColor: options.backgroundColor,
                snapToPixel: options.snapToPixel
            });
            this.graphicsContext = exWebglCtx;
            this.ctx = exWebglCtx.__ctx;
        }
        this.screen = new Screen({
            canvas: this.canvas,
            context: this.graphicsContext,
            antialiasing: (_b = options.antialiasing) !== null && _b !== void 0 ? _b : true,
            browser: this.browser,
            viewport: (_c = options.viewport) !== null && _c !== void 0 ? _c : (options.width && options.height ? { width: options.width, height: options.height } : Resolution.SVGA),
            resolution: options.resolution,
            displayMode,
            position: options.position,
            pixelRatio: options.suppressHiDPIScaling ? 1 : null
        });
        if (options.backgroundColor) {
            this.backgroundColor = options.backgroundColor.clone();
        }
        this.enableCanvasTransparency = options.enableCanvasTransparency;
        this._loader = new Loader();
        this.debug = new Debug(this);
        this._initialize(options);
        this.rootScene = this.currentScene = new Scene();
        this.addScene('root', this.rootScene);
    }
    /**
     * The width of the game canvas in pixels (physical width component of the
     * resolution of the canvas element)
     */
    get canvasWidth() {
        return this.screen.canvasWidth;
    }
    /**
     * Returns half width of the game canvas in pixels (half physical width component)
     */
    get halfCanvasWidth() {
        return this.screen.halfCanvasWidth;
    }
    /**
     * The height of the game canvas in pixels, (physical height component of
     * the resolution of the canvas element)
     */
    get canvasHeight() {
        return this.screen.canvasHeight;
    }
    /**
     * Returns half height of the game canvas in pixels (half physical height component)
     */
    get halfCanvasHeight() {
        return this.screen.halfCanvasHeight;
    }
    /**
     * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawWidth() {
        return this.screen.drawWidth;
    }
    /**
     * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawWidth() {
        return this.screen.halfDrawWidth;
    }
    /**
     * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawHeight() {
        return this.screen.drawHeight;
    }
    /**
     * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawHeight() {
        return this.screen.halfDrawHeight;
    }
    /**
     * Returns whether excalibur detects the current screen to be HiDPI
     */
    get isHiDpi() {
        return this.screen.isHiDpi;
    }
    /**
     * Access [[stats]] that holds frame statistics.
     */
    get stats() {
        return this.debug.stats;
    }
    /**
     * Indicates whether the engine is set to fullscreen or not
     */
    get isFullscreen() {
        return this.screen.isFullScreen;
    }
    /**
     * Indicates the current [[DisplayMode]] of the engine.
     */
    get displayMode() {
        return this.screen.displayMode;
    }
    /**
     * Returns the calculated pixel ration for use in rendering
     */
    get pixelRatio() {
        return this.screen.pixelRatio;
    }
    get isDebug() {
        return this._isDebug;
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    once(eventName, handler) {
        super.once(eventName, handler);
    }
    off(eventName, handler) {
        super.off(eventName, handler);
    }
    /**
     * Returns a BoundingBox of the top left corner of the screen
     * and the bottom right corner of the screen.
     */
    getWorldBounds() {
        return this.screen.getWorldBounds();
    }
    /**
     * Gets the current engine timescale factor (default is 1.0 which is 1:1 time)
     */
    get timescale() {
        return this._timescale;
    }
    /**
     * Sets the current engine timescale factor. Useful for creating slow-motion effects or fast-forward effects
     * when using time-based movement.
     */
    set timescale(value) {
        if (value <= 0) {
            Logger.getInstance().error('Cannot set engine.timescale to a value of 0 or less than 0.');
            return;
        }
        this._timescale = value;
    }
    /**
     * Plays a sprite animation on the screen at the specified `x` and `y`
     * (in game coordinates, not screen pixels). These animations play
     * independent of actors, and will be cleaned up internally as soon
     * as they are complete. Note animations that loop will never be
     * cleaned up.
     *
     * @param animation  Animation to play
     * @param x          x game coordinate to play the animation
     * @param y          y game coordinate to play the animation
     * @deprecated
     */
    playAnimation(animation, x, y) {
        this._animations.push(new AnimationNode(animation, x, y));
    }
    /**
     * Adds a [[TileMap]] to the [[currentScene]], once this is done the TileMap
     * will be drawn and updated.
     */
    addTileMap(tileMap) {
        this.currentScene.addTileMap(tileMap);
    }
    /**
     * Removes a [[TileMap]] from the [[currentScene]], it will no longer be drawn or updated.
     */
    removeTileMap(tileMap) {
        this.currentScene.removeTileMap(tileMap);
    }
    /**
     * Adds a [[Timer]] to the [[currentScene]].
     * @param timer  The timer to add to the [[currentScene]].
     */
    addTimer(timer) {
        return this.currentScene.addTimer(timer);
    }
    /**
     * Removes a [[Timer]] from the [[currentScene]].
     * @param timer  The timer to remove to the [[currentScene]].
     */
    removeTimer(timer) {
        return this.currentScene.removeTimer(timer);
    }
    /**
     * Adds a [[Scene]] to the engine, think of scenes in Excalibur as you
     * would levels or menus.
     *
     * @param key  The name of the scene, must be unique
     * @param scene The scene to add to the engine
     */
    addScene(key, scene) {
        if (this.scenes[key]) {
            this._logger.warn('Scene', key, 'already exists overwriting');
        }
        this.scenes[key] = scene;
    }
    /**
     * @internal
     */
    removeScene(entity) {
        if (entity instanceof Scene) {
            // remove scene
            for (const key in this.scenes) {
                if (this.scenes.hasOwnProperty(key)) {
                    if (this.scenes[key] === entity) {
                        delete this.scenes[key];
                    }
                }
            }
        }
        if (typeof entity === 'string') {
            // remove scene
            delete this.scenes[entity];
        }
    }
    add(entity) {
        if (arguments.length === 2) {
            this.addScene(arguments[0], arguments[1]);
            return;
        }
        if (this._deferredGoTo && this.scenes[this._deferredGoTo]) {
            this.scenes[this._deferredGoTo].add(entity);
        }
        else {
            this.currentScene.add(entity);
        }
    }
    remove(entity) {
        if (entity instanceof Entity) {
            this.currentScene.remove(entity);
        }
        if (entity instanceof Scene) {
            this.removeScene(entity);
        }
        if (typeof entity === 'string') {
            this.removeScene(entity);
        }
    }
    /**
     * Changes the currently updating and drawing scene to a different,
     * named scene. Calls the [[Scene]] lifecycle events.
     * @param key  The key of the scene to transition to.
     */
    goToScene(key) {
        // if not yet initialized defer goToScene
        if (!this.isInitialized) {
            this._deferredGoTo = key;
            return;
        }
        if (this.scenes[key]) {
            const oldScene = this.currentScene;
            const newScene = this.scenes[key];
            this._logger.debug('Going to scene:', key);
            // only deactivate when initialized
            if (this.currentScene.isInitialized) {
                this.currentScene._deactivate.apply(this.currentScene, [oldScene, newScene]);
                this.currentScene.eventDispatcher.emit('deactivate', new DeactivateEvent(newScene, this.currentScene));
            }
            // set current scene to new one
            this.currentScene = newScene;
            this.screen.setCurrentCamera(newScene.camera);
            // initialize the current scene if has not been already
            this.currentScene._initialize(this);
            this.currentScene._activate.apply(this.currentScene, [oldScene, newScene]);
            this.currentScene.eventDispatcher.emit('activate', new ActivateEvent(oldScene, this.currentScene));
        }
        else {
            this._logger.error('Scene', key, 'does not exist!');
        }
    }
    /**
     * Transforms the current x, y from screen coordinates to world coordinates
     * @param point  Screen coordinate to convert
     */
    screenToWorldCoordinates(point) {
        return this.screen.screenToWorldCoordinates(point);
    }
    /**
     * Transforms a world coordinate, to a screen coordinate
     * @param point  World coordinate to convert
     */
    worldToScreenCoordinates(point) {
        return this.screen.worldToScreenCoordinates(point);
    }
    /**
     * Initializes the internal canvas, rendering context, display mode, and native event listeners
     */
    _initialize(options) {
        this.pageScrollPreventionMode = options.scrollPreventionMode;
        // initialize inputs
        this.input = {
            keyboard: new Keyboard(),
            pointers: new Pointers(this),
            gamepads: new Gamepads()
        };
        this.input.keyboard.init();
        this.input.pointers.init(options && options.pointerScope === PointerScope.Document ? document : this.canvas);
        this.input.gamepads.init();
        // Issue #385 make use of the visibility api
        // https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API
        let hidden, visibilityChange;
        if (typeof document.hidden !== 'undefined') {
            // Opera 12.10 and Firefox 18 and later support
            hidden = 'hidden';
            visibilityChange = 'visibilitychange';
        }
        else if ('msHidden' in document) {
            hidden = 'msHidden';
            visibilityChange = 'msvisibilitychange';
        }
        else if ('webkitHidden' in document) {
            hidden = 'webkitHidden';
            visibilityChange = 'webkitvisibilitychange';
        }
        this.browser.document.on(visibilityChange, () => {
            if (document[hidden]) {
                this.eventDispatcher.emit('hidden', new HiddenEvent(this));
                this._logger.debug('Window hidden');
            }
            else {
                this.eventDispatcher.emit('visible', new VisibleEvent(this));
                this._logger.debug('Window visible');
            }
        });
        if (!this.canvasElementId && !options.canvasElement) {
            document.body.appendChild(this.canvas);
        }
    }
    onInitialize(_engine) {
        // Override me
    }
    /**
     * If supported by the browser, this will set the antialiasing flag on the
     * canvas. Set this to `false` if you want a 'jagged' pixel art look to your
     * image resources.
     * @param isSmooth  Set smoothing to true or false
     */
    setAntialiasing(isSmooth) {
        this.screen.antialiasing = isSmooth;
    }
    /**
     * Return the current smoothing status of the canvas
     */
    getAntialiasing() {
        return this.screen.antialiasing;
    }
    /**
     * Gets whether the actor is Initialized
     */
    get isInitialized() {
        return this._isInitialized;
    }
    _overrideInitialize(engine) {
        if (!this.isInitialized) {
            this.onInitialize(engine);
            super.emit('initialize', new InitializeEvent(engine, this));
            this._isInitialized = true;
            if (this._deferredGoTo) {
                this.goToScene(this._deferredGoTo);
            }
            else {
                this.goToScene('root');
            }
        }
    }
    /**
     * Updates the entire state of the game
     * @param delta  Number of milliseconds elapsed since the last update.
     */
    _update(delta) {
        if (this._isLoading) {
            // suspend updates until loading is finished
            this._loader.update(this, delta);
            // Update input listeners
            this.input.keyboard.update();
            this.input.pointers.update();
            this.input.gamepads.update();
            return;
        }
        this._overrideInitialize(this);
        // Publish preupdate events
        this._preupdate(delta);
        // process engine level events
        this.currentScene.update(this, delta);
        // update animations
        // TODO remove
        this._animations = this._animations.filter(function (a) {
            return !a.animation.isDone();
        });
        // Update input listeners
        this.input.keyboard.update();
        this.input.pointers.update();
        this.input.gamepads.update();
        // Publish update event
        this._postupdate(delta);
    }
    /**
     * @internal
     */
    _preupdate(delta) {
        this.emit('preupdate', new PreUpdateEvent(this, delta, this));
        this.onPreUpdate(this, delta);
    }
    onPreUpdate(_engine, _delta) {
        // Override me
    }
    /**
     * @internal
     */
    _postupdate(delta) {
        this.emit('postupdate', new PostUpdateEvent(this, delta, this));
        this.onPostUpdate(this, delta);
    }
    onPostUpdate(_engine, _delta) {
        // Override me
    }
    /**
     * Draws the entire game
     * @param delta  Number of milliseconds elapsed since the last draw.
     */
    _draw(delta) {
        const ctx = this.ctx;
        this._predraw(ctx, delta);
        if (this._isLoading) {
            this._loader.canvas.draw(this.graphicsContext, 0, 0);
            this.graphicsContext.flush();
            // Drawing nothing else while loading
            return;
        }
        // TODO move to graphics systems?
        this.graphicsContext.backgroundColor = this.backgroundColor;
        this.currentScene.draw(this.ctx, delta);
        // todo needs to be a better way of doing this
        let a = 0;
        const len = this._animations.length;
        for (a; a < len; a++) {
            this._animations[a].animation.draw(ctx, this._animations[a].x, this._animations[a].y);
        }
        // Draw debug information
        // TODO don't access ctx directly
        if (this.isDebug) {
            this.ctx.font = 'Consolas';
            this.ctx.fillStyle = this.debugColor.toString();
            const keys = this.input.keyboard.getKeys();
            for (let j = 0; j < keys.length; j++) {
                this.ctx.fillText(keys[j].toString() + ' : ' + (Keys[keys[j]] ? Keys[keys[j]] : 'Not Mapped'), 100, 10 * j + 10);
            }
            this.ctx.fillText('FPS:' + this.stats.currFrame.fps.toFixed(2).toString(), 10, 10);
        }
        // Post processing
        for (let i = 0; i < this.postProcessors.length; i++) {
            this.postProcessors[i].process(this.ctx.getImageData(0, 0, this.canvasWidth, this.canvasHeight), this.ctx);
        }
        this._postdraw(ctx, delta);
    }
    /**
     * @internal
     */
    _predraw(_ctx, delta) {
        this.emit('predraw', new PreDrawEvent(_ctx, delta, this));
        this.onPreDraw(_ctx, delta);
    }
    onPreDraw(_ctx, _delta) {
        // Override me
    }
    /**
     * @internal
     */
    _postdraw(_ctx, delta) {
        this.emit('postdraw', new PostDrawEvent(_ctx, delta, this));
        this.onPostDraw(_ctx, delta);
    }
    onPostDraw(_ctx, _delta) {
        // Override me
    }
    /**
     * Enable or disable Excalibur debugging functionality.
     * @param toggle a value that debug drawing will be changed to
     */
    showDebug(toggle) {
        this._isDebug = toggle;
    }
    /**
     * Toggle Excalibur debugging functionality.
     */
    toggleDebug() {
        this._isDebug = !this._isDebug;
        return this._isDebug;
    }
    /**
     * Returns true when loading is totally complete and the player has clicked start
     */
    get loadingComplete() {
        return this._loadingComplete;
    }
    /**
     * Starts the internal game loop for Excalibur after loading
     * any provided assets.
     * @param loader  Optional [[Loader]] to use to load resources. The default loader is [[Loader]], override to provide your own
     * custom loader.
     */
    start(loader) {
        if (!this._compatible) {
            return Promise.reject('Excalibur is incompatible with your browser');
        }
        let loadingComplete;
        // Push the current user entered resolution/viewport
        this.screen.pushResolutionAndViewport();
        // Configure resolution for loader
        this.screen.resolution = this.screen.viewport;
        this.screen.applyResolutionAndViewport();
        this.graphicsContext.updateViewport();
        if (loader) {
            this._loader = loader;
            this._loader.suppressPlayButton = this._suppressPlayButton || this._loader.suppressPlayButton;
            this._loader.wireEngine(this);
            loadingComplete = this.load(this._loader);
        }
        else {
            loadingComplete = Promise.resolve();
        }
        loadingComplete.then(() => {
            this.screen.popResolutionAndViewport();
            this.screen.applyResolutionAndViewport();
            this.graphicsContext.updateViewport();
            this.emit('start', new GameStartEvent(this));
            this._loadingComplete = true;
        });
        if (!this._hasStarted) {
            // has started is a slight misnomer, it's really mainloop started
            this._hasStarted = true;
            this._logger.debug('Starting game...');
            this.browser.resume();
            Engine.createMainLoop(this, window.requestAnimationFrame, Date.now)();
            this._logger.debug('Game started');
        }
        else {
            // Game already started;
        }
        return loadingComplete;
    }
    static createMainLoop(game, raf, nowFn) {
        let lastTime = nowFn();
        return function mainloop() {
            if (!game._hasStarted) {
                return;
            }
            try {
                game._requestId = raf(mainloop);
                game.emit('preframe', new PreFrameEvent(game, game.stats.prevFrame));
                // Get the time to calculate time-elapsed
                const now = nowFn();
                let elapsed = Math.floor(now - lastTime) || 1;
                // Resolves issue #138 if the game has been paused, or blurred for
                // more than a 200 milliseconds, reset elapsed time to 1. This improves reliability
                // and provides more expected behavior when the engine comes back
                // into focus
                if (elapsed > 200) {
                    elapsed = 1;
                }
                const delta = elapsed * game.timescale;
                // reset frame stats (reuse existing instances)
                const frameId = game.stats.prevFrame.id + 1;
                game.stats.currFrame.reset();
                game.stats.currFrame.id = frameId;
                game.stats.currFrame.delta = delta;
                game.stats.currFrame.fps = 1.0 / (delta / 1000);
                const beforeUpdate = nowFn();
                game._update(delta);
                const afterUpdate = nowFn();
                game._draw(delta);
                const afterDraw = nowFn();
                game.stats.currFrame.duration.update = afterUpdate - beforeUpdate;
                game.stats.currFrame.duration.draw = afterDraw - afterUpdate;
                lastTime = now;
                game.emit('postframe', new PostFrameEvent(game, game.stats.currFrame));
                game.stats.prevFrame.reset(game.stats.currFrame);
            }
            catch (e) {
                window.cancelAnimationFrame(game._requestId);
                game.stop();
                game.onFatalException(e);
            }
        };
    }
    /**
     * Stops Excalibur's main loop, useful for pausing the game.
     */
    stop() {
        if (this._hasStarted) {
            this.emit('stop', new GameStopEvent(this));
            this.browser.pause();
            this._hasStarted = false;
            this._logger.debug('Game stopped');
        }
    }
    /**
     * Returns the Engine's Running status, Useful for checking whether engine is running or paused.
     */
    isPaused() {
        return !this._hasStarted;
    }
    /**
     * Takes a screen shot of the current viewport and returns it as an
     * HTML Image Element.
     */
    screenshot() {
        const result = new Image();
        const raw = this.canvas.toDataURL('image/png');
        result.src = raw;
        return result;
    }
    /**
     * Another option available to you to load resources into the game.
     * Immediately after calling this the game will pause and the loading screen
     * will appear.
     * @param loader  Some [[Loadable]] such as a [[Loader]] collection, [[Sound]], or [[Texture]].
     */
    load(loader) {
        const complete = new Promise((resolve) => {
            this._isLoading = true;
            loader.load().then(() => {
                if (this._suppressPlayButton) {
                    setTimeout(() => {
                        this._isLoading = false;
                        resolve();
                        // Delay is to give the logo a chance to show, otherwise don't delay
                    }, 500);
                }
                else {
                    this._isLoading = false;
                    resolve();
                }
            });
        });
        return complete;
    }
}
/**
 * Default [[EngineOptions]]
 */
Engine._DEFAULT_ENGINE_OPTIONS = {
    width: 0,
    height: 0,
    enableCanvasTransparency: true,
    canvasElementId: '',
    canvasElement: undefined,
    snapToPixel: false,
    pointerScope: PointerScope.Canvas,
    suppressConsoleBootMessage: null,
    suppressMinimumBrowserFeatureDetection: null,
    suppressHiDPIScaling: null,
    suppressPlayButton: null,
    scrollPreventionMode: ScrollPreventionMode.Canvas,
    backgroundColor: Color.fromHex('#2185d0') // Excalibur blue
};
Engine_decorate([
    obsolete({ message: 'Will be removed in excalibur v0.26.0', alternateMethod: 'Use Actor.graphics' })
], Engine.prototype, "playAnimation", null);
/**
 * @internal
 * @deprecated
 */
let AnimationNode = class AnimationNode {
    constructor(animation, x, y) {
        this.animation = animation;
        this.x = x;
        this.y = y;
    }
};
AnimationNode = Engine_decorate([
    obsolete({ message: 'Will be removed in excalibur v0.26.0' })
], AnimationNode);

;// CONCATENATED MODULE: ./Math/Index.ts









;// CONCATENATED MODULE: ./Debug/index.ts




;// CONCATENATED MODULE: ./Events/MediaEvents.ts

class MediaEvent extends GameEvent {
    constructor(target, _name = 'MediaEvent') {
        super();
        this.target = target;
        this._name = _name;
    }
    /**
     * Media event cannot bubble
     */
    set bubbles(_value) {
        // stubbed
    }
    /**
     * Media event cannot bubble
     */
    get bubbles() {
        return false;
    }
    /**
     * Media event cannot bubble, so they have no path
     */
    get _path() {
        return null;
    }
    /**
     * Media event cannot bubble, so they have no path
     */
    set _path(_val) {
        // stubbed
    }
    /**
     * Prevents event from bubbling
     */
    stopPropagation() {
        /**
         * Stub
         */
    }
    /**
     * Action, that calls when event happens
     */
    action() {
        /**
         * Stub
         */
    }
    /**
     * Propagate event further through event path
     */
    propagate() {
        /**
         * Stub
         */
    }
    layPath(_actor) {
        /**
         * Stub
         */
    }
}
class NativeSoundEvent extends MediaEvent {
    constructor(target, track) {
        super(target, 'NativeSoundEvent');
        this.track = track;
    }
}
class NativeSoundProcessedEvent extends MediaEvent {
    constructor(target, _processedData) {
        super(target, 'NativeSoundProcessedEvent');
        this._processedData = _processedData;
        this.data = this._processedData;
    }
}

;// CONCATENATED MODULE: ./Graphics/Font.ts





class Font extends Raster {
    constructor(options = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        super(options);
        /**
         * Font quality determines the size of the underlying rastered text, higher quality means less jagged edges.
         * If quality is set to 1, then just enough raster bitmap is generated to render the text.
         *
         * You can think of quality as how zoomed in to the text you can get before seeing jagged edges.
         *
         * (Default 4)
         */
        this.quality = 2;
        this.family = 'sans-serif';
        this.style = FontStyle.Normal;
        this.bold = false;
        this.unit = FontUnit.Px;
        this.textAlign = TextAlign.Left;
        this.baseAlign = BaseAlign.Alphabetic;
        this.direction = Direction.LeftToRight;
        this.size = 10;
        this.shadow = null;
        this._textBounds = new BoundingBox();
        this._textWidth = 0;
        this._textHeight = 0;
        this.family = (_a = options === null || options === void 0 ? void 0 : options.family) !== null && _a !== void 0 ? _a : this.family;
        this.style = (_b = options === null || options === void 0 ? void 0 : options.style) !== null && _b !== void 0 ? _b : this.style;
        this.bold = (_c = options === null || options === void 0 ? void 0 : options.bold) !== null && _c !== void 0 ? _c : this.bold;
        this.size = (_d = options === null || options === void 0 ? void 0 : options.size) !== null && _d !== void 0 ? _d : this.size;
        this.unit = (_e = options === null || options === void 0 ? void 0 : options.unit) !== null && _e !== void 0 ? _e : this.unit;
        this.textAlign = (_f = options === null || options === void 0 ? void 0 : options.textAlign) !== null && _f !== void 0 ? _f : this.textAlign;
        this.baseAlign = (_g = options === null || options === void 0 ? void 0 : options.baseAlign) !== null && _g !== void 0 ? _g : this.baseAlign;
        this.direction = (_h = options === null || options === void 0 ? void 0 : options.direction) !== null && _h !== void 0 ? _h : this.direction;
        this.quality = (_j = options === null || options === void 0 ? void 0 : options.quality) !== null && _j !== void 0 ? _j : this.quality;
        if (options === null || options === void 0 ? void 0 : options.shadow) {
            this.shadow = {};
            this.shadow.blur = (_k = options.shadow.blur) !== null && _k !== void 0 ? _k : this.shadow.blur;
            this.shadow.offset = (_l = options.shadow.offset) !== null && _l !== void 0 ? _l : this.shadow.offset;
            this.shadow.color = (_m = options.shadow.color) !== null && _m !== void 0 ? _m : this.shadow.color;
        }
        this.flagDirty();
    }
    clone() {
        return new Font(Object.assign(Object.assign(Object.assign({}, this.cloneGraphicOptions()), this.cloneRasterOptions()), { size: this.size, unit: this.unit, family: this.family, style: this.style, bold: this.bold, textAlign: this.textAlign, baseAlign: this.baseAlign, direction: this.direction, shadow: this.shadow
                ? {
                    blur: this.shadow.blur,
                    offset: this.shadow.offset,
                    color: this.shadow.color
                }
                : null }));
    }
    get fontString() {
        return `${this.style} ${this.bold ? 'bold' : ''} ${this.size}${this.unit} ${this.family}`;
    }
    get width() {
        return this._textWidth;
    }
    set width(value) {
        this._textWidth = value;
    }
    get height() {
        var _a, _b;
        const numLines = (_b = (_a = this._lines) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 1;
        return this._textHeight * numLines;
    }
    set height(value) {
        var _a, _b;
        const numLines = (_b = (_a = this._lines) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 1;
        this._textHeight = value / numLines;
    }
    get _rasterWidth() {
        return this._bitmap.width;
    }
    get _rasterHeight() {
        return this._bitmap.height;
    }
    get _halfRasterWidth() {
        return Math.floor(this._bitmap.width / 2);
    }
    get _halfRasterHeight() {
        return Math.floor(this._bitmap.height / 2);
    }
    get localBounds() {
        return this._textBounds;
    }
    _drawImage(ex, x, y) {
        if (this.dirty) {
            this.rasterize();
        }
        ex.drawImage(this._bitmap, 0, 0, this._rasterWidth, this._rasterHeight, x - this._rasterWidth / this.quality / 2, y - this._rasterHeight / this.quality / 2, this._rasterWidth / this.quality, this._rasterHeight / this.quality);
    }
    _rotate(ex) {
        var _a;
        // TODO this needs to change depending on the bounding box...
        const origin = (_a = this.origin) !== null && _a !== void 0 ? _a : this._textBounds.center;
        ex.translate(origin.x, origin.y);
        ex.rotate(this.rotation);
        ex.translate(-origin.x, -origin.y);
    }
    _flip(ex) {
        if (this.flipHorizontal) {
            ex.translate(this._textBounds.width / this.scale.x, 0);
            ex.scale(-1, 1);
        }
        if (this.flipVertical) {
            ex.translate(0, -this._textBounds.height / 2 / this.scale.y);
            ex.scale(1, -1);
        }
    }
    updateText(text) {
        if (this._text !== text) {
            this._text = text;
            this._lines = this._text.split('\n');
            this._updateDimensions();
            this.flagDirty();
        }
    }
    _updateDimensions() {
        if (this._text) {
            this._applyFont(this._ctx);
            const maxWidthLine = this._lines.reduce((a, b) => {
                return a.length > b.length ? a : b;
            });
            const metrics = this._ctx.measureText(maxWidthLine);
            this._textWidth = Math.abs(metrics.actualBoundingBoxLeft) + Math.abs(metrics.actualBoundingBoxRight);
            this._textHeight = Math.abs(metrics.actualBoundingBoxAscent) + Math.abs(metrics.actualBoundingBoxDescent);
            // TODO lineheight makes the text bounds wonky
            const lineAdjustedHeight = this._textHeight * this._lines.length;
            // this._textHeight = lineAdjustedHeight;
            // Changing the width and height clears the context properties
            // We double the bitmap width to account for alignment
            // We scale by "quality" so we render text without jaggies
            this._bitmap.width = (this._textWidth + this.padding * 2) * 2 * this.quality;
            this._bitmap.height = (lineAdjustedHeight + this.padding * 2) * 2 * this.quality;
            // These bounds exist in raster bitmap space where the top left corner is the corder of the bitmap
            const x = 0;
            const y = 0;
            const bottomBounds = lineAdjustedHeight - Math.abs(metrics.actualBoundingBoxAscent);
            this._textBounds = new BoundingBox({
                left: x - Math.abs(metrics.actualBoundingBoxLeft) - this.padding,
                top: y - Math.abs(metrics.actualBoundingBoxAscent) - this.padding,
                bottom: y + bottomBounds + this.padding,
                right: x + Math.abs(metrics.actualBoundingBoxRight) + this.padding
            });
        }
    }
    _preDraw(ex, x, y) {
        if (this.dirty) {
            this._updateDimensions();
        }
        super._preDraw(ex, x, y);
    }
    _postDraw(ex) {
        if (this.showDebug) {
            /* istanbul ignore next */
            ex.debug.drawRect(-this._halfRasterWidth, -this._halfRasterHeight, this._rasterWidth, this._rasterHeight);
        }
        ex.restore();
    }
    _applyFont(ctx) {
        ctx.translate(this.padding + this._halfRasterWidth, this.padding + this._halfRasterHeight);
        ctx.scale(this.quality, this.quality);
        ctx.textAlign = this.textAlign;
        ctx.textBaseline = this.baseAlign;
        ctx.font = this.fontString;
        ctx.direction = this.direction;
        if (this.shadow) {
            ctx.shadowColor = this.shadow.color.toString();
            ctx.shadowBlur = this.shadow.blur;
            ctx.shadowOffsetX = this.shadow.offset.x;
            ctx.shadowOffsetY = this.shadow.offset.y;
        }
    }
    execute(ctx) {
        if (this._text) {
            // The reason we need to re-apply the font is setting raster properties (like width/height) can reset the context props
            this._applyRasterProperites(ctx);
            this._applyFont(ctx);
            const lineHeight = this._textHeight; // TODO user specified line height
            for (let i = 0; i < this._lines.length; i++) {
                const line = this._lines[i];
                if (this.color) {
                    ctx.fillText(line, 0, i * lineHeight);
                }
                if (this.strokeColor) {
                    ctx.strokeText(line, 0, i * lineHeight);
                }
            }
            if (this.showDebug) {
                // Horizontal line
                /* istanbul ignore next */
                line(ctx, Color.Red, -this._halfRasterWidth, 0, this._halfRasterWidth, 0, 2);
                // Vertical line
                /* istanbul ignore next */
                line(ctx, Color.Red, 0, -this._halfRasterHeight, 0, this._halfRasterHeight, 2);
            }
        }
    }
    render(ex, text, x, y) {
        this.updateText(text);
        this.draw(ex, x, y);
    }
}

;// CONCATENATED MODULE: ./Graphics/Text.ts




class Text extends Graphic {
    constructor(options) {
        var _a, _b;
        super(options);
        this._text = '';
        // This order is important font, color, then text
        this.font = (_a = options.font) !== null && _a !== void 0 ? _a : new Font();
        this.color = (_b = options.color) !== null && _b !== void 0 ? _b : this.color;
        this.text = options.text;
    }
    clone() {
        return new Text({
            text: this.text.slice(),
            color: this.color.clone(),
            font: this.font.clone()
        });
    }
    get text() {
        return this._text;
    }
    set text(value) {
        this._text = value;
        this.font.updateText(value);
    }
    // TODO SpriteFont doesn't support a color yet :(
    get color() {
        if (this.font instanceof Font) {
            return this.font.color;
        }
        return Color.Black;
    }
    set color(color) {
        if (this.font instanceof Font) {
            this.font.color = color;
        }
    }
    get font() {
        return this._font;
    }
    set font(font) {
        if (font instanceof Font) {
            this._font = watch(font, (font) => font.flagDirty());
        }
        else {
            this._font = font;
        }
    }
    get width() {
        return this.font.width;
    }
    get height() {
        return this.font.height;
    }
    get localBounds() {
        return this.font.localBounds;
    }
    _rotate(_ex) {
        // None this is delegated to font
        // This override erases the default behavior
    }
    _flip(_ex) {
        // None this is delegated to font
        // This override erases the default behavior
    }
    _drawImage(ex, x, y) {
        if (this.font instanceof Font) {
            this.font.color = this.color;
        }
        this.font.flipHorizontal = this.flipHorizontal;
        this.font.flipVertical = this.flipVertical;
        this.font.scale = this.scale;
        this.font.rotation = this.rotation;
        this.font.origin = this.origin;
        this.font.opacity = this.opacity;
        this.font.render(ex, this._text, x, y);
    }
}

;// CONCATENATED MODULE: ./Label.ts
var Label_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};







/**
 * Labels are the way to draw small amounts of text to the screen. They are
 * actors and inherit all of the benefits and capabilities.
 */
class Label_Label extends Actor {
    /**
     * Build a new label
     * @param options
     */
    constructor(options) {
        super(options);
        this.font = new Font();
        this._text = new Text({ text: '', font: this.font });
        /**
         * Gets or sets the letter spacing on a Label. Only supported with Sprite Fonts.
         * @deprecated Use [[SpriteFont.spacing]]
         */
        this.letterSpacing = 0; //px
        /**
         * Whether or not the [[SpriteFont]] will be case-sensitive when matching characters.
         * @deprecated Use Graphics.SpriteFont.caseInsensitve
         */
        this.caseInsensitive = true;
        const { text, pos, x, y, spriteFont, font, color } = options;
        this.pos = pos !== null && pos !== void 0 ? pos : (x && y ? vec(x, y) : this.pos);
        this.text = text !== null && text !== void 0 ? text : this.text;
        this.spriteFont = spriteFont !== null && spriteFont !== void 0 ? spriteFont : this.spriteFont;
        this.font = font !== null && font !== void 0 ? font : this.font;
        this.color = color !== null && color !== void 0 ? color : this.color;
        const gfx = this.get(GraphicsComponent);
        gfx.anchor = Vector.Zero;
        gfx.use(this._text);
    }
    /**
     * The text to draw.
     */
    get text() {
        return this._text.text;
    }
    set text(text) {
        this._text.text = text;
    }
    get color() {
        return this._text.color;
    }
    set color(color) {
        this._text.color = color;
    }
    get opacity() {
        return this._text.opacity;
    }
    set opacity(opacity) {
        this._text.opacity = opacity;
    }
    /**
     * Sets or gets the bold property of the label's text, by default it's false
     * @deprecated Use [[Font.bold|Label.font.bold]]
     */
    get bold() {
        return this.font.bold;
    }
    set bold(isBold) {
        this.font.bold = isBold;
    }
    /**
     * The CSS font family string (e.g. `sans-serif`, `Droid Sans Pro`). Web fonts
     * are supported, same as in CSS.
     * @deprecated Use [[Font.family|Label.font.family]]
     */
    get fontFamily() {
        return this.font.family;
    }
    set fontFamily(family) {
        this.font.family = family;
    }
    /**
     * The font size in the selected units, default is 10 (default units is pixel)
     * @deprecated Use [[Font.size|Label.font.size]]
     */
    get fontSize() {
        return this.font.size;
    }
    set fontSize(sizeInUnit) {
        this.font.size = sizeInUnit;
    }
    /**
     * The font style for this label, the default is [[FontStyle.Normal]]
     * @deprecated Use [[Font.style|Label.font.style]]
     */
    get fontStyle() {
        return this.font.style;
    }
    set fontStyle(style) {
        this.font.style = style;
    }
    /**
     * The css units for a font size such as px, pt, em (SpriteFont only support px), by default is 'px';
     * @deprecated Use [[Font.unit|Label.font.unit]]
     */
    get fontUnit() {
        return this.font.unit;
    }
    set fontUnit(unit) {
        this.font.unit = unit;
    }
    /**
     * Gets or sets the horizontal text alignment property for the label.
     * @deprecated Use [[Font.textAlign|Label.font.textAlign]]
     */
    get textAlign() {
        return this.font.textAlign;
    }
    set textAlign(align) {
        this.font.textAlign = align;
    }
    /**
     * Gets or sets the baseline alignment property for the label.
     * @deprecated Use [[Font.baseAlign|Label.font.baseAlign]]
     */
    get baseAlign() {
        return this.font.baseAlign;
    }
    set baseAlign(align) {
        this.font.baseAlign = align;
    }
    /**
     * The [[LegacyDrawing.SpriteFont]] to use, if any. Overrides [[fontFamily]] if present.
     * @deprecated Use [[SpriteFont]]
     */
    get spriteFont() {
        return this._legacySpriteFont;
    }
    set spriteFont(sf) {
        if (sf) {
            if (sf instanceof SpriteFont) {
                this._legacySpriteFont = sf;
                this._spriteFont = SpriteFont_SpriteFont.fromLegacySpriteFont(sf);
                this._text.font = this._spriteFont;
                return;
            }
            this._spriteFont = sf;
            this._text.font = this._spriteFont;
        }
    }
    _initialize(engine) {
        super._initialize(engine);
        this._graphicsContext = engine.graphicsContext;
    }
    /**
     * Returns the width of the text in the label (in pixels);
     */
    getTextWidth() {
        return this._text.width;
    }
    /**
     * Sets the text shadow for sprite fonts
     * @param offsetX      The x offset in pixels to place the shadow
     * @param offsetY      The y offset in pixels to place the shadow
     * @param shadowColor  The color of the text shadow
     * @deprecated Use [[Font.shadow|Label.font.shadow]]
     */
    setTextShadow(offsetX, offsetY, shadowColor) {
        this.font.shadow = { offset: vec(offsetX, offsetY), blur: 2, color: shadowColor };
    }
    /**
     * Toggles text shadows on or off, only applies when using sprite fonts
     * @deprecated Use [[Font.shadow|Label.font.shadow]]
     */
    useTextShadow(on) {
        if (this.spriteFont) {
            this.spriteFont.useTextShadow(on);
        }
    }
    /**
     * Clears the current text shadow
     * @deprecated Use [[Font.shadow|Label.font.shadow]]
     */
    clearTextShadow() {
        this.font.shadow = null;
    }
    draw(_ctx, _delta) {
        const exctx = this._graphicsContext;
        this._text.draw(exctx, 0, 0);
    }
}
Label_decorate([
    obsolete({
        message: 'Label.bold will be removed in v0.26.0',
        alternateMethod: 'Use Label.font.bold'
    })
], Label_Label.prototype, "bold", null);
Label_decorate([
    obsolete({
        message: 'Label.fontFamily will be removed in v0.26.0',
        alternateMethod: 'Use Label.font.family'
    })
], Label_Label.prototype, "fontFamily", null);
Label_decorate([
    obsolete({
        message: 'Label.fontSize will be removed in v0.26.0',
        alternateMethod: 'Use Label.font.size'
    })
], Label_Label.prototype, "fontSize", null);
Label_decorate([
    obsolete({
        message: 'Label.fontStyle will be removed in v0.26.0',
        alternateMethod: 'Use Lable.font.style'
    })
], Label_Label.prototype, "fontStyle", null);
Label_decorate([
    obsolete({
        message: 'Label.fontUnit will be removed in v0.26.0',
        alternateMethod: 'Use Label.font.unit'
    })
], Label_Label.prototype, "fontUnit", null);
Label_decorate([
    obsolete({
        message: 'Label.textAlign will be removed in v0.26.0',
        alternateMethod: 'Use Label.font.textAlign'
    })
], Label_Label.prototype, "textAlign", null);
Label_decorate([
    obsolete({
        message: 'Label.baseAlign will be removed in v0.26.0',
        alternateMethod: 'Use Label.font.baseAlign'
    })
], Label_Label.prototype, "baseAlign", null);
Label_decorate([
    obsolete()
], Label_Label.prototype, "spriteFont", null);
Label_decorate([
    obsolete({
        message: 'Label.setTextShadow will be removed in v0.26.0',
        alternateMethod: 'Use Label.font.shadow'
    })
], Label_Label.prototype, "setTextShadow", null);
Label_decorate([
    obsolete({
        message: 'Label.useTextShadow will be removed in v0.26.0',
        alternateMethod: 'Use Label.font.shadow'
    })
], Label_Label.prototype, "useTextShadow", null);
Label_decorate([
    obsolete({
        message: 'Label.clearTextShadow will be removed in v0.26.0',
        alternateMethod: 'Use Label.font.shadow'
    })
], Label_Label.prototype, "clearTextShadow", null);

;// CONCATENATED MODULE: ./Actions/Index.ts






















;// CONCATENATED MODULE: ./Collision/Group/CollisionGroupManager.ts

/**
 * Static class for managing collision groups in excalibur, there is a maximum of 32 collision groups possible in excalibur
 */
class CollisionGroupManager {
    /**
     * Create a new named collision group up to a max of 32.
     * @param name Name for the collision group
     * @param mask Optionally provide your own 32-bit mask, if none is provide the manager will generate one
     */
    static create(name, mask) {
        if (this._CURRENT_GROUP > this._MAX_GROUPS) {
            throw new Error(`Cannot have more than ${this._MAX_GROUPS} collision groups`);
        }
        if (this._GROUPS.get(name)) {
            throw new Error(`Collision group ${name} already exists`);
        }
        const group = new CollisionGroup(name, this._CURRENT_BIT, mask !== undefined ? mask : ~this._CURRENT_BIT);
        this._CURRENT_BIT = (this._CURRENT_BIT << 1) | 0;
        this._CURRENT_GROUP++;
        this._GROUPS.set(name, group);
        return group;
    }
    /**
     * Get all collision groups currently tracked by excalibur
     */
    static get groups() {
        return Array.from(this._GROUPS.values());
    }
    /**
     * Get a collision group by it's name
     * @param name
     */
    static groupByName(name) {
        return this._GROUPS.get(name);
    }
    /**
     * Resets the managers internal group management state
     */
    static reset() {
        this._GROUPS = new Map();
        this._CURRENT_BIT = this._STARTING_BIT;
        this._CURRENT_GROUP = 1;
    }
}
// using bitmasking the maximum number of groups is 32, because that is the highest 32bit integer that JS can present.
CollisionGroupManager._STARTING_BIT = 0b1 | 0;
CollisionGroupManager._MAX_GROUPS = 32;
CollisionGroupManager._CURRENT_GROUP = 1;
CollisionGroupManager._CURRENT_BIT = CollisionGroupManager._STARTING_BIT;
CollisionGroupManager._GROUPS = new Map();

;// CONCATENATED MODULE: ./Collision/Index.ts





























;// CONCATENATED MODULE: ./Drawing/Polygon.ts
var Polygon_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


/**
 * Creates a closed polygon drawing given a list of [[Vector]]s.
 *
 * @deprecated Use [[Polygon]]
 * @warning Use sparingly as Polygons are performance intensive
 */
let Polygon = class Polygon {
    /**
     * @param points  The vectors to use to build the polygon in order
     */
    constructor(points) {
        /**
         * The width of the lines of the polygon
         */
        this.lineWidth = 5;
        /**
         * Indicates whether the polygon is filled or not.
         */
        this.filled = false;
        this._points = [];
        this.anchor = Vector.Zero;
        this.offset = Vector.Zero;
        this.rotation = 0;
        this.scale = Vector.One;
        this.opacity = 1;
        this._points = points;
        const minX = this._points.reduce((prev, curr) => {
            return Math.min(prev, curr.x);
        }, 0);
        const maxX = this._points.reduce((prev, curr) => {
            return Math.max(prev, curr.x);
        }, 0);
        this.drawWidth = maxX - minX;
        const minY = this._points.reduce((prev, curr) => {
            return Math.min(prev, curr.y);
        }, 0);
        const maxY = this._points.reduce((prev, curr) => {
            return Math.max(prev, curr.y);
        }, 0);
        this.drawHeight = maxY - minY;
        this.height = this.drawHeight;
        this.width = this.drawWidth;
    }
    /**
     * @notimplemented Effects are not supported on `Polygon`
     */
    addEffect() {
        // not supported on polygons
    }
    /**
     * @notimplemented Effects are not supported on `Polygon`
     */
    removeEffect() {
        // not supported on polygons
    }
    /**
     * @notimplemented Effects are not supported on `Polygon`
     */
    clearEffects() {
        // not supported on polygons
    }
    reset() {
        //pass
    }
    draw(ctxOrOptions, x, y) {
        if (ctxOrOptions instanceof CanvasRenderingContext2D) {
            this._drawWithOptions({ ctx: ctxOrOptions, x, y });
        }
        else {
            this._drawWithOptions(ctxOrOptions);
        }
    }
    _drawWithOptions(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const { ctx, x, y, rotation, drawWidth, drawHeight, anchor, offset, opacity, flipHorizontal, flipVertical } = Object.assign(Object.assign({}, options), { rotation: (_a = options.rotation) !== null && _a !== void 0 ? _a : this.rotation, drawWidth: (_b = options.drawWidth) !== null && _b !== void 0 ? _b : this.drawWidth, drawHeight: (_c = options.drawHeight) !== null && _c !== void 0 ? _c : this.drawHeight, flipHorizontal: (_d = options.flipHorizontal) !== null && _d !== void 0 ? _d : this.flipHorizontal, flipVertical: (_e = options.flipVertical) !== null && _e !== void 0 ? _e : this.flipVertical, anchor: (_f = options.anchor) !== null && _f !== void 0 ? _f : this.anchor, offset: (_g = options.offset) !== null && _g !== void 0 ? _g : this.offset, opacity: ((_h = options.opacity) !== null && _h !== void 0 ? _h : 1) * ((_j = this.opacity) !== null && _j !== void 0 ? _j : 1) });
        const xpoint = drawWidth * anchor.x + offset.x + x;
        const ypoint = drawHeight * anchor.y + offset.y + y;
        ctx.save();
        ctx.translate(xpoint, ypoint);
        ctx.scale(this.scale.x, this.scale.y);
        ctx.rotate(rotation);
        ctx.beginPath();
        ctx.lineWidth = this.lineWidth;
        // Iterate through the supplied points and construct a 'polygon'
        const firstPoint = this._points[0];
        ctx.moveTo(firstPoint.x, firstPoint.y);
        let i = 0;
        const len = this._points.length;
        for (i; i < len; i++) {
            ctx.lineTo(this._points[i].x, this._points[i].y);
        }
        ctx.lineTo(firstPoint.x, firstPoint.y);
        ctx.closePath();
        if (this.filled) {
            ctx.fillStyle = this.fillColor.toString();
            ctx.fill();
        }
        ctx.strokeStyle = this.lineColor.toString();
        if (flipHorizontal) {
            ctx.translate(drawWidth, 0);
            ctx.scale(-1, 1);
        }
        if (flipVertical) {
            ctx.translate(0, drawHeight);
            ctx.scale(1, -1);
        }
        const oldAlpha = ctx.globalAlpha;
        ctx.globalAlpha = opacity;
        ctx.stroke();
        ctx.globalAlpha = oldAlpha;
        ctx.restore();
    }
};
Polygon = Polygon_decorate([
    obsolete({
        message: 'Polygon will be removed in v0.26.0',
        alternateMethod: 'Use Graphics.Polygon'
    })
], Polygon);


;// CONCATENATED MODULE: ./Drawing/Index.ts










;// CONCATENATED MODULE: ./Interfaces/AudioImplementation.ts
class ExResponse {
}
ExResponse.type = {
    any: '',
    blob: 'blob',
    json: 'json',
    text: 'text',
    document: 'document',
    arraybuffer: 'arraybuffer'
};

;// CONCATENATED MODULE: ./Interfaces/LifecycleEvents.ts
/**
 * Type guard checking for internal initialize method
 * @internal
 * @param a
 */
function has_initialize(a) {
    return !!a._initialize;
}
/**
 *
 */
function hasOnInitialize(a) {
    return !!a.onInitialize;
}
/**
 *
 */
function has_preupdate(a) {
    return !!a._preupdate;
}
/**
 *
 */
function hasOnPreUpdate(a) {
    return !!a.onPreUpdate;
}
/**
 *
 */
function has_postupdate(a) {
    return !!a.onPostUpdate;
}
/**
 *
 */
function hasOnPostUpdate(a) {
    return !!a.onPostUpdate;
}
/**
 *
 */
function hasPreDraw(a) {
    return !!a.onPreDraw;
}
/**
 *
 */
function hasPostDraw(a) {
    return !!a.onPostDraw;
}

;// CONCATENATED MODULE: ./Interfaces/Index.ts










;// CONCATENATED MODULE: ./PostProcessing/Index.ts



;// CONCATENATED MODULE: ./Resources/Sound/WebAudioInstance.ts


/**
 * Internal class representing a Web Audio AudioBufferSourceNode instance
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API
 */
class WebAudioInstance {
    constructor(_src) {
        this._src = _src;
        this._volume = 1;
        this._duration = undefined;
        this._loop = false;
        this._isPlaying = false;
        this._isPaused = false;
        this._audioContext = AudioContextFactory.create();
        this._volumeNode = this._audioContext.createGain();
        /**
         * Current playback offset (in seconds)
         */
        this._currentOffset = 0;
        this._createNewBufferSource();
    }
    set loop(value) {
        this._loop = value;
        if (this._instance) {
            this._instance.loop = value;
            this._wireUpOnEnded();
        }
    }
    get loop() {
        return this._loop;
    }
    set volume(value) {
        value = clamp(value, 0, 1.0);
        this._volume = value;
        if (this._isPlaying && this._volumeNode.gain.setTargetAtTime) {
            // https://developer.mozilla.org/en-US/docs/Web/API/AudioParam/setTargetAtTime
            // After each .1 seconds timestep, the target value will ~63.2% closer to the target value.
            // This exponential ramp provides a more pleasant transition in gain
            this._volumeNode.gain.setTargetAtTime(value, this._audioContext.currentTime, 0.1);
        }
        else {
            this._volumeNode.gain.value = value;
        }
    }
    get volume() {
        return this._volume;
    }
    set duration(value) {
        this._duration = value;
    }
    /**
     * Duration of the sound, in seconds.
     */
    get duration() {
        return this._duration;
    }
    get _playbackRate() {
        return this._instance ? 1 / (this._instance.playbackRate.value || 1.0) : null;
    }
    isPlaying() {
        return this._isPlaying;
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    play(playStarted = () => { }) {
        if (this._isPaused) {
            this._resumePlayBack();
            playStarted();
        }
        if (!this._isPlaying) {
            this._startPlayBack();
            playStarted();
        }
        return this._playingPromise;
    }
    pause() {
        if (!this._isPlaying) {
            return;
        }
        this._isPaused = true;
        this._isPlaying = false;
        this._instance.stop(0);
        // Playback rate will be a scale factor of how fast/slow the audio is being played
        // default is 1.0
        // we need to invert it to get the time scale
        this._setPauseOffset();
    }
    stop() {
        if (!this._isPlaying) {
            return;
        }
        this._isPlaying = false;
        this._isPaused = false;
        this._currentOffset = 0;
        this._instance.stop(0);
        // handler will not be wired up if we were looping
        if (!this._instance.onended) {
            this._handleOnEnded();
        }
    }
    _startPlayBack() {
        this._isPlaying = true;
        this._isPaused = false;
        this._playingPromise = new Promise((resolve) => {
            this._playingResolve = resolve;
        });
        if (!this._instance) {
            this._createNewBufferSource();
        }
        this._rememberStartTime();
        this._volumeNode.connect(this._audioContext.destination);
        this._instance.start(0, 0);
        this._currentOffset = 0;
        this._wireUpOnEnded();
    }
    _resumePlayBack() {
        if (!this._isPaused) {
            return;
        }
        this._isPaused = false;
        this._isPlaying = true;
        // a buffer source can only be started once
        // so we need to dispose of the previous instance before
        // "resuming" the next one
        this._instance.onended = null; // dispose of any previous event handler
        this._createNewBufferSource();
        const duration = this._playbackRate * this._src.duration;
        const restartTime = this._currentOffset % duration;
        this._rememberStartTime(restartTime * -1000);
        this._instance.start(0, restartTime);
        this._wireUpOnEnded();
    }
    _wireUpOnEnded() {
        if (!this.loop) {
            this._instance.onended = () => this._handleOnEnded();
        }
    }
    _handleOnEnded() {
        // pausing calls stop(0) which triggers onended event
        // so we don't "resolve" yet (when we resume we'll try again)
        if (!this._isPaused) {
            this._isPlaying = false;
            this._playingResolve(true);
        }
    }
    _rememberStartTime(amend) {
        this._startTime = new Date().getTime() + (amend | 0);
    }
    _setPauseOffset() {
        this._currentOffset = ((new Date().getTime() - this._startTime) * this._playbackRate) / 1000; // in seconds
    }
    _createNewBufferSource() {
        this._instance = this._audioContext.createBufferSource();
        this._instance.buffer = this._src;
        this._instance.loop = this.loop;
        this._instance.playbackRate.setValueAtTime(1.0, 0);
        this._instance.connect(this._volumeNode);
    }
}

;// CONCATENATED MODULE: ./Util/Sound.ts

/**
 * Whether or not the browser can play this file as HTML5 Audio
 */
function canPlayFile(file) {
    try {
        const a = new Audio();
        const filetype = /.*\.([A-Za-z0-9]+)$/;
        const type = file.match(filetype)[1];
        if (a.canPlayType('audio/' + type)) {
            return true;
        }
        else {
            return false;
        }
    }
    catch (e) {
        Logger.getInstance().warn('Cannot determine audio support, assuming no support for the Audio Tag', e);
        return false;
    }
}

;// CONCATENATED MODULE: ./Resources/Sound/Sound.ts
var Sound_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};








/**
 * The [[Sound]] object allows games built in Excalibur to load audio
 * components, from soundtracks to sound effects. [[Sound]] is an [[Loadable]]
 * which means it can be passed to a [[Loader]] to pre-load before a game or level.
 */
class Sound extends Class {
    /**
     * @param paths A list of audio sources (clip.wav, clip.mp3, clip.ogg) for this audio clip. This is done for browser compatibility.
     */
    constructor(...paths) {
        super();
        this.logger = Logger.getInstance();
        this._loop = false;
        this._volume = 1;
        this._duration = undefined;
        this._isStopped = false;
        this._isPaused = false;
        this._tracks = [];
        this._wasPlayingOnHidden = false;
        this._audioContext = AudioContextFactory.create();
        this._resource = new Resource('', ExResponse.type.arraybuffer);
        /**
         * Chrome : MP3, WAV, Ogg
         * Firefox : WAV, Ogg,
         * IE : MP3, WAV coming soon
         * Safari MP3, WAV, Ogg
         */
        for (const path of paths) {
            if (canPlayFile(path)) {
                this.path = path;
                break;
            }
        }
        if (!this.path) {
            this.logger.warn('This browser does not support any of the audio files specified:', paths.join(', '));
            this.logger.warn('Attempting to use', paths[0]);
            this.path = paths[0]; // select the first specified
        }
    }
    /**
     * Indicates whether the clip should loop when complete
     * @param value  Set the looping flag
     */
    set loop(value) {
        this._loop = value;
        for (const track of this._tracks) {
            track.loop = this._loop;
        }
        this.logger.debug('Set loop for all instances of sound', this.path, 'to', this._loop);
    }
    get loop() {
        return this._loop;
    }
    set volume(value) {
        this._volume = value;
        for (const track of this._tracks) {
            track.volume = this._volume;
        }
        this.emit('volumechange', new NativeSoundEvent(this));
        this.logger.debug('Set loop for all instances of sound', this.path, 'to', this._volume);
    }
    get volume() {
        return this._volume;
    }
    get duration() {
        return this._duration;
    }
    /**
     * Return array of Current AudioInstances playing or being paused
     */
    get instances() {
        return this._tracks;
    }
    get path() {
        return this._resource.path;
    }
    set path(val) {
        this._resource.path = val;
    }
    isLoaded() {
        return !!this.data;
    }
    load() {
        return Sound_awaiter(this, void 0, void 0, function* () {
            if (this.data) {
                return this.data;
            }
            const arraybuffer = yield this._resource.load();
            const audiobuffer = yield this.decodeAudio(arraybuffer.slice(0));
            this._duration = typeof audiobuffer === 'object' ? audiobuffer.duration : undefined;
            this.emit('processed', new NativeSoundProcessedEvent(this, audiobuffer));
            return this.data = audiobuffer;
        });
    }
    decodeAudio(data) {
        return Sound_awaiter(this, void 0, void 0, function* () {
            try {
                return yield this._audioContext.decodeAudioData(data.slice(0));
            }
            catch (e) {
                this.logger.error('Unable to decode ' +
                    ' this browser may not fully support this format, or the file may be corrupt, ' +
                    'if this is an mp3 try removing id3 tags and album art from the file.');
                return yield Promise.reject();
            }
        });
    }
    wireEngine(engine) {
        if (engine) {
            this._engine = engine;
            this._engine.on('hidden', () => {
                if (engine.pauseAudioWhenHidden && this.isPlaying()) {
                    this._wasPlayingOnHidden = true;
                    this.pause();
                }
            });
            this._engine.on('visible', () => {
                if (engine.pauseAudioWhenHidden && this._wasPlayingOnHidden) {
                    this.play();
                    this._wasPlayingOnHidden = false;
                }
            });
            this._engine.on('start', () => {
                this._isStopped = false;
            });
            this._engine.on('stop', () => {
                this.stop();
                this._isStopped = true;
            });
        }
    }
    /**
     * Returns how many instances of the sound are currently playing
     */
    instanceCount() {
        return this._tracks.length;
    }
    /**
     * Whether or not the sound is playing right now
     */
    isPlaying() {
        return this._tracks.some((t) => t.isPlaying());
    }
    /**
     * Play the sound, returns a promise that resolves when the sound is done playing
     * An optional volume argument can be passed in to play the sound. Max volume is 1.0
     */
    play(volume) {
        if (!this.isLoaded()) {
            this.logger.warn('Cannot start playing. Resource', this.path, 'is not loaded yet');
            return Promise.resolve(true);
        }
        if (this._isStopped) {
            this.logger.warn('Cannot start playing. Engine is in a stopped state.');
            return Promise.resolve(false);
        }
        this.volume = volume || this.volume;
        if (this._isPaused) {
            return this._resumePlayback();
        }
        else {
            return this._startPlayback();
        }
    }
    /**
     * Stop the sound, and do not rewind
     */
    pause() {
        if (!this.isPlaying()) {
            return;
        }
        for (const track of this._tracks) {
            track.pause();
        }
        this._isPaused = true;
        this.emit('pause', new NativeSoundEvent(this));
        this.logger.debug('Paused all instances of sound', this.path);
    }
    /**
     * Stop the sound if it is currently playing and rewind the track. If the sound is not playing, rewinds the track.
     */
    stop() {
        for (const track of this._tracks) {
            track.stop();
        }
        this.emit('stop', new NativeSoundEvent(this));
        this._isPaused = false;
        this._tracks.length = 0;
        this.logger.debug('Stopped all instances of sound', this.path);
    }
    /**
     * Get Id of provided AudioInstance in current trackList
     * @param track [[Audio]] which Id is to be given
     */
    getTrackId(track) {
        return this._tracks.indexOf(track);
    }
    _resumePlayback() {
        return Sound_awaiter(this, void 0, void 0, function* () {
            if (this._isPaused) {
                const resumed = [];
                // ensure we resume *current* tracks (if paused)
                for (const track of this._tracks) {
                    resumed.push(track.play());
                }
                this._isPaused = false;
                this.emit('resume', new NativeSoundEvent(this));
                this.logger.debug('Resuming paused instances for sound', this.path, this._tracks);
                // resolve when resumed tracks are done
                yield Promise.all(resumed);
            }
            return true;
        });
    }
    /**
     * Starts playback, returns a promise that resolves when playback is complete
     */
    _startPlayback() {
        return Sound_awaiter(this, void 0, void 0, function* () {
            const track = yield this._getTrackInstance(this.data);
            const complete = yield track.play(() => {
                this.emit('playbackstart', new NativeSoundEvent(this, track));
                this.logger.debug('Playing new instance for sound', this.path);
            });
            // when done, remove track
            this.emit('playbackend', new NativeSoundEvent(this, track));
            this._tracks.splice(this.getTrackId(track), 1);
            return complete;
        });
    }
    _getTrackInstance(data) {
        const newTrack = new WebAudioInstance(data);
        newTrack.loop = this.loop;
        newTrack.volume = this.volume;
        newTrack.duration = this.duration;
        this._tracks.push(newTrack);
        return newTrack;
    }
}

;// CONCATENATED MODULE: ./Resources/Sound/Index.ts




;// CONCATENATED MODULE: ./Resources/Gif.ts
var Gif_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};







/**
 * The [[Texture]] object allows games built in Excalibur to load image resources.
 * [[Texture]] is an [[Loadable]] which means it can be passed to a [[Loader]]
 * to pre-load before starting a level or game.
 */
class Gif {
    /**
     * @param path       Path to the image resource
     * @param color      Optionally set the color to treat as transparent the gif, by default [[Color.Magenta]]
     * @param bustCache  Optionally load texture with cache busting
     */
    constructor(path, color = Color.Magenta, bustCache = true) {
        this.path = path;
        this.color = color;
        this.bustCache = bustCache;
        this._stream = null;
        this._gif = null;
        this._textures = [];
        this._animation = null;
        this._transparentColor = null;
        this._resource = new Resource(path, 'arraybuffer', bustCache);
        this._transparentColor = color;
    }
    /**
     * Begins loading the texture and returns a promise to be resolved on completion
     */
    load() {
        return Gif_awaiter(this, void 0, void 0, function* () {
            const arraybuffer = yield this._resource.load();
            this._stream = new Stream(arraybuffer);
            this._gif = new ParseGif(this._stream, this._transparentColor);
            const images = this._gif.images.map(i => new ImageSource(i.src, false));
            // Load all textures
            yield Promise.all(images.map(t => t.load()));
            return this.data = this._textures = images;
        });
    }
    isLoaded() {
        return !!this.data;
    }
    /**
     * Return a frame of the gif as a legacy sprite by index
     * @deprecated
     */
    toLegacySprite(id = 0) {
        return Sprite.toLegacySprite(this.toSprite(id));
    }
    /**
     * Return the gif as a legacy spritesheet
     * @deprecated
     * @returns
     */
    toLegacySpriteSheet() {
        return SpriteSheet.toLegacySpriteSheet(this.toSpriteSheet());
    }
    /**
     * Return the gif as a legacy animation
     * @deprecated
     * @param speed
     */
    toLegacyAnimation(engine, speed) {
        return Animation.toLegacyAnimation(engine, this.toAnimation(speed));
    }
    /**
     * Return a frame of the gif as a sprite by id
     * @param id
     */
    toSprite(id = 0) {
        const sprite = this._textures[id].toSprite();
        return sprite;
    }
    /**
     * Return the gif as a spritesheet
     */
    toSpriteSheet() {
        const sprites = this._textures.map((image) => {
            return image.toSprite();
        });
        return new SpriteSheet({ sprites });
    }
    /**
     * Transform the GIF into an animation with duration per frame
     */
    toAnimation(durationPerFrameMs) {
        const spriteSheet = this.toSpriteSheet();
        const length = spriteSheet.sprites.length;
        this._animation = Animation.fromSpriteSheet(spriteSheet, range(0, length), durationPerFrameMs);
        return this._animation;
    }
    get readCheckBytes() {
        return this._gif.checkBytes;
    }
}
const bitsToNum = (ba) => {
    return ba.reduce(function (s, n) {
        return s * 2 + n;
    }, 0);
};
const byteToBitArr = (bite) => {
    const a = [];
    for (let i = 7; i >= 0; i--) {
        a.push(!!(bite & (1 << i)));
    }
    return a;
};
class Stream {
    constructor(dataArray) {
        this.data = null;
        this.len = 0;
        this.position = 0;
        this.readByte = () => {
            if (this.position >= this.data.byteLength) {
                throw new Error('Attempted to read past end of stream.');
            }
            return this.data[this.position++];
        };
        this.readBytes = (n) => {
            const bytes = [];
            for (let i = 0; i < n; i++) {
                bytes.push(this.readByte());
            }
            return bytes;
        };
        this.read = (n) => {
            let s = '';
            for (let i = 0; i < n; i++) {
                s += String.fromCharCode(this.readByte());
            }
            return s;
        };
        this.readUnsigned = () => {
            // Little-endian.
            const a = this.readBytes(2);
            return (a[1] << 8) + a[0];
        };
        this.data = new Uint8Array(dataArray);
        this.len = this.data.byteLength;
        if (this.len === 0) {
            throw new Error('No data loaded from file');
        }
    }
}
const lzwDecode = function (minCodeSize, data) {
    // TODO: Now that the GIF parser is a bit different, maybe this should get an array of bytes instead of a String?
    let pos = 0; // Maybe this streaming thing should be merged with the Stream?
    const readCode = function (size) {
        let code = 0;
        for (let i = 0; i < size; i++) {
            if (data.charCodeAt(pos >> 3) & (1 << (pos & 7))) {
                code |= 1 << i;
            }
            pos++;
        }
        return code;
    };
    const output = [];
    const clearCode = 1 << minCodeSize;
    const eoiCode = clearCode + 1;
    let codeSize = minCodeSize + 1;
    let dict = [];
    const clear = function () {
        dict = [];
        codeSize = minCodeSize + 1;
        for (let i = 0; i < clearCode; i++) {
            dict[i] = [i];
        }
        dict[clearCode] = [];
        dict[eoiCode] = null;
    };
    let code;
    let last;
    while (true) {
        last = code;
        code = readCode(codeSize);
        if (code === clearCode) {
            clear();
            continue;
        }
        if (code === eoiCode) {
            break;
        }
        if (code < dict.length) {
            if (last !== clearCode) {
                dict.push(dict[last].concat(dict[code][0]));
            }
        }
        else {
            if (code !== dict.length) {
                throw new Error('Invalid LZW code.');
            }
            dict.push(dict[last].concat(dict[last][0]));
        }
        output.push.apply(output, dict[code]);
        if (dict.length === 1 << codeSize && codeSize < 12) {
            // If we're at the last code and codeSize is 12, the next code will be a clearCode, and it'll be 12 bits long.
            codeSize++;
        }
    }
    // I don't know if this is technically an error, but some GIFs do it.
    //if (Math.ceil(pos / 8) !== data.length) throw new Error('Extraneous LZW bytes.');
    return output;
};
// The actual parsing; returns an object with properties.
class ParseGif {
    constructor(stream, color = Color.Magenta) {
        this._st = null;
        this._handler = {};
        this._transparentColor = null;
        this.frames = [];
        this.images = [];
        this.globalColorTable = [];
        this.checkBytes = [];
        // LZW (GIF-specific)
        this.parseColorTable = (entries) => {
            // Each entry is 3 bytes, for RGB.
            const ct = [];
            for (let i = 0; i < entries; i++) {
                const rgb = this._st.readBytes(3);
                const rgba = '#' +
                    rgb
                        .map((x) => {
                        const hex = x.toString(16);
                        return hex.length === 1 ? '0' + hex : hex;
                    })
                        .join('');
                ct.push(rgba);
            }
            return ct;
        };
        this.readSubBlocks = () => {
            let size, data;
            data = '';
            do {
                size = this._st.readByte();
                data += this._st.read(size);
            } while (size !== 0);
            return data;
        };
        this.parseHeader = () => {
            const hdr = {
                sig: null,
                ver: null,
                width: null,
                height: null,
                colorRes: null,
                globalColorTableSize: null,
                gctFlag: null,
                sorted: null,
                globalColorTable: [],
                bgColor: null,
                pixelAspectRatio: null // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64
            };
            hdr.sig = this._st.read(3);
            hdr.ver = this._st.read(3);
            if (hdr.sig !== 'GIF') {
                throw new Error('Not a GIF file.'); // XXX: This should probably be handled more nicely.
            }
            hdr.width = this._st.readUnsigned();
            hdr.height = this._st.readUnsigned();
            const bits = byteToBitArr(this._st.readByte());
            hdr.gctFlag = bits.shift();
            hdr.colorRes = bitsToNum(bits.splice(0, 3));
            hdr.sorted = bits.shift();
            hdr.globalColorTableSize = bitsToNum(bits.splice(0, 3));
            hdr.bgColor = this._st.readByte();
            hdr.pixelAspectRatio = this._st.readByte(); // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64
            if (hdr.gctFlag) {
                hdr.globalColorTable = this.parseColorTable(1 << (hdr.globalColorTableSize + 1));
                this.globalColorTable = hdr.globalColorTable;
            }
            if (this._handler.hdr && this._handler.hdr(hdr)) {
                this.checkBytes.push(this._handler.hdr);
            }
        };
        this.parseExt = (block) => {
            const parseGCExt = (block) => {
                this.checkBytes.push(this._st.readByte()); // Always 4
                const bits = byteToBitArr(this._st.readByte());
                block.reserved = bits.splice(0, 3); // Reserved; should be 000.
                block.disposalMethod = bitsToNum(bits.splice(0, 3));
                block.userInput = bits.shift();
                block.transparencyGiven = bits.shift();
                block.delayTime = this._st.readUnsigned();
                block.transparencyIndex = this._st.readByte();
                block.terminator = this._st.readByte();
                if (this._handler.gce && this._handler.gce(block)) {
                    this.checkBytes.push(this._handler.gce);
                }
            };
            const parseComExt = (block) => {
                block.comment = this.readSubBlocks();
                if (this._handler.com && this._handler.com(block)) {
                    this.checkBytes.push(this._handler.com);
                }
            };
            const parsePTExt = (block) => {
                this.checkBytes.push(this._st.readByte()); // Always 12
                block.ptHeader = this._st.readBytes(12);
                block.ptData = this.readSubBlocks();
                if (this._handler.pte && this._handler.pte(block)) {
                    this.checkBytes.push(this._handler.pte);
                }
            };
            const parseAppExt = (block) => {
                const parseNetscapeExt = (block) => {
                    this.checkBytes.push(this._st.readByte()); // Always 3
                    block.unknown = this._st.readByte(); // Q: Always 1? What is this?
                    block.iterations = this._st.readUnsigned();
                    block.terminator = this._st.readByte();
                    if (this._handler.app && this._handler.app.NETSCAPE && this._handler.app.NETSCAPE(block)) {
                        this.checkBytes.push(this._handler.app);
                    }
                };
                const parseUnknownAppExt = (block) => {
                    block.appData = this.readSubBlocks();
                    // FIXME: This won't work if a handler wants to match on any identifier.
                    if (this._handler.app && this._handler.app[block.identifier] && this._handler.app[block.identifier](block)) {
                        this.checkBytes.push(this._handler.app[block.identifier]);
                    }
                };
                this.checkBytes.push(this._st.readByte()); // Always 11
                block.identifier = this._st.read(8);
                block.authCode = this._st.read(3);
                switch (block.identifier) {
                    case 'NETSCAPE':
                        parseNetscapeExt(block);
                        break;
                    default:
                        parseUnknownAppExt(block);
                        break;
                }
            };
            const parseUnknownExt = (block) => {
                block.data = this.readSubBlocks();
                if (this._handler.unknown && this._handler.unknown(block)) {
                    this.checkBytes.push(this._handler.unknown);
                }
            };
            block.label = this._st.readByte();
            switch (block.label) {
                case 0xf9:
                    block.extType = 'gce';
                    parseGCExt(block);
                    break;
                case 0xfe:
                    block.extType = 'com';
                    parseComExt(block);
                    break;
                case 0x01:
                    block.extType = 'pte';
                    parsePTExt(block);
                    break;
                case 0xff:
                    block.extType = 'app';
                    parseAppExt(block);
                    break;
                default:
                    block.extType = 'unknown';
                    parseUnknownExt(block);
                    break;
            }
        };
        this.parseImg = (img) => {
            const deinterlace = (pixels, width) => {
                // Of course this defeats the purpose of interlacing. And it's *probably*
                // the least efficient way it's ever been implemented. But nevertheless...
                const newPixels = new Array(pixels.length);
                const rows = pixels.length / width;
                const cpRow = (toRow, fromRow) => {
                    const fromPixels = pixels.slice(fromRow * width, (fromRow + 1) * width);
                    newPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels));
                };
                const offsets = [0, 4, 2, 1];
                const steps = [8, 8, 4, 2];
                let fromRow = 0;
                for (let pass = 0; pass < 4; pass++) {
                    for (let toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {
                        cpRow(toRow, fromRow);
                        fromRow++;
                    }
                }
                return newPixels;
            };
            img.leftPos = this._st.readUnsigned();
            img.topPos = this._st.readUnsigned();
            img.width = this._st.readUnsigned();
            img.height = this._st.readUnsigned();
            const bits = byteToBitArr(this._st.readByte());
            img.lctFlag = bits.shift();
            img.interlaced = bits.shift();
            img.sorted = bits.shift();
            img.reserved = bits.splice(0, 2);
            img.lctSize = bitsToNum(bits.splice(0, 3));
            if (img.lctFlag) {
                img.lct = this.parseColorTable(1 << (img.lctSize + 1));
            }
            img.lzwMinCodeSize = this._st.readByte();
            const lzwData = this.readSubBlocks();
            img.pixels = lzwDecode(img.lzwMinCodeSize, lzwData);
            if (img.interlaced) {
                // Move
                img.pixels = deinterlace(img.pixels, img.width);
            }
            this.frames.push(img);
            this.arrayToImage(img);
            if (this._handler.img && this._handler.img(img)) {
                this.checkBytes.push(this._handler);
            }
        };
        this.parseBlock = () => {
            const block = {
                sentinel: this._st.readByte(),
                type: ''
            };
            const blockChar = String.fromCharCode(block.sentinel);
            switch (blockChar) {
                case '!':
                    block.type = 'ext';
                    this.parseExt(block);
                    break;
                case ',':
                    block.type = 'img';
                    this.parseImg(block);
                    break;
                case ';':
                    block.type = 'eof';
                    if (this._handler.eof && this._handler.eof(block)) {
                        this.checkBytes.push(this._handler.eof);
                    }
                    break;
                default:
                    throw new Error('Unknown block: 0x' + block.sentinel.toString(16));
            }
            if (block.type !== 'eof') {
                this.parseBlock();
            }
        };
        this.arrayToImage = (frame) => {
            let count = 0;
            const c = document.createElement('canvas');
            c.id = count.toString();
            c.width = frame.width;
            c.height = frame.height;
            count++;
            const context = c.getContext('2d');
            const pixSize = 1;
            let y = 0;
            let x = 0;
            for (let i = 0; i < frame.pixels.length; i++) {
                if (x % frame.width === 0) {
                    y++;
                    x = 0;
                }
                if (this.globalColorTable[frame.pixels[i]] === this._transparentColor.toHex()) {
                    context.fillStyle = `rgba(0, 0, 0, 0)`;
                }
                else {
                    context.fillStyle = this.globalColorTable[frame.pixels[i]];
                }
                context.fillRect(x, y, pixSize, pixSize);
                x++;
            }
            const img = new Image();
            img.src = c.toDataURL();
            this.images.push(img);
        };
        this._st = stream;
        this._handler = {};
        this._transparentColor = color;
        this.parseHeader();
        this.parseBlock();
    }
}

;// CONCATENATED MODULE: ./Resources/Index.ts




;// CONCATENATED MODULE: ./EntityComponentSystem/index.ts











;// CONCATENATED MODULE: ./Graphics/Polygon.ts


/**
 * A polygon [[Graphic]] for drawing arbitrary polygons to the [[ExcaliburGraphicsContext]]
 */
class Polygon_Polygon extends Raster {
    constructor(options) {
        super(options);
        this.points = options.points;
        this.rasterize();
    }
    get points() {
        return this._points;
    }
    set points(points) {
        this._points = points;
        const min = this.minPoint;
        this.width = this._points.reduce((max, p) => Math.max(p.x, max), 0) - min.x;
        this.height = this._points.reduce((max, p) => Math.max(p.y, max), 0) - min.y;
        this.flagDirty();
    }
    get minPoint() {
        const minX = this._points.reduce((min, p) => Math.min(p.x, min), Infinity);
        const minY = this._points.reduce((min, p) => Math.min(p.y, min), Infinity);
        return vec(minX, minY);
    }
    clone() {
        return new Polygon_Polygon(Object.assign(Object.assign({ points: this.points.map((p) => p.clone()) }, this.cloneGraphicOptions()), this.cloneRasterOptions()));
    }
    execute(ctx) {
        if (this.points && this.points.length) {
            ctx.beginPath();
            // Iterate through the supplied points and construct a 'polygon'
            const min = this.minPoint.negate();
            const firstPoint = this.points[0].add(min);
            ctx.moveTo(firstPoint.x, firstPoint.y);
            this.points.forEach((point) => {
                ctx.lineTo(point.x + min.x, point.y + min.y);
            });
            ctx.lineTo(firstPoint.x, firstPoint.y);
            ctx.closePath();
            if (this.color) {
                ctx.fill();
            }
            if (this.strokeColor) {
                ctx.stroke();
            }
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/index.ts
// Graphics






// Graphics ECS


// Raster graphics














;// CONCATENATED MODULE: ./Input/Index.ts
/**
 * @module
 * Provides support for mice, keyboards, and controllers.
 */
/**
 * @typedoc
 */








;// CONCATENATED MODULE: ./Traits/Index.ts
/**
 * @module
 */



;// CONCATENATED MODULE: ./Util/Index.ts







;// CONCATENATED MODULE: ./Util/SortedList.ts
var SortedList_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/**
 * A sorted list implementation. NOTE: this implementation is not self-balancing
 * @deprecated WIll be removed in v0.26.0 Use built in JS array.sort
 */
let SortedList = class SortedList {
    constructor(getComparable) {
        this._getComparable = getComparable;
    }
    find(element) {
        return this._find(this._root, element);
    }
    _find(node, element) {
        if (node == null) {
            return false;
        }
        else if (this._getComparable(element) === node.getKey()) {
            if (node.getData().indexOf(element) > -1) {
                return true;
            }
            else {
                return false;
            }
        }
        else if (this._getComparable(element) < node.getKey()) {
            return this._find(node.getLeft(), element);
        }
        else {
            return this._find(node.getRight(), element);
        }
    }
    // returns the array of elements at a specific key value
    get(key) {
        return this._get(this._root, key);
    }
    _get(node, key) {
        if (node == null) {
            return [];
        }
        else if (key === node.getKey()) {
            return node.getData();
        }
        else if (key < node.getKey()) {
            return this._get(node.getLeft(), key);
        }
        else {
            return this._get(node.getRight(), key);
        }
    }
    add(element) {
        if (this._root == null) {
            this._root = new BinaryTreeNode(this._getComparable(element), [element], null, null);
            return true;
        }
        else {
            return this._insert(this._root, element);
        }
    }
    _insert(node, element) {
        if (node != null) {
            if (this._getComparable(element) === node.getKey()) {
                if (node.getData().indexOf(element) > -1) {
                    return false; // the element we're trying to insert already exists
                }
                else {
                    node.getData().push(element);
                    return true;
                }
            }
            else if (this._getComparable(element) < node.getKey()) {
                if (node.getLeft() == null) {
                    node.setLeft(new BinaryTreeNode(this._getComparable(element), [element], null, null));
                    return true;
                }
                else {
                    return this._insert(node.getLeft(), element);
                }
            }
            else {
                if (node.getRight() == null) {
                    node.setRight(new BinaryTreeNode(this._getComparable(element), [element], null, null));
                    return true;
                }
                else {
                    return this._insert(node.getRight(), element);
                }
            }
        }
        return false;
    }
    removeByComparable(element) {
        this._root = this._remove(this._root, element);
    }
    _remove(node, element) {
        if (node == null) {
            return null;
        }
        else if (this._getComparable(element) === node.getKey()) {
            const elementIndex = node.getData().indexOf(element);
            // if the node contains the element, remove the element
            if (elementIndex > -1) {
                node.getData().splice(elementIndex, 1);
                // if we have removed the last element at this node, remove the node
                if (node.getData().length === 0) {
                    // if the node is a leaf
                    if (node.getLeft() == null && node.getRight() == null) {
                        return null;
                    }
                    else if (node.getLeft() == null) {
                        return node.getRight();
                    }
                    else if (node.getRight() == null) {
                        return node.getLeft();
                    }
                    // if node has 2 children
                    const temp = this._findMinNode(node.getRight());
                    node.setKey(temp.getKey());
                    node.setData(temp.getData());
                    node.setRight(this._cleanup(node.getRight(), temp)); //"cleanup nodes" (move them up recursively)
                    return node;
                }
                else {
                    // this prevents the node from being removed since it still contains elements
                    return node;
                }
            }
        }
        else if (this._getComparable(element) < node.getKey()) {
            node.setLeft(this._remove(node.getLeft(), element));
            return node;
        }
        else {
            node.setRight(this._remove(node.getRight(), element));
            return node;
        }
        return null;
    }
    // called once we have successfully removed the element we wanted, recursively corrects the part of the tree below the removed node
    _cleanup(node, element) {
        const comparable = element.getKey();
        if (node == null) {
            return null;
        }
        else if (comparable === node.getKey()) {
            // if the node is a leaf
            if (node.getLeft() == null && node.getRight() == null) {
                return null;
            }
            else if (node.getLeft() == null) {
                return node.getRight();
            }
            else if (node.getRight() == null) {
                return node.getLeft();
            }
            // if node has 2 children
            const temp = this._findMinNode(node.getRight());
            node.setKey(temp.getKey());
            node.setData(temp.getData());
            node.setRight(this._cleanup(node.getRight(), temp));
            return node;
        }
        else if (element.getKey() < node.getKey()) {
            node.setLeft(this._cleanup(node.getLeft(), element));
            return node;
        }
        else {
            node.setRight(this._cleanup(node.getRight(), element));
            return node;
        }
    }
    _findMinNode(node) {
        let current = node;
        while (current.getLeft() != null) {
            current = current.getLeft();
        }
        return current;
    }
    list() {
        const results = new Array();
        this._list(this._root, results);
        return results;
    }
    _list(treeNode, results) {
        if (treeNode != null) {
            this._list(treeNode.getLeft(), results);
            treeNode.getData().forEach((element) => {
                results.push(element);
            });
            this._list(treeNode.getRight(), results);
        }
    }
};
SortedList = SortedList_decorate([
    obsolete({ message: 'Will be removed in excalibur v0.26.0', alternateMethod: 'Use built in JS array.sort' })
], SortedList);

/**
 * A tree node part of [[SortedList]]
 * @deprecated Will be removed in v0.26.0
 */
let BinaryTreeNode = class BinaryTreeNode {
    constructor(key, data, left, right) {
        this._key = key;
        this._data = data;
        this._left = left;
        this._right = right;
    }
    getKey() {
        return this._key;
    }
    setKey(key) {
        this._key = key;
    }
    getData() {
        return this._data;
    }
    setData(data) {
        this._data = data;
    }
    getLeft() {
        return this._left;
    }
    setLeft(left) {
        this._left = left;
    }
    getRight() {
        return this._right;
    }
    setRight(right) {
        this._right = right;
    }
};
BinaryTreeNode = SortedList_decorate([
    obsolete({ message: 'Will be removed in excalibur v0.26.0' })
], BinaryTreeNode);

/**
 * Mock element for testing
 *
 * @internal
 * @deprecated Will be removed in v0.26.0
 */
class MockedElement {
    constructor(key) {
        this._key = 0;
        this._key = key;
    }
    getTheKey() {
        return this._key;
    }
    setKey(key) {
        this._key = key;
    }
}

;// CONCATENATED MODULE: ./Promises.ts
// Promises/A+ Spec http://promises-aplus.github.io/promises-spec/
var Promises_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Promise_1;

/**
 * Valid states for a promise to be in
 * @deprecated Will be removed in v0.26.0
 */
var PromiseState;
(function (PromiseState) {
    PromiseState[PromiseState["Resolved"] = 0] = "Resolved";
    PromiseState[PromiseState["Rejected"] = 1] = "Rejected";
    PromiseState[PromiseState["Pending"] = 2] = "Pending";
})(PromiseState || (PromiseState = {}));
/**
 * Promises are used to do asynchronous work and they are useful for
 * creating a chain of actions. In Excalibur they are used for loading,
 * sounds, animation, actions, and more.
 * @deprecated Will be removed in v0.26.0
 */
let Promises_Promise = Promise_1 = class Promise {
    constructor() {
        this._state = PromiseState.Pending;
        this._successCallbacks = [];
        this._rejectCallback = () => {
            return;
        };
    }
    /**
     * Create and resolve a Promise with an optional value
     * @param value  An optional value to wrap in a resolved promise
     * @deprecated Use browser native promises
     */
    static resolve(value) {
        const promise = new Promise_1().resolve(value);
        return promise;
    }
    /**
     * Create and reject a Promise with an optional value
     * @param value  An optional value to wrap in a rejected promise
     * @deprecated Use browser native promises
     */
    static reject(value) {
        const promise = new Promise_1().reject(value);
        return promise;
    }
    static join() {
        let promises = [];
        if (arguments.length > 0 && !Array.isArray(arguments[0])) {
            for (let _i = 0; _i < arguments.length; _i++) {
                promises[_i - 0] = arguments[_i];
            }
        }
        else if (arguments.length === 1 && Array.isArray(arguments[0])) {
            promises = arguments[0];
        }
        const joinedPromise = new Promise_1();
        if (!promises || !promises.length) {
            return joinedPromise.resolve();
        }
        const total = promises.length;
        let successes = 0;
        let rejects = 0;
        const errors = [];
        promises.forEach((p) => {
            p.then(() => {
                successes += 1;
                if (successes === total) {
                    joinedPromise.resolve();
                }
                else if (successes + rejects + errors.length === total) {
                    joinedPromise.reject(errors);
                }
            }, () => {
                rejects += 1;
                if (successes + rejects + errors.length === total) {
                    joinedPromise.reject(errors);
                }
            }).error((e) => {
                errors.push(e);
                if (errors.length + successes + rejects === total) {
                    joinedPromise.reject(errors);
                }
            });
        });
        return joinedPromise;
    }
    /**
     * Chain success and reject callbacks after the promise is resolved
     * @param successCallback  Call on resolution of promise
     * @param rejectCallback   Call on rejection of promise
     * @deprecated Use browser native promises
     */
    then(successCallback, rejectCallback) {
        if (successCallback) {
            this._successCallbacks.push(successCallback);
            // If the promise is already resolved call immediately
            if (this.state() === PromiseState.Resolved) {
                try {
                    successCallback.call(this, this._value);
                }
                catch (e) {
                    this._handleError(e);
                }
            }
        }
        if (rejectCallback) {
            this._rejectCallback = rejectCallback;
            // If the promise is already rejected call immediately
            if (this.state() === PromiseState.Rejected) {
                try {
                    rejectCallback.call(this, this._value);
                }
                catch (e) {
                    this._handleError(e);
                }
            }
        }
        return this;
    }
    /**
     * Add an error callback to the promise
     * @param errorCallback  Call if there was an error in a callback
     * @deprecated Use browser native promises
     */
    error(errorCallback) {
        if (errorCallback) {
            this._errorCallback = errorCallback;
        }
        return this;
    }
    /**
     * Resolve the promise and pass an option value to the success callbacks
     * @param value  Value to pass to the success callbacks
     * @deprecated Use browser native promises
     */
    resolve(value) {
        if (this._state === PromiseState.Pending) {
            this._value = value;
            try {
                this._state = PromiseState.Resolved;
                this._successCallbacks.forEach((cb) => {
                    cb.call(this, this._value);
                });
            }
            catch (e) {
                this._handleError(e);
            }
        }
        else {
            throw new Error('Cannot resolve a promise that is not in a pending state!');
        }
        return this;
    }
    /**
     * Reject the promise and pass an option value to the reject callbacks
     * @param value  Value to pass to the reject callbacks
     * @deprecated Use browser native promises
     */
    reject(value) {
        if (this._state === PromiseState.Pending) {
            this._value = value;
            try {
                this._state = PromiseState.Rejected;
                this._rejectCallback.call(this, this._value);
            }
            catch (e) {
                this._handleError(e);
            }
        }
        else {
            throw new Error('Cannot reject a promise that is not in a pending state!');
        }
        return this;
    }
    /**
     * Inspect the current state of a promise
     * @deprecated Use browser native promises
     */
    state() {
        return this._state;
    }
    _handleError(e) {
        if (this._errorCallback) {
            this._errorCallback.call(this, e);
        }
        else {
            // rethrow error
            throw e;
        }
    }
};
Promises_Promise = Promise_1 = Promises_decorate([
    obsolete({
        message: 'ex.Promises are being replaced by native browser promises in v0.26.0',
        alternateMethod: 'Use browser native promises'
    })
], Promises_Promise);


;// CONCATENATED MODULE: ./index.ts
/**
 * The current Excalibur version string
 * @description `process.env.__EX_VERSION` gets replaced by Webpack on build
 */
const EX_VERSION = "0.25.1";

polyfill();
// This file is used as the bundle entry point and exports everything
// that will be exposed as the `ex` global variable.

























// ex.LegacyDrawing namespace








// ex.Events namespace


// ex.Input namespace


// ex.Traits namespace


// ex.Util namespaces












// ex.Deprecated

// import * as deprecated from './Deprecated';
// export { deprecated as Deprecated };
// export * from './Deprecated';

})();

var __webpack_exports__ActionContext = __webpack_exports__.fWn;
var __webpack_exports__ActionQueue = __webpack_exports__.Ia8;
var __webpack_exports__ActionsComponent = __webpack_exports__.hLI;
var __webpack_exports__ActionsSystem = __webpack_exports__.yyv;
var __webpack_exports__ActivateEvent = __webpack_exports__.tX5;
var __webpack_exports__Actor = __webpack_exports__.vtX;
var __webpack_exports__AddedComponent = __webpack_exports__.r7K;
var __webpack_exports__AddedEntity = __webpack_exports__.lCh;
var __webpack_exports__Animation = __webpack_exports__.fwF;
var __webpack_exports__AnimationDirection = __webpack_exports__.sce;
var __webpack_exports__AnimationStrategy = __webpack_exports__._c7;
var __webpack_exports__ArcadeSolver = __webpack_exports__.KUs;
var __webpack_exports__AudioContextFactory = __webpack_exports__.Ajp;
var __webpack_exports__Axis = __webpack_exports__.RDh;
var __webpack_exports__BaseAlign = __webpack_exports__._H9;
var __webpack_exports__BinaryTreeNode = __webpack_exports__.Ulf;
var __webpack_exports__Blink = __webpack_exports__.mxs;
var __webpack_exports__BodyComponent = __webpack_exports__.OmD;
var __webpack_exports__BoundingBox = __webpack_exports__.kBf;
var __webpack_exports__BroadphaseStrategy = __webpack_exports__.C4F;
var __webpack_exports__BrowserComponent = __webpack_exports__.NQt;
var __webpack_exports__BrowserEvents = __webpack_exports__.JjN;
var __webpack_exports__Camera = __webpack_exports__.V1s;
var __webpack_exports__Canvas = __webpack_exports__.Xz7;
var __webpack_exports__Cell = __webpack_exports__.bLd;
var __webpack_exports__Circle = __webpack_exports__.Cdc;
var __webpack_exports__CircleCollider = __webpack_exports__.FKn;
var __webpack_exports__Class = __webpack_exports__.wTW;
var __webpack_exports__ClosestLine = __webpack_exports__.ab2;
var __webpack_exports__ClosestLineJumpTable = __webpack_exports__.GfZ;
var __webpack_exports__Collider = __webpack_exports__.YMS;
var __webpack_exports__ColliderComponent = __webpack_exports__.oyv;
var __webpack_exports__CollisionContact = __webpack_exports__.aUb;
var __webpack_exports__CollisionEndEvent = __webpack_exports__.SdD;
var __webpack_exports__CollisionGroup = __webpack_exports__.JUv;
var __webpack_exports__CollisionGroupManager = __webpack_exports__.jEj;
var __webpack_exports__CollisionJumpTable = __webpack_exports__.TFq;
var __webpack_exports__CollisionPostSolveEvent = __webpack_exports__.HDU;
var __webpack_exports__CollisionPreSolveEvent = __webpack_exports__.R_y;
var __webpack_exports__CollisionResolutionStrategy = __webpack_exports__.ydN;
var __webpack_exports__CollisionSolver = __webpack_exports__._N2;
var __webpack_exports__CollisionStartEvent = __webpack_exports__.t50;
var __webpack_exports__CollisionSystem = __webpack_exports__.s$$;
var __webpack_exports__CollisionType = __webpack_exports__.v2G;
var __webpack_exports__Color = __webpack_exports__.Ilk;
var __webpack_exports__ColorBlindCorrector = __webpack_exports__.H_9;
var __webpack_exports__ColorBlindFlags = __webpack_exports__.s9i;
var __webpack_exports__ColorBlindness = __webpack_exports__.ksl;
var __webpack_exports__Component = __webpack_exports__.wA2;
var __webpack_exports__CompositeCollider = __webpack_exports__.R_p;
var __webpack_exports__Configurable = __webpack_exports__.IQ$;
var __webpack_exports__ConsoleAppender = __webpack_exports__.I5F;
var __webpack_exports__ContactConstraintPoint = __webpack_exports__.X8$;
var __webpack_exports__ContactEndEvent = __webpack_exports__.FR6;
var __webpack_exports__ContactStartEvent = __webpack_exports__.U8o;
var __webpack_exports__CoordPlane = __webpack_exports__.kbG;
var __webpack_exports__CullingBox = __webpack_exports__.oeJ;
var __webpack_exports__DeactivateEvent = __webpack_exports__.iS_;
var __webpack_exports__Debug = __webpack_exports__.cGG;
var __webpack_exports__DebugSystem = __webpack_exports__.skb;
var __webpack_exports__DebugText = __webpack_exports__.SLU;
var __webpack_exports__DegreeOfFreedom = __webpack_exports__.RdJ;
var __webpack_exports__Detector = __webpack_exports__.gU7;
var __webpack_exports__Die = __webpack_exports__.LSk;
var __webpack_exports__Direction = __webpack_exports__.Nmp;
var __webpack_exports__DisplayMode = __webpack_exports__.d1Y;
var __webpack_exports__DynamicTree = __webpack_exports__.xrL;
var __webpack_exports__DynamicTreeCollisionProcessor = __webpack_exports__.sRW;
var __webpack_exports__EX_VERSION = __webpack_exports__.cmV;
var __webpack_exports__EaseTo = __webpack_exports__.N0Q;
var __webpack_exports__EasingFunctions = __webpack_exports__.q8b;
var __webpack_exports__EdgeCollider = __webpack_exports__.ynB;
var __webpack_exports__ElasticToActorStrategy = __webpack_exports__.jT9;
var __webpack_exports__EmitterType = __webpack_exports__.wAz;
var __webpack_exports__Engine = __webpack_exports__.D4V;
var __webpack_exports__EnterTriggerEvent = __webpack_exports__.N6H;
var __webpack_exports__EnterViewPortEvent = __webpack_exports__.W1A;
var __webpack_exports__Entity = __webpack_exports__.JHW;
var __webpack_exports__EntityManager = __webpack_exports__.v2K;
var __webpack_exports__EventDispatcher = __webpack_exports__.pBf;
var __webpack_exports__EventTypes = __webpack_exports__.GMl;
var __webpack_exports__Events = __webpack_exports__.zW2;
var __webpack_exports__ExResponse = __webpack_exports__.B0K;
var __webpack_exports__ExcaliburGraphicsContext2DCanvas = __webpack_exports__.Nv7;
var __webpack_exports__ExcaliburGraphicsContextWebGL = __webpack_exports__.C_p;
var __webpack_exports__ExitTriggerEvent = __webpack_exports__.MUA;
var __webpack_exports__ExitViewPortEvent = __webpack_exports__.xqU;
var __webpack_exports__Experiments = __webpack_exports__.peG;
var __webpack_exports__Fade = __webpack_exports__.pTp;
var __webpack_exports__Flags = __webpack_exports__.vUK;
var __webpack_exports__Follow = __webpack_exports__.j9l;
var __webpack_exports__Font = __webpack_exports__.Zxw;
var __webpack_exports__FontStyle = __webpack_exports__.Hdx;
var __webpack_exports__FontUnit = __webpack_exports__.Z$d;
var __webpack_exports__FrameStats = __webpack_exports__.o$7;
var __webpack_exports__GameEvent = __webpack_exports__.Zm$;
var __webpack_exports__GameStartEvent = __webpack_exports__.$QH;
var __webpack_exports__GameStopEvent = __webpack_exports__.i78;
var __webpack_exports__GamepadAxisEvent = __webpack_exports__.h6u;
var __webpack_exports__GamepadButtonEvent = __webpack_exports__.hts;
var __webpack_exports__GamepadConnectEvent = __webpack_exports__.j88;
var __webpack_exports__GamepadDisconnectEvent = __webpack_exports__.VME;
var __webpack_exports__Gif = __webpack_exports__.nt;
var __webpack_exports__GlobalCoordinates = __webpack_exports__.Ukr;
var __webpack_exports__Graphic = __webpack_exports__.zsu;
var __webpack_exports__GraphicsComponent = __webpack_exports__.oA6;
var __webpack_exports__GraphicsGroup = __webpack_exports__.TVh;
var __webpack_exports__GraphicsLayer = __webpack_exports__.TwZ;
var __webpack_exports__GraphicsLayers = __webpack_exports__.GTT;
var __webpack_exports__GraphicsSystem = __webpack_exports__.xxj;
var __webpack_exports__HiddenEvent = __webpack_exports__.XdK;
var __webpack_exports__ImageSource = __webpack_exports__.cXo;
var __webpack_exports__InitializeEvent = __webpack_exports__.Dm5;
var __webpack_exports__Input = __webpack_exports__.IIB;
var __webpack_exports__Integrator = __webpack_exports__.zI0;
var __webpack_exports__KillEvent = __webpack_exports__.SKZ;
var __webpack_exports__Label = __webpack_exports__.__J;
var __webpack_exports__Legacy = __webpack_exports__.Dvr;
var __webpack_exports__LegacyDrawing = __webpack_exports__.Tf9;
var __webpack_exports__LimitCameraBoundsStrategy = __webpack_exports__.RI$;
var __webpack_exports__Line = __webpack_exports__.x12;
var __webpack_exports__Loader = __webpack_exports__.aNw;
var __webpack_exports__LockCameraToActorAxisStrategy = __webpack_exports__.xwn;
var __webpack_exports__LockCameraToActorStrategy = __webpack_exports__.dNK;
var __webpack_exports__LogLevel = __webpack_exports__.ini;
var __webpack_exports__Logger = __webpack_exports__.YdH;
var __webpack_exports__Matrix = __webpack_exports__.y3G;
var __webpack_exports__MatrixLocations = __webpack_exports__.l57;
var __webpack_exports__MediaEvent = __webpack_exports__.xn0;
var __webpack_exports__Meet = __webpack_exports__.t2V;
var __webpack_exports__MockedElement = __webpack_exports__.ZyS;
var __webpack_exports__MotionComponent = __webpack_exports__.uxB;
var __webpack_exports__MotionSystem = __webpack_exports__.cpd;
var __webpack_exports__MoveBy = __webpack_exports__.fiy;
var __webpack_exports__MoveTo = __webpack_exports__.$XZ;
var __webpack_exports__NativeSoundEvent = __webpack_exports__.uqK;
var __webpack_exports__NativeSoundProcessedEvent = __webpack_exports__.STE;
var __webpack_exports__Observable = __webpack_exports__.y$z;
var __webpack_exports__Pair = __webpack_exports__.sOq;
var __webpack_exports__ParseGif = __webpack_exports__.Sqs;
var __webpack_exports__Particle = __webpack_exports__.hpZ;
var __webpack_exports__ParticleEmitter = __webpack_exports__.Vol;
var __webpack_exports__Physics = __webpack_exports__.wIZ;
var __webpack_exports__PhysicsStats = __webpack_exports__.cBi;
var __webpack_exports__Polygon = __webpack_exports__.mgq;
var __webpack_exports__PolygonCollider = __webpack_exports__.YVA;
var __webpack_exports__Pool = __webpack_exports__.Kgp;
var __webpack_exports__PostCollisionEvent = __webpack_exports__.HH$;
var __webpack_exports__PostDebugDrawEvent = __webpack_exports__.M_d;
var __webpack_exports__PostDrawEvent = __webpack_exports__.rgh;
var __webpack_exports__PostFrameEvent = __webpack_exports__.Ra6;
var __webpack_exports__PostKillEvent = __webpack_exports__.KhR;
var __webpack_exports__PostUpdateEvent = __webpack_exports__.BS5;
var __webpack_exports__PreCollisionEvent = __webpack_exports__.xhz;
var __webpack_exports__PreDebugDrawEvent = __webpack_exports__.xOq;
var __webpack_exports__PreDrawEvent = __webpack_exports__.a9j;
var __webpack_exports__PreFrameEvent = __webpack_exports__.bHk;
var __webpack_exports__PreKillEvent = __webpack_exports__.CgK;
var __webpack_exports__PreUpdateEvent = __webpack_exports__.cuY;
var __webpack_exports__Projection = __webpack_exports__.kvE;
var __webpack_exports__Promise = __webpack_exports__.JDb;
var __webpack_exports__PromiseState = __webpack_exports__.Cbi;
var __webpack_exports__Query = __webpack_exports__.AE_;
var __webpack_exports__QueryManager = __webpack_exports__.ctO;
var __webpack_exports__RadiusAroundActorStrategy = __webpack_exports__.OLH;
var __webpack_exports__Random = __webpack_exports__.kky;
var __webpack_exports__Raster = __webpack_exports__.nSF;
var __webpack_exports__Ray = __webpack_exports__.zHn;
var __webpack_exports__RealisticSolver = __webpack_exports__.zwx;
var __webpack_exports__Rectangle = __webpack_exports__.AeJ;
var __webpack_exports__RemovedComponent = __webpack_exports__.hLz;
var __webpack_exports__RemovedEntity = __webpack_exports__.D9g;
var __webpack_exports__Repeat = __webpack_exports__.wA;
var __webpack_exports__RepeatForever = __webpack_exports__.jhr;
var __webpack_exports__Resolution = __webpack_exports__.GVs;
var __webpack_exports__Resource = __webpack_exports__._zO;
var __webpack_exports__RotateBy = __webpack_exports__.w6$;
var __webpack_exports__RotateTo = __webpack_exports__.mhV;
var __webpack_exports__RotationType = __webpack_exports__.MOD;
var __webpack_exports__ScaleBy = __webpack_exports__.kwd;
var __webpack_exports__ScaleTo = __webpack_exports__.Lmr;
var __webpack_exports__Scene = __webpack_exports__.xsS;
var __webpack_exports__Screen = __webpack_exports__.lLr;
var __webpack_exports__ScreenAppender = __webpack_exports__.Z$r;
var __webpack_exports__ScreenElement = __webpack_exports__.IXb;
var __webpack_exports__ScrollPreventionMode = __webpack_exports__.SMj;
var __webpack_exports__Shape = __webpack_exports__.bnF;
var __webpack_exports__Side = __webpack_exports__.MFA;
var __webpack_exports__SortedList = __webpack_exports__.$XC;
var __webpack_exports__Sound = __webpack_exports__.$uU;
var __webpack_exports__Sprite = __webpack_exports__.jyi;
var __webpack_exports__SpriteFont = __webpack_exports__.E03;
var __webpack_exports__SpriteSheet = __webpack_exports__.V6q;
var __webpack_exports__StrategyContainer = __webpack_exports__.nVo;
var __webpack_exports__Stream = __webpack_exports__.F6N;
var __webpack_exports__SubscribeEvent = __webpack_exports__.ad3;
var __webpack_exports__System = __webpack_exports__.xP7;
var __webpack_exports__SystemManager = __webpack_exports__.Odq;
var __webpack_exports__SystemType = __webpack_exports__.Zif;
var __webpack_exports__TagComponent = __webpack_exports__.ZGJ;
var __webpack_exports__Text = __webpack_exports__.xvT;
var __webpack_exports__TextAlign = __webpack_exports__.PHM;
var __webpack_exports__TileMap = __webpack_exports__.KwO;
var __webpack_exports__Timer = __webpack_exports__.B7y;
var __webpack_exports__Traits = __webpack_exports__.SFp;
var __webpack_exports__TransformComponent = __webpack_exports__.Uvn;
var __webpack_exports__TreeNode = __webpack_exports__.OFT;
var __webpack_exports__Trigger = __webpack_exports__.xzN;
var __webpack_exports__UnsubscribeEvent = __webpack_exports__.H6j;
var __webpack_exports__Util = __webpack_exports__.ZrN;
var __webpack_exports__Vector = __webpack_exports__.OWs;
var __webpack_exports__VectorView = __webpack_exports__.dF9;
var __webpack_exports__VisibleEvent = __webpack_exports__.VHo;
var __webpack_exports__WebAudioInstance = __webpack_exports__.R$E;
var __webpack_exports__World = __webpack_exports__.q3I;
var __webpack_exports__canonicalizeAngle = __webpack_exports__.Pab;
var __webpack_exports__clamp = __webpack_exports__.uZ5;
var __webpack_exports__createId = __webpack_exports__.McK;
var __webpack_exports__hasGraphicsTick = __webpack_exports__.k0b;
var __webpack_exports__hasOnInitialize = __webpack_exports__.hnT;
var __webpack_exports__hasOnPostUpdate = __webpack_exports__.RSJ;
var __webpack_exports__hasOnPreUpdate = __webpack_exports__.Mku;
var __webpack_exports__hasPostDraw = __webpack_exports__.h90;
var __webpack_exports__hasPreDraw = __webpack_exports__.rms;
var __webpack_exports__has_initialize = __webpack_exports__.ErP;
var __webpack_exports__has_postupdate = __webpack_exports__.aVg;
var __webpack_exports__has_preupdate = __webpack_exports__.lPc;
var __webpack_exports__isAddedComponent = __webpack_exports__.Z8E;
var __webpack_exports__isAddedSystemEntity = __webpack_exports__.NNA;
var __webpack_exports__isRemoveSystemEntity = __webpack_exports__.yFn;
var __webpack_exports__isRemovedComponent = __webpack_exports__.lNv;
var __webpack_exports__maxMessages = __webpack_exports__.MZQ;
var __webpack_exports__obsolete = __webpack_exports__.FUM;
var __webpack_exports__randomInRange = __webpack_exports__.vdf;
var __webpack_exports__randomIntInRange = __webpack_exports__.iaL;
var __webpack_exports__range = __webpack_exports__.w6H;
var __webpack_exports__resetObsoleteCounter = __webpack_exports__.Q4c;
var __webpack_exports__toDegrees = __webpack_exports__.Uxb;
var __webpack_exports__toRadians = __webpack_exports__.Yr5;
var __webpack_exports__vec = __webpack_exports__.Bhw;
export { __webpack_exports__ActionContext as ActionContext, __webpack_exports__ActionQueue as ActionQueue, __webpack_exports__ActionsComponent as ActionsComponent, __webpack_exports__ActionsSystem as ActionsSystem, __webpack_exports__ActivateEvent as ActivateEvent, __webpack_exports__Actor as Actor, __webpack_exports__AddedComponent as AddedComponent, __webpack_exports__AddedEntity as AddedEntity, __webpack_exports__Animation as Animation, __webpack_exports__AnimationDirection as AnimationDirection, __webpack_exports__AnimationStrategy as AnimationStrategy, __webpack_exports__ArcadeSolver as ArcadeSolver, __webpack_exports__AudioContextFactory as AudioContextFactory, __webpack_exports__Axis as Axis, __webpack_exports__BaseAlign as BaseAlign, __webpack_exports__BinaryTreeNode as BinaryTreeNode, __webpack_exports__Blink as Blink, __webpack_exports__BodyComponent as BodyComponent, __webpack_exports__BoundingBox as BoundingBox, __webpack_exports__BroadphaseStrategy as BroadphaseStrategy, __webpack_exports__BrowserComponent as BrowserComponent, __webpack_exports__BrowserEvents as BrowserEvents, __webpack_exports__Camera as Camera, __webpack_exports__Canvas as Canvas, __webpack_exports__Cell as Cell, __webpack_exports__Circle as Circle, __webpack_exports__CircleCollider as CircleCollider, __webpack_exports__Class as Class, __webpack_exports__ClosestLine as ClosestLine, __webpack_exports__ClosestLineJumpTable as ClosestLineJumpTable, __webpack_exports__Collider as Collider, __webpack_exports__ColliderComponent as ColliderComponent, __webpack_exports__CollisionContact as CollisionContact, __webpack_exports__CollisionEndEvent as CollisionEndEvent, __webpack_exports__CollisionGroup as CollisionGroup, __webpack_exports__CollisionGroupManager as CollisionGroupManager, __webpack_exports__CollisionJumpTable as CollisionJumpTable, __webpack_exports__CollisionPostSolveEvent as CollisionPostSolveEvent, __webpack_exports__CollisionPreSolveEvent as CollisionPreSolveEvent, __webpack_exports__CollisionResolutionStrategy as CollisionResolutionStrategy, __webpack_exports__CollisionSolver as CollisionSolver, __webpack_exports__CollisionStartEvent as CollisionStartEvent, __webpack_exports__CollisionSystem as CollisionSystem, __webpack_exports__CollisionType as CollisionType, __webpack_exports__Color as Color, __webpack_exports__ColorBlindCorrector as ColorBlindCorrector, __webpack_exports__ColorBlindFlags as ColorBlindFlags, __webpack_exports__ColorBlindness as ColorBlindness, __webpack_exports__Component as Component, __webpack_exports__CompositeCollider as CompositeCollider, __webpack_exports__Configurable as Configurable, __webpack_exports__ConsoleAppender as ConsoleAppender, __webpack_exports__ContactConstraintPoint as ContactConstraintPoint, __webpack_exports__ContactEndEvent as ContactEndEvent, __webpack_exports__ContactStartEvent as ContactStartEvent, __webpack_exports__CoordPlane as CoordPlane, __webpack_exports__CullingBox as CullingBox, __webpack_exports__DeactivateEvent as DeactivateEvent, __webpack_exports__Debug as Debug, __webpack_exports__DebugSystem as DebugSystem, __webpack_exports__DebugText as DebugText, __webpack_exports__DegreeOfFreedom as DegreeOfFreedom, __webpack_exports__Detector as Detector, __webpack_exports__Die as Die, __webpack_exports__Direction as Direction, __webpack_exports__DisplayMode as DisplayMode, __webpack_exports__DynamicTree as DynamicTree, __webpack_exports__DynamicTreeCollisionProcessor as DynamicTreeCollisionProcessor, __webpack_exports__EX_VERSION as EX_VERSION, __webpack_exports__EaseTo as EaseTo, __webpack_exports__EasingFunctions as EasingFunctions, __webpack_exports__EdgeCollider as EdgeCollider, __webpack_exports__ElasticToActorStrategy as ElasticToActorStrategy, __webpack_exports__EmitterType as EmitterType, __webpack_exports__Engine as Engine, __webpack_exports__EnterTriggerEvent as EnterTriggerEvent, __webpack_exports__EnterViewPortEvent as EnterViewPortEvent, __webpack_exports__Entity as Entity, __webpack_exports__EntityManager as EntityManager, __webpack_exports__EventDispatcher as EventDispatcher, __webpack_exports__EventTypes as EventTypes, __webpack_exports__Events as Events, __webpack_exports__ExResponse as ExResponse, __webpack_exports__ExcaliburGraphicsContext2DCanvas as ExcaliburGraphicsContext2DCanvas, __webpack_exports__ExcaliburGraphicsContextWebGL as ExcaliburGraphicsContextWebGL, __webpack_exports__ExitTriggerEvent as ExitTriggerEvent, __webpack_exports__ExitViewPortEvent as ExitViewPortEvent, __webpack_exports__Experiments as Experiments, __webpack_exports__Fade as Fade, __webpack_exports__Flags as Flags, __webpack_exports__Follow as Follow, __webpack_exports__Font as Font, __webpack_exports__FontStyle as FontStyle, __webpack_exports__FontUnit as FontUnit, __webpack_exports__FrameStats as FrameStats, __webpack_exports__GameEvent as GameEvent, __webpack_exports__GameStartEvent as GameStartEvent, __webpack_exports__GameStopEvent as GameStopEvent, __webpack_exports__GamepadAxisEvent as GamepadAxisEvent, __webpack_exports__GamepadButtonEvent as GamepadButtonEvent, __webpack_exports__GamepadConnectEvent as GamepadConnectEvent, __webpack_exports__GamepadDisconnectEvent as GamepadDisconnectEvent, __webpack_exports__Gif as Gif, __webpack_exports__GlobalCoordinates as GlobalCoordinates, __webpack_exports__Graphic as Graphic, __webpack_exports__GraphicsComponent as GraphicsComponent, __webpack_exports__GraphicsGroup as GraphicsGroup, __webpack_exports__GraphicsLayer as GraphicsLayer, __webpack_exports__GraphicsLayers as GraphicsLayers, __webpack_exports__GraphicsSystem as GraphicsSystem, __webpack_exports__HiddenEvent as HiddenEvent, __webpack_exports__ImageSource as ImageSource, __webpack_exports__InitializeEvent as InitializeEvent, __webpack_exports__Input as Input, __webpack_exports__Integrator as Integrator, __webpack_exports__KillEvent as KillEvent, __webpack_exports__Label as Label, __webpack_exports__Legacy as Legacy, __webpack_exports__LegacyDrawing as LegacyDrawing, __webpack_exports__LimitCameraBoundsStrategy as LimitCameraBoundsStrategy, __webpack_exports__Line as Line, __webpack_exports__Loader as Loader, __webpack_exports__LockCameraToActorAxisStrategy as LockCameraToActorAxisStrategy, __webpack_exports__LockCameraToActorStrategy as LockCameraToActorStrategy, __webpack_exports__LogLevel as LogLevel, __webpack_exports__Logger as Logger, __webpack_exports__Matrix as Matrix, __webpack_exports__MatrixLocations as MatrixLocations, __webpack_exports__MediaEvent as MediaEvent, __webpack_exports__Meet as Meet, __webpack_exports__MockedElement as MockedElement, __webpack_exports__MotionComponent as MotionComponent, __webpack_exports__MotionSystem as MotionSystem, __webpack_exports__MoveBy as MoveBy, __webpack_exports__MoveTo as MoveTo, __webpack_exports__NativeSoundEvent as NativeSoundEvent, __webpack_exports__NativeSoundProcessedEvent as NativeSoundProcessedEvent, __webpack_exports__Observable as Observable, __webpack_exports__Pair as Pair, __webpack_exports__ParseGif as ParseGif, __webpack_exports__Particle as Particle, __webpack_exports__ParticleEmitter as ParticleEmitter, __webpack_exports__Physics as Physics, __webpack_exports__PhysicsStats as PhysicsStats, __webpack_exports__Polygon as Polygon, __webpack_exports__PolygonCollider as PolygonCollider, __webpack_exports__Pool as Pool, __webpack_exports__PostCollisionEvent as PostCollisionEvent, __webpack_exports__PostDebugDrawEvent as PostDebugDrawEvent, __webpack_exports__PostDrawEvent as PostDrawEvent, __webpack_exports__PostFrameEvent as PostFrameEvent, __webpack_exports__PostKillEvent as PostKillEvent, __webpack_exports__PostUpdateEvent as PostUpdateEvent, __webpack_exports__PreCollisionEvent as PreCollisionEvent, __webpack_exports__PreDebugDrawEvent as PreDebugDrawEvent, __webpack_exports__PreDrawEvent as PreDrawEvent, __webpack_exports__PreFrameEvent as PreFrameEvent, __webpack_exports__PreKillEvent as PreKillEvent, __webpack_exports__PreUpdateEvent as PreUpdateEvent, __webpack_exports__Projection as Projection, __webpack_exports__Promise as Promise, __webpack_exports__PromiseState as PromiseState, __webpack_exports__Query as Query, __webpack_exports__QueryManager as QueryManager, __webpack_exports__RadiusAroundActorStrategy as RadiusAroundActorStrategy, __webpack_exports__Random as Random, __webpack_exports__Raster as Raster, __webpack_exports__Ray as Ray, __webpack_exports__RealisticSolver as RealisticSolver, __webpack_exports__Rectangle as Rectangle, __webpack_exports__RemovedComponent as RemovedComponent, __webpack_exports__RemovedEntity as RemovedEntity, __webpack_exports__Repeat as Repeat, __webpack_exports__RepeatForever as RepeatForever, __webpack_exports__Resolution as Resolution, __webpack_exports__Resource as Resource, __webpack_exports__RotateBy as RotateBy, __webpack_exports__RotateTo as RotateTo, __webpack_exports__RotationType as RotationType, __webpack_exports__ScaleBy as ScaleBy, __webpack_exports__ScaleTo as ScaleTo, __webpack_exports__Scene as Scene, __webpack_exports__Screen as Screen, __webpack_exports__ScreenAppender as ScreenAppender, __webpack_exports__ScreenElement as ScreenElement, __webpack_exports__ScrollPreventionMode as ScrollPreventionMode, __webpack_exports__Shape as Shape, __webpack_exports__Side as Side, __webpack_exports__SortedList as SortedList, __webpack_exports__Sound as Sound, __webpack_exports__Sprite as Sprite, __webpack_exports__SpriteFont as SpriteFont, __webpack_exports__SpriteSheet as SpriteSheet, __webpack_exports__StrategyContainer as StrategyContainer, __webpack_exports__Stream as Stream, __webpack_exports__SubscribeEvent as SubscribeEvent, __webpack_exports__System as System, __webpack_exports__SystemManager as SystemManager, __webpack_exports__SystemType as SystemType, __webpack_exports__TagComponent as TagComponent, __webpack_exports__Text as Text, __webpack_exports__TextAlign as TextAlign, __webpack_exports__TileMap as TileMap, __webpack_exports__Timer as Timer, __webpack_exports__Traits as Traits, __webpack_exports__TransformComponent as TransformComponent, __webpack_exports__TreeNode as TreeNode, __webpack_exports__Trigger as Trigger, __webpack_exports__UnsubscribeEvent as UnsubscribeEvent, __webpack_exports__Util as Util, __webpack_exports__Vector as Vector, __webpack_exports__VectorView as VectorView, __webpack_exports__VisibleEvent as VisibleEvent, __webpack_exports__WebAudioInstance as WebAudioInstance, __webpack_exports__World as World, __webpack_exports__canonicalizeAngle as canonicalizeAngle, __webpack_exports__clamp as clamp, __webpack_exports__createId as createId, __webpack_exports__hasGraphicsTick as hasGraphicsTick, __webpack_exports__hasOnInitialize as hasOnInitialize, __webpack_exports__hasOnPostUpdate as hasOnPostUpdate, __webpack_exports__hasOnPreUpdate as hasOnPreUpdate, __webpack_exports__hasPostDraw as hasPostDraw, __webpack_exports__hasPreDraw as hasPreDraw, __webpack_exports__has_initialize as has_initialize, __webpack_exports__has_postupdate as has_postupdate, __webpack_exports__has_preupdate as has_preupdate, __webpack_exports__isAddedComponent as isAddedComponent, __webpack_exports__isAddedSystemEntity as isAddedSystemEntity, __webpack_exports__isRemoveSystemEntity as isRemoveSystemEntity, __webpack_exports__isRemovedComponent as isRemovedComponent, __webpack_exports__maxMessages as maxMessages, __webpack_exports__obsolete as obsolete, __webpack_exports__randomInRange as randomInRange, __webpack_exports__randomIntInRange as randomIntInRange, __webpack_exports__range as range, __webpack_exports__resetObsoleteCounter as resetObsoleteCounter, __webpack_exports__toDegrees as toDegrees, __webpack_exports__toRadians as toRadians, __webpack_exports__vec as vec };

//# sourceMappingURL=excalibur.js.map